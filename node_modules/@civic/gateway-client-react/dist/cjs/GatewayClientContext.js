"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGateway = exports.GatewayProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = __importStar(require("react"));
const gateway_client_core_1 = __importStar(require("@civic/gateway-client-core"));
const iframe_resizer_react_1 = __importDefault(require("iframe-resizer-react"));
const R = __importStar(require("ramda"));
const types_1 = require("./types");
const Wrapper_1 = require("./wrapper/Wrapper");
const constants_1 = require("./lib/constants");
const gatewayUtils_1 = require("./lib/gatewayUtils");
const version_1 = require("./version");
const pageUnloadHook_1 = require("./lib/pageUnloadHook");
const GatewayContext = react_1.default.createContext({
    requestGatewayToken: async () => { },
    gatewayStatus: types_1.GatewayStatus.UNKNOWN,
});
// to handle environments where globalThis is not available by default, like nextjs
// https://github.com/vercel/next.js/pull/45592
let globalThisObject;
if (typeof window !== 'undefined') {
    globalThisObject = window;
}
else if (typeof global !== 'undefined') {
    globalThisObject = global;
}
else {
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    globalThisObject = Function('return this')();
}
globalThisObject.globalThis = globalThisObject;
// If there is no window object (e.g. in an SSR environment) then the redirectUrl must be passed in.
// If none is passed in, use a default redirect url.
const DEFAULT_REDIRECT_URL = 'https://getpass.civic.com';
const redirectUrlFromWindow = () => { var _a; return ((_a = globalThis.window) === null || _a === void 0 ? void 0 : _a.location.href) ? encodeURIComponent(globalThis.window.location.href) : DEFAULT_REDIRECT_URL; };
const logLevels = [types_1.LogLevel.DEBUG, types_1.LogLevel.INFO, types_1.LogLevel.WARN, types_1.LogLevel.ERROR];
const GatewayProvider = ({ children = null, walletAddress, chainImplementation, wrapper, logo, stage = 'prod', 
// If set, this will be passed to the core in the xCivicClientVersion param,
// so it will be sent in the Gatekeeper header and analytics events.
// This allows a chain-specific component's version to be passed in if one is used.
// If not passed in, we will use the version of this generic gateway-client-react component.
reactComponentVersion, redirectUrl, gatekeeperNetwork, options = { autoShowModal: false }, payer, gatekeeperSendsTransaction, expiryMarginSeconds = 0, partnerAppId, forceRequireRefresh, expectTokenTimeoutSeconds, disableInitialGatekeeperLookup, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const logger = (0, gateway_client_core_1.prefixLogger)('GatewayProvider', 'gateway-client-react');
    if (logger.setLogLevel) {
        if (options.logLevel) {
            logger.setLogLevel(options.logLevel);
        }
        else if (typeof globalThis.window !== 'undefined') {
            const urlSearchParams = new URLSearchParams(window.location.search);
            const urllogLevel = urlSearchParams.get('logLevel');
            if (logLevels.includes(urllogLevel)) {
                logger.setLogLevel(urllogLevel);
            }
        }
    }
    if (payer && gatekeeperSendsTransaction)
        throw Error('Cannot set payer when gatekeeperSendsTransaction is true');
    const [clientCoreOutput, setClientCoreOutput] = (0, react_1.useState)();
    const [darkMode, setDarkMode] = (0, react_1.useState)(false);
    const onOutputChange = (output) => {
        const newClientOutput = R.clone(Object.assign(Object.assign({}, output), { gatewayStatus: (0, gatewayUtils_1.coreToReactGatewayStatus)(output === null || output === void 0 ? void 0 : output.gatewayStatus) }));
        logger.debug(`GatewayProvider.onOutputChange: setClientCoreOutput: ${setClientCoreOutput}`, newClientOutput);
        setClientCoreOutput(newClientOutput);
    };
    const parentSearchParams = new URLSearchParams(((_a = globalThis.window) === null || _a === void 0 ? void 0 : _a.location.search) || '');
    // If a chain-specific RC version was passed in, use that.
    // Otherwise, use the version of this generic package (gateway-client-react).
    // That way, we'll have some version header even if this generic component is used directly from a dApp.
    const clientVersionHeader = reactComponentVersion || version_1.VERSION;
    const postMessageTargetCallback = (instanceId) => { var _a, _b, _c; return (_c = (_b = (_a = globalThis.document) === null || _a === void 0 ? void 0 : _a.getElementById) === null || _b === void 0 ? void 0 : _b.call(_a, `${constants_1.IFRAME_ID}_${instanceId}`)) === null || _c === void 0 ? void 0 : _c.contentWindow; };
    const inputs = {
        postMessageTargetCallback: postMessageTargetCallback,
        messageEventInterface: {
            addMessageEventListener: (handler) => window.addEventListener('message', handler),
            removeMessageEventListener: (handler) => window.removeEventListener('message', handler),
        },
        parameters: {
            wallet: walletAddress
                ? {
                    address: walletAddress,
                }
                : undefined,
            xCivicClientHeader: clientVersionHeader,
            stage,
            redirectUrl: redirectUrl || redirectUrlFromWindow(),
            gatekeeperNetwork,
            options,
            payer,
            gatekeeperSendsTransaction,
            expiryMarginSeconds,
            partnerAppId,
            expectTokenTimeoutSeconds,
            disableInitialGatekeeperLookup,
            flowIdPrefix: 'GWRC',
            referrer: parentSearchParams.get('referrer') || ((_b = globalThis.document) === null || _b === void 0 ? void 0 : _b.referrer),
            domain: (_c = globalThis.window) === null || _c === void 0 ? void 0 : _c.location.hostname,
        },
        chainImplementation,
        fetchConfig: { fetchImplementation: fetch, numRetries: 3 },
        onOutputChange,
        dynamicParameters: { forceRequireRefresh },
    };
    // the gateway client instance must be handled by react to ensure proper lifecycle management
    // as react doesn't like non-pure components that create side-effects handling their own
    // instance management
    const gatewayClientCoreInst = (0, react_1.useRef)();
    (0, react_1.useEffect)(() => {
        var _a, _b;
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        setDarkMode(mediaQuery.matches);
        if (!(0, gateway_client_core_1.hasRequiredInputs)(inputs)) {
            (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.abort();
            gatewayClientCoreInst.current = undefined;
            return;
        }
        if ((0, gateway_client_core_1.shouldUpdateInstance)(inputs, gatewayClientCoreInst.current)) {
            (_b = gatewayClientCoreInst.current) === null || _b === void 0 ? void 0 : _b.abort();
            gatewayClientCoreInst.current = new gateway_client_core_1.default(inputs);
        }
        // eslint-disable-next-line consistent-return
        return () => {
            var _a;
            (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.abort();
            gatewayClientCoreInst.current = undefined;
        };
    }, [JSON.stringify((0, gateway_client_core_1.getInstanceInputObject)(inputs))]);
    // we need a useEffect to handle the output change cleanup as the instance gets set to undefined
    // if there's no walletAddress and calling onOutputChange on abort causes infinite rendering
    (0, react_1.useEffect)(() => {
        if (!walletAddress && !gatewayClientCoreInst.current) {
            logger.debug('GatewayProvider.onOutputChange undefined');
            onOutputChange(undefined);
        }
    }, [walletAddress]);
    // update dynamic parameters separately from instance creation as we don't want every to change if dynamic parameters change
    (0, react_1.useEffect)(() => {
        var _a;
        (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.updateDynamicParameters({ forceRequireRefresh });
    }, [forceRequireRefresh, (_d = gatewayClientCoreInst.current) === null || _d === void 0 ? void 0 : _d.instanceId]);
    const noRequestGatewayTokenFn = () => {
        logger.warn('GatewayProvider.requestGatewayToken() called before the Gateway is ready');
    };
    logger.debug('GatewayProvider.render', { clientCoreOutput, gatewayClientCoreInst });
    (0, pageUnloadHook_1.usePageUnload)(clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.flowParameters, gatewayClientCoreInst.current);
    return ((0, jsx_runtime_1.jsx)(GatewayContext.Provider, Object.assign({ value: {
            civicPassSrcUrl: (_e = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _e === void 0 ? void 0 : _e.url,
            // we need to provide a default here to support legacy implementations wehere requestGatewayToken was always available
            requestGatewayToken: () => {
                var _a, _b, _c, _d, _e;
                return ((_b = (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.onShow)
                    ? (_e = (_d = (_c = gatewayClientCoreInst.current) === null || _c === void 0 ? void 0 : _c.ui) === null || _d === void 0 ? void 0 : _d.onShow) === null || _e === void 0 ? void 0 : _e.call(_d)
                    : noRequestGatewayTokenFn;
            },
            gatewayStatus: (clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.gatewayStatus) || types_1.GatewayStatus.UNKNOWN,
            gatewayToken: clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.gatewayToken,
            gatewayTokenTransaction: clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.gatewayTokenTransaction,
            pendingRequests: clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.pendingRequests,
        } }, { children: (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [children, ((_f = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _f === void 0 ? void 0 : _f.url) && ((_g = gatewayClientCoreInst.current) === null || _g === void 0 ? void 0 : _g.instanceId) && ((0, jsx_runtime_1.jsx)("div", Object.assign({ "data-testid": constants_1.TESTID_WRAPPER_CONTAINER, hidden: !((_h = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _h === void 0 ? void 0 : _h.isVisible) }, { children: (0, jsx_runtime_1.jsx)(Wrapper_1.Wrapper, Object.assign({ "data-testid": constants_1.TESTID_WRAPPER, onClose: () => {
                            var _a, _b, _c;
                            (_c = (_b = (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.onHide) === null || _c === void 0 ? void 0 : _c.call(_b);
                        }, wrapper: wrapper, logo: logo, loaded: (_j = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _j === void 0 ? void 0 : _j.isLoaded, loading: (_k = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _k === void 0 ? void 0 : _k.isLoading }, { children: (0, jsx_runtime_1.jsx)(iframe_resizer_react_1.default, { "data-testid": constants_1.TESTID_IFRAME, src: (_l = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _l === void 0 ? void 0 : _l.url, id: `${constants_1.IFRAME_ID}_${(_m = gatewayClientCoreInst.current) === null || _m === void 0 ? void 0 : _m.instanceId}`, style: {
                                width: '1px',
                                minWidth: '100%',
                                border: 'none',
                                backgroundColor: darkMode ? 'rgb(30, 41, 59)' : 'rgb(255, 255, 255)',
                                height: '26px',
                                transition: 'height 0.25s ease',
                                pointerEvents: !((_o = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _o === void 0 ? void 0 : _o.isLoading) ? 'auto' : 'none', // disables user input during loading
                            }, heightCalculationMethod: "min", checkOrigin: false, onLoad: () => {
                                var _a, _b, _c;
                                (_c = (_b = (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.onLoad) === null || _c === void 0 ? void 0 : _c.call(_b);
                            }, inPageLinks: true, allow: "camera; screen-wake-lock", allowFullScreen: true, frameBorder: "0" }) })) })))] }) })));
};
exports.GatewayProvider = GatewayProvider;
const useGateway = () => (0, react_1.useContext)(GatewayContext);
exports.useGateway = useGateway;

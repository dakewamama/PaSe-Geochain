import { step } from 'mocha-steps';
import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import chaiAsPromised from 'chai-as-promised';
import sinonChai from 'sinon-chai';
import { IntegrationTestHelpers, sleep } from '../testSupport';
import { ValidationStatus } from '../../src/types/civicPass';
import { validationProcessToGatewayStatus } from '../../src/state/common';
import { GatewayStatus } from '../../src/types/gateway';

chai.use(sinonChai);
chai.use(chaiSubset);
chai.use(chaiAsPromised);

const sandbox = sinon.createSandbox();

describe('GatewayClientCore initialisation integration tests', () => {
  let testHelpers: IntegrationTestHelpers;

  context('with the initial gatekeeper record lookup disabled', () => {
    before(() => {
      testHelpers = new IntegrationTestHelpers(sandbox);
      testHelpers.stubSuccessfulFetchCalls();
    });
    after(() => {
      testHelpers.cleanup();
      sandbox.restore();
    });
    step('1. expect the Gatekeeper client to successfully initialize', () => {
      testHelpers.initializeGatewayCore({ disableInitialGatekeeperLookup: true });
    });

    step('2. wait for  on-chain checks to complete', async () => {
      await sleep(110);
    });

    step('3. Expect gateway status to change to NOT_REQUESTED', async () => {
      testHelpers.expectNotRequested();
    });
  });

  context('with the initial gatekeeper record lookup disabled flag not set', () => {
    before(() => {
      testHelpers = new IntegrationTestHelpers(sandbox);
      testHelpers.stubSuccessfulFetchCalls();
    });
    after(() => {
      testHelpers.cleanup();
      sandbox.restore();
    });
    step('1. expect the Gatekeeper client to successfully initialize', () => {
      testHelpers.initializeGatewayCore();
    });

    step('2. wait for GK and on-chain checks to complete', async () => {
      await sleep(110);
    });

    step('3. Expect gateway status to change to NOT_REQUESTED', async () => {
      testHelpers.expectNotRequested();
    });
  });

  context('with a validation in progress', () => {
    Object.entries({
      ...validationProcessToGatewayStatus,
      // this is a special case where data-collection needs to restart as we don't have a payload
      // the internal status will go to ISSUANCE_RESTART_DATA_COLLECTION which maps to an output of NOT_REQUESTED
      [ValidationStatus.COMPLETED]: GatewayStatus.NOT_REQUESTED,
    }).forEach(([validationStatus, gatewayStatus]) => {
      context(`with a civic-pass ${validationStatus} status event that arrives after checking is complete`, () => {
        before(() => {
          testHelpers = new IntegrationTestHelpers(sandbox);
          testHelpers.stubSuccessfulFetchCalls();
        });
        after(() => {
          testHelpers.cleanup();
          sandbox.restore();
        });

        step('1. expect the Gatekeeper client to successfully initialize', () => {
          testHelpers.initializeGatewayCore();
        });

        step('2. wait for GK and on-chain checks to complete', async () => {
          await sleep(110);
        });

        step(`3. Simulate a ${validationStatus} civic pass validation process status event`, async () => {
          testHelpers.simulateDataCollectionStatusEvent(validationStatus as ValidationStatus);
        });

        step(`4. Expect gateway status to change to ${gatewayStatus}`, async () => {
          testHelpers.expectStatus(gatewayStatus);
        });
      });

      context(`with a civic-pass ${validationStatus} status that arrives before checking is complete`, () => {
        before(() => {
          testHelpers = new IntegrationTestHelpers(sandbox);
          testHelpers.stubSuccessfulFetchCalls();
        });
        after(() => {
          testHelpers.cleanup();
          sandbox.restore();
        });

        step('1. expect the Gatekeeper client to successfully initialize', () => {
          testHelpers.initializeGatewayCore();
        });

        step('2. wait for GK and on-chain checks to be still in progress', async () => {
          await sleep(5);
        });

        step(`3. Simulate a ${validationStatus} civic pass validation process status event`, async () => {
          testHelpers.simulateDataCollectionStatusEvent(validationStatus as ValidationStatus);
        });

        step('4. expect status to still be CHECKING', async () => {
          await sleep(5);
          testHelpers.expectStatus(GatewayStatus.CHECKING);
        });

        step('5. wait for GK and on-chain checks to complete', async () => {
          await sleep(110);
        });

        step(`6. Expect gateway status to change to ${gatewayStatus}`, async () => {
          testHelpers.expectStatus(gatewayStatus);
        });
      });
    });

    context('with a validation failure', () => {
      context('with auto-restart on validation failure', () => {
        before(() => {
          testHelpers = new IntegrationTestHelpers(sandbox);
          testHelpers.stubSuccessfulFetchCalls();
        });
        after(() => {
          testHelpers.cleanup();
          sandbox.restore();
        });

        step('1. expect the Gatekeeper client to successfully initialize', () => {
          testHelpers.initializeGatewayCore();
        });

        step('2. wait for GK and on-chain checks to complete', async () => {
          await sleep(110);
        });

        step('3. Simulate an event for a started validation process', async () => {
          testHelpers.simulateDataCollectionStatusEvent(ValidationStatus.COLLECTING as ValidationStatus);
        });

        step('5. wait for GK and on-chain checks to complete', async () => {
          await sleep(110);
        });

        step('6. Expect the status to change to COLLECTING_USER_INFORMATION', async () => {
          testHelpers.expectRejected(GatewayStatus.COLLECTING_USER_INFORMATION);
        });

        step('7. Simulating a civic-pass validation failure (e.g.: scope request patch rejected)', async () => {
          await testHelpers.simulateCivicPassFailureEvent();
        });

        step('8. Wait for the status change', async () => {
          await sleep(120);
        });

        step('9. Expect it to re-initialize and status to be NOT_REQUESTED', async () => {
          testHelpers.expectRejected(GatewayStatus.NOT_REQUESTED);
        });
      });

      context('with auto-restart on validation failure disabled (disableAutoRestartOnValidationFailure)', () => {
        before(() => {
          testHelpers = new IntegrationTestHelpers(sandbox);
          testHelpers.stubSuccessfulFetchCalls();
        });
        after(() => {
          testHelpers.cleanup();
          sandbox.restore();
        });

        step('1. expect the Gatekeeper client to successfully initialize', () => {
          testHelpers.initializeGatewayCore({
            options: {
              disableAutoRestartOnValidationFailure: true,
            },
          });
        });

        step('2. wait for GK and on-chain checks to complete', async () => {
          await sleep(110);
        });

        step('3. Simulate an event for a started validation process', async () => {
          testHelpers.simulateDataCollectionStatusEvent(ValidationStatus.COLLECTING as ValidationStatus);
        });

        step('5. wait for GK and on-chain checks to complete', async () => {
          await sleep(110);
        });

        step('6. Expect the status to change to COLLECTING_USER_INFORMATION', async () => {
          testHelpers.expectRejected(GatewayStatus.COLLECTING_USER_INFORMATION);
        });

        step('7. Simulating a civic-pass validation failure (e.g.: scope request patch rejected)', async () => {
          await testHelpers.simulateCivicPassFailureEvent();
        });

        step('8. Wait for the status change', async () => {
          await sleep(120);
        });

        step('9. Expect status to be USER_INFORMATION_REJECTED', async () => {
          testHelpers.expectRejected(GatewayStatus.USER_INFORMATION_REJECTED);
        });
      });
    });
  });

  context('with a validation not found', () => {
    context('with a civic-pass status event that arrives after checking is complete', () => {
      before(() => {
        testHelpers = new IntegrationTestHelpers(sandbox);
        testHelpers.stubSuccessfulFetchCalls();
      });
      after(() => {
        testHelpers.cleanup();
        sandbox.restore();
      });

      step('1. expect the Gatekeeper client to successfully initialize', () => {
        testHelpers.initializeGatewayCore();
      });

      step('2. wait for GK and on-chain checks to complete', async () => {
        await sleep(110);
      });

      step(`3. Simulate a NOT_FOUND civic pass validation process status event`, async () => {
        testHelpers.simulateDataCollectionStatusEvent(ValidationStatus.NOT_FOUND);
      });

      step(`4. Expect gateway status to be NOT_REQUESTED`, async () => {
        testHelpers.expectStatus(GatewayStatus.NOT_REQUESTED);
      });
    });

    context('with a civic-pass status event that arrives before checking is complete', () => {
      before(() => {
        testHelpers = new IntegrationTestHelpers(sandbox);
        testHelpers.stubSuccessfulFetchCalls();
      });
      after(() => {
        testHelpers.cleanup();
        sandbox.restore();
      });

      step('1. expect the Gatekeeper client to successfully initialize', () => {
        testHelpers.initializeGatewayCore();
      });

      step('2. wait for GK and on-chain checks to be still in progress', async () => {
        await sleep(5);
      });

      step(`3. Simulate a NOT_FOUND civic pass validation process status event`, async () => {
        testHelpers.simulateDataCollectionStatusEvent(ValidationStatus.NOT_FOUND);
      });

      step('4. expect status to still be CHECKING', async () => {
        await sleep(5);
        testHelpers.expectStatus(GatewayStatus.CHECKING);
      });

      step('5. wait for GK and on-chain checks to complete', async () => {
        await sleep(110);
      });

      step(`6. Expect gateway status to be NOT_REQUESTED`, async () => {
        testHelpers.expectStatus(GatewayStatus.NOT_REQUESTED);
      });
    });
  });
});

import * as R from 'ramda';
import chai from 'chai';
import sinon, { SinonStub } from 'sinon';
import {
  CivicAnalyticsEvent,
  SendBeaconFn,
  sendAnalyticsEvent,
  sendOnCloseAnalyticsEvent,
} from '../../src/utils/analytics';
import * as analytics from '../../src/utils/analytics';
import { Stage } from '../../src/types/parameters';
import { VERSION as CORE_VERSION } from '../../src/version';
import { ChainType, ErrorCode, FlowParameters, FlowType } from '../../src';

const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('analytics', () => {
  afterEach(sandbox.restore);
  context('sendAnalyticsEvent', () => {
    let fetchStub: SinonStub;
    let sendBeaconStub: SinonStub;
    beforeEach(() => {
      fetchStub = sandbox.stub();
      global.fetch = fetchStub;
      sendBeaconStub = sinon.stub();
    });
    ['local', 'test'].map((stage: Stage) => {
      context(`with no analytics endpoint configured for stage (${stage})`, () => {
        it('should not make an API calls', async () => {
          await sendAnalyticsEvent(stage, {} as CivicAnalyticsEvent);
          expect(fetchStub).not.to.have.been.called;
          expect(sendBeaconStub).not.to.have.been.called;
        });
      });
    });
    context('with analytics endpoint configured', () => {
      const stage = 'dev';
      context('with sendBeacon function passed in', () => {
        it('should call Beacon API', async () => {
          await sendAnalyticsEvent(stage, { testEvent: '123' } as unknown as CivicAnalyticsEvent, sendBeaconStub);
          expect(sendBeaconStub).to.have.been.calledOnceWith(
            'https://dev.api.civic.com/analytics-dev/events',
            JSON.stringify({ testEvent: '123', source: 'passApi_dev', civicClient: CORE_VERSION })
          );
        });
        it('should not call fetch', async () => {
          await sendAnalyticsEvent(stage, {} as CivicAnalyticsEvent, sendBeaconStub);
          expect(fetchStub).not.to.have.been.called;
        });
        context('with civicClient passed in with event', async () => {
          it('should include civicClient from the event', async () => {
            await sendAnalyticsEvent(
              stage,
              {
                civicClient: '@civic/gateway-client-react:1.1.1',
              } as CivicAnalyticsEvent,
              sendBeaconStub
            );
            expect(sendBeaconStub).to.have.been.calledOnceWith(
              sinon.match.string,
              JSON.stringify({ civicClient: '@civic/gateway-client-react:1.1.1', source: 'passApi_dev' })
            );
          });
        });
        context('with no civicClient passed in with event', async () => {
          it('should use civicClient from core version', async () => {
            await sendAnalyticsEvent(stage, {} as CivicAnalyticsEvent, sendBeaconStub);
            expect(sendBeaconStub).to.have.been.calledOnceWith(
              sinon.match.string,
              JSON.stringify({ source: 'passApi_dev', civicClient: CORE_VERSION })
            );
          });
        });
        context('with an empty civicClient passed in with event', async () => {
          it('should use civicClient from core version', async () => {
            await sendAnalyticsEvent(stage, {} as CivicAnalyticsEvent, sendBeaconStub);
            expect(sendBeaconStub).to.have.been.calledOnceWith(
              sinon.match.string,
              JSON.stringify({ source: 'passApi_dev', civicClient: CORE_VERSION })
            );
          });
        });
      });
      context('with sendBeacon not passed in', () => {
        it('should call fetch with no-cors', async () => {
          await sendAnalyticsEvent(stage, { testEvent: '123' } as unknown as CivicAnalyticsEvent);
          expect(fetchStub).to.have.been.calledOnceWith('https://dev.api.civic.com/analytics-dev/events', {
            method: 'POST',
            mode: 'no-cors',
            body: JSON.stringify({ testEvent: '123', source: 'passApi_dev', civicClient: CORE_VERSION }),
          });
        });
        it('should not call Beacon API', async () => {
          await sendAnalyticsEvent(stage, { testEvent: '123' } as unknown as CivicAnalyticsEvent);
          expect(sendBeaconStub).not.to.have.been.called;
        });
      });
    });
  });
  context('sendOnAbortAnalyticsEvent', () => {
    let sendAnalyticsEventStub: SinonStub;
    let flowParams: FlowParameters;
    beforeEach(() => {
      sendAnalyticsEventStub = sandbox.stub(analytics, 'sendAnalyticsEvent');

      flowParams = {
        did: 'did:example:123',
        wallet: '0xabc',
        networkAddress: 'test-network-address',
        chain: ChainType.ETHEREUM,
        chainNetwork: 'mainnet',
        flowId: 'flow-id',
        flowType: FlowType.ISSUANCE,
        referrer: 'referrer.example.com',
        domain: 'domain.example.com',
        ownerSigns: true,
        stage: 'test-stage',
        civicClient: 'test-client-version',
      } as FlowParameters;
    });
    context('with a pendingTransaction on the chainImplementation', () => {
      it('should call sendAnalyticsEvent with correct event body', async () => {
        await sendOnCloseAnalyticsEvent(flowParams, 'pending-tx-hash');
        expect(sendAnalyticsEventStub).to.have.been.calledOnceWith(sinon.match.string, {
          did: 'did:example:123',
          networkAddress: 'test-network-address',
          chain: 'ethereum',
          chainNetwork: 'mainnet',
          ownerSigns: 'true',
          wallet: '0xabc',
          domain: 'domain.example.com',
          referrer: 'referrer.example.com',
          action: 'CHAIN_ERROR',
          errorCode: ErrorCode.BROWSER_CLOSED_WHILE_TRANSACTION_PENDING,
          flowId: 'flow-id',
          flowType: FlowType.ISSUANCE,
          signedTx: 'pending-tx-hash',
          civicClient: 'test-client-version',
        });
      });
      it('should call sendAnalyticsEvent with correct stage', async () => {
        await sendOnCloseAnalyticsEvent(flowParams, 'pending-tx-hash');
        expect(sendAnalyticsEventStub).to.have.been.calledOnceWith('test-stage', sinon.match.object, sinon.match.any);
      });
      it('should pass sendBeacon argument along to sendAnalyticsEvent', async () => {
        await sendOnCloseAnalyticsEvent(flowParams, 'pending-tx-hash', 'test-send-beacon' as unknown as SendBeaconFn);
        expect(sendAnalyticsEventStub).to.have.been.calledOnceWith(
          'test-stage',
          sinon.match.object,
          'test-send-beacon'
        );
      });
      context('with no stage set on flowParameters', () => {
        it('should not send analytics event', async () => {
          await sendOnCloseAnalyticsEvent(R.omit(['stage'], flowParams), 'pending-tx-hash');
          expect(sendAnalyticsEventStub).not.to.have.been.called;
        });
      });
      context('with empty flowParameters', () => {
        it('should send empty strings', async () => {
          await sendOnCloseAnalyticsEvent({ stage: 'test-stage' } as FlowParameters, 'pending-tx-hash');
          expect(sendAnalyticsEventStub).to.have.been.calledOnceWith(
            sinon.match.string,
            {
              did: '',
              networkAddress: '',
              chain: '',
              chainNetwork: '',
              ownerSigns: 'false',
              wallet: '',
              domain: '',
              referrer: '',
              action: 'CHAIN_ERROR',
              errorCode: ErrorCode.BROWSER_CLOSED_WHILE_TRANSACTION_PENDING,
              flowId: '',
              flowType: '',
              signedTx: 'pending-tx-hash',
              civicClient: undefined,
            },
            sinon.match.any
          );
        });
      });
    });
    context('with no pendingTransaction', () => {
      it('should not call sendAnalyticsEvent', async () => {
        await sendOnCloseAnalyticsEvent(flowParams, undefined);
        expect(sendAnalyticsEventStub).not.to.have.been.called;
      });
    });
  });
});

import { GatewayStatus } from '../src';
import { createGatewayCoreStore, Store } from '../src/state/state';
import { UIManager } from '../src/ui';
import chai from 'chai';
import sinon from 'sinon';
import chaiSubset from 'chai-subset';
import { sleep } from './testSupport';

chai.use(chaiSubset);
const { expect } = chai;

const sandbox = sinon.createSandbox();
describe('ui tests', () => {
  afterEach(sandbox.restore);

  context('with no output set', () => {
    context('with no ui set', () => {
      let gatewayCoreStore: Store;
      let ui: UIManager;
      beforeEach(async () => {
        // Arrange
        gatewayCoreStore = createGatewayCoreStore({ name: 'test' });
        await sleep(5);
        gatewayCoreStore.setState((state) => {
          state.output = undefined;
        });
        ui = new UIManager(gatewayCoreStore);
      });
      context('onShow', () => {
        it('should set isVisible to true and userInteraction status to STARTED', async () => {
          // Act
          ui.onShow();

          // Assert
          const newState = gatewayCoreStore.getState();

          expect(newState.output?.ui).containSubset({
            isVisible: true,
            url: undefined,
          });
          expect(newState.internal.userInteraction.status).to.equal('started');
          expect(newState.output?.gatewayStatus).to.eq(GatewayStatus.UNKNOWN);
        });
      });

      context('onHide', () => {
        it('should set isVisible to false', () => {
          // Act
          ui.onHide();

          // Assert
          const newState = gatewayCoreStore.getState();
          expect(newState.output?.ui).containSubset({
            isVisible: false,
            url: undefined,
          });
          expect(newState.output?.gatewayStatus).to.eq(GatewayStatus.UNKNOWN);
        });
      });

      context('onLoad', () => {
        it('should set isLoading to false and isLoaded to true', () => {
          // Act
          ui.onLoad();

          // Assert
          const newState = gatewayCoreStore.getState();
          expect(newState.output?.ui).containSubset({
            isVisible: false,
            isLoading: false,
            url: undefined,
            isLoaded: true,
          });
          expect(newState.output?.gatewayStatus).to.eq(GatewayStatus.UNKNOWN);
        });
      });
    });
  });

  context('with output set', () => {
    let gatewayCoreStore: Store;
    let ui: UIManager;
    beforeEach(() => {
      // Arrange
      gatewayCoreStore = createGatewayCoreStore({ name: 'test' });
      ui = new UIManager(gatewayCoreStore);
    });

    context('onShow', () => {
      it('should set isVisible to true and userInteraction status to STARTED', () => {
        // Act
        ui.onShow();

        // Assert
        const newState = gatewayCoreStore.getState();
        expect(newState.output?.ui?.isVisible).to.be.true;
        expect(newState.internal.userInteraction.status).to.equal('started');
      });
    });

    context('onHide', () => {
      it('should set isVisible to false', () => {
        // Act
        ui.onHide();

        // Assert
        const newState = gatewayCoreStore.getState();
        expect(newState.output?.ui?.isVisible).to.be.false;
      });
    });

    context('onLoad', () => {
      it('should set isLoading to false and isLoaded to true', () => {
        // Act
        ui.onLoad();

        // Assert
        const newState = gatewayCoreStore.getState();
        expect(newState.output?.ui?.isLoading).to.be.false;
        expect(newState.output?.ui?.isLoaded).to.be.true;
      });
    });
  });
});

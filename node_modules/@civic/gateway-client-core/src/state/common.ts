import { isTokenRefreshRequired } from '../utils/expiry';
import { ValidationStatus } from '../types/civicPass';
import { GatewayStatus } from '../types/gateway';
import { GatewayCoreState } from '../types/gatewayCore';
import { prefixLogger } from '../logger';
import { GatekeeperAPIStatus } from '../types/gatekeeperApi';

const logError = prefixLogger('common').error;
export type ValidationGatewayStatusType =
  | GatewayStatus.COLLECTING_USER_INFORMATION
  | GatewayStatus.VALIDATING_USER_INFORMATION
  | GatewayStatus.USER_INFORMATION_REJECTED
  | GatewayStatus.NOT_REQUESTED
  | GatewayStatus.USER_INFORMATION_VALIDATED;

export type CheckValidationStatusType =
  | ValidationStatus.COLLECTING
  | ValidationStatus.PROCESSING
  | ValidationStatus.IN_REVIEW
  | ValidationStatus.FAILED
  | ValidationStatus.COMPLETED;
export const validationProcessToGatewayStatus: Record<CheckValidationStatusType, ValidationGatewayStatusType> = {
  [ValidationStatus.COLLECTING]: GatewayStatus.COLLECTING_USER_INFORMATION,
  [ValidationStatus.PROCESSING]: GatewayStatus.VALIDATING_USER_INFORMATION,
  [ValidationStatus.IN_REVIEW]: GatewayStatus.VALIDATING_USER_INFORMATION,
  [ValidationStatus.FAILED]: GatewayStatus.USER_INFORMATION_REJECTED,
  [ValidationStatus.COMPLETED]: GatewayStatus.USER_INFORMATION_VALIDATED,
};

export const payerIsWalletOwner = (state: GatewayCoreState): boolean =>
  !!(state.inputs.parameters?.payer === state.inputs.parameters?.wallet?.address);

export const tokenNoGatekeeperRecordError = (state: GatewayCoreState): boolean =>
  !!(
    state.inputs.gatewayToken?.received &&
    state.inputs.gatekeeperRecord?.received?.state === GatekeeperAPIStatus.NOT_REQUESTED
  );

/**
 * if a gateway token is present in state, then derive the status from the token fields:
 * - if the state is ACTIVE, check if a token refresh is required OR if the forceRequireRefresh input flag is set
 * in which case return REFRESH_TOKEN_REQUIRED, otherwise return ACTIVE
 * - if the state is FROZEN, return FROZEN
 * - if the state is REVOKED, return REVOKED
 * - if the state is not one of the above, then the gatewayToken is in an unsupported state, so log an error and return ERROR
 * @param state
 * @returns
 */
export type GatewayTokenCheckType =
  | GatewayStatus.ERROR
  | GatewayStatus.REFRESH_TOKEN_REQUIRED
  | GatewayStatus.ACTIVE
  | GatewayStatus.FROZEN
  | GatewayStatus.REVOKED;

export const statusFromGatewayTokenIfExists = (state: GatewayCoreState): GatewayTokenCheckType | undefined => {
  const gatewayToken = state.inputs.gatewayToken?.received;
  if (tokenNoGatekeeperRecordError(state)) {
    return GatewayStatus.ERROR;
  }
  if (gatewayToken) {
    const tokenRefreshRequired = isTokenRefreshRequired({
      gatewayToken,
      tokenExpirationMarginSeconds: 0,
      forceRequireRefresh: state.inputs.dynamicParameters?.forceRequireRefresh,
    });

    switch (gatewayToken.state) {
      case 'ACTIVE':
        return tokenRefreshRequired ? GatewayStatus.REFRESH_TOKEN_REQUIRED : GatewayStatus.ACTIVE;
      case 'FROZEN':
        return GatewayStatus.FROZEN;
      case 'REVOKED':
        return GatewayStatus.REVOKED;
      default:
        // Handle unexpected token states or add logging as necessary
        logError(`Unexpected token state: ${gatewayToken.state}`);
        return GatewayStatus.ERROR;
    }
  }
  return undefined;
};

export const handleGatewayTokenExistsStatus = (state: GatewayCoreState): GatewayTokenCheckType => {
  const status = statusFromGatewayTokenIfExists(state);
  if (!status) {
    logError('The gateway status indicated an existing token but no status could be derived');
    return GatewayStatus.ERROR;
  }
  return status;
};
export type StatusIfGatekeeperRecordRejectedType =
  | GatewayStatus.REJECTED
  | GatewayStatus.LOCATION_NOT_SUPPORTED
  | GatewayStatus.VPN_NOT_SUPPORTED
  | GatewayStatus.REFRESH_TOKEN_REQUIRED
  | GatewayStatus.ERROR;
export const statusIfGatekeeperRecordRejected = (
  state: GatewayCoreState
): StatusIfGatekeeperRecordRejectedType | undefined => {
  const gatekeeperRecord = state.inputs.gatekeeperRecord;
  const gatewayToken = state.inputs.gatewayToken;
  const recordState = gatekeeperRecord?.received?.state;
  switch (recordState) {
    case GatekeeperAPIStatus.ISSUED_EXPIRED:
      // we only want to handle the error case here
      // the refresh case will be handled by statusFromGatewayTokenIfExists
      return gatewayToken?.received ? undefined : GatewayStatus.ERROR;
    case GatekeeperAPIStatus.REJECTED:
      return GatewayStatus.REJECTED;
    case GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED:
    case GatekeeperAPIStatus.LOCATION_NOT_SUPPORTED:
      return GatewayStatus.LOCATION_NOT_SUPPORTED;
    case GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED:
    case GatekeeperAPIStatus.VPN_NOT_SUPPORTED:
      return GatewayStatus.VPN_NOT_SUPPORTED;
    case GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED:
      return GatewayStatus.ERROR;
    default:
      return undefined;
  }
};

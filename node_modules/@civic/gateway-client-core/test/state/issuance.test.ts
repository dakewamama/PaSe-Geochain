import { ExtendedGatewayStatus, GatewayClientParameters, GatewayCoreState, GatewayStatus } from '../../src';
import {
  calculateFromGatekeeperIssuanceRequested,
  calculateFromIssuanceAwaitingOnChain,
  calculateFromIssuanceInReview,
  calculateIssuanceRequestedDataCollectionRestart,
  calculateIssuanceStatus,
  hasExistingDataCollectionProcessInProgress,
  isInPartnerReview,
} from '../../src/state/issuance';
import { expect } from 'chai';
import { ErrorCode } from '../../src/utils/errors';
import { CivicPassMessageAction, CivicPassMessageEventResult, ValidationStatus } from '../../src/types/civicPass';
import { InputStatus } from '../../src/types/fetch';
import { GatekeeperAPIStatus } from '../../src/types/gatekeeperApi';
import { validationProcessToGatewayStatus } from '../../src/state/common';

describe('issuance state unit tests', () => {
  context('calculateFromIssuanceAwaitingOnChain', () => {
    context('with an expectedOnChainToken error', () => {
      it('should return CHAIN_TIMEOUT_ERROR', () => {
        const state = {
          internal: {
            errors: {
              expectedOnChainToken: {
                errorCode: ErrorCode.CHAIN_CONFIRMATION_TIMEOUT_ERROR,
              },
            },
          },
        } as GatewayCoreState;
        const result = calculateFromIssuanceAwaitingOnChain(state);
        expect(result).to.equal(ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR);
      });
    });

    context('with no internal error in state', () => {
      it('should return undefined', () => {
        const state = {
          internal: {},
        } as GatewayCoreState;
        const result = calculateFromIssuanceAwaitingOnChain(state);
        expect(result).to.be.undefined;
      });
    });
  });

  context('calculateFromIssuanceInReview', () => {
    context('with a payer', () => {
      context('with a gatekeeperRecord complete with no transaction', () => {
        context('with a civicPassEvent action not equal to ISSUANCE', () => {
          it('should return ISSUANCE_RESTART_DATA_COLLECTION', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                },
                civicPass: {
                  received: {
                    action: 'test-action',
                  },
                },
                gatekeeperRecord: {
                  status: 'COMPLETE',
                  received: {},
                },
              },
            } as unknown as GatewayCoreState;
            const result = calculateFromIssuanceInReview(state);
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION);
          });
        });

        context('with a civicPassEvent action equal to ISSUANCE', () => {
          it('should return undefined', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                },
                civicPass: {
                  received: {
                    action: CivicPassMessageAction.ISSUANCE,
                  },
                },
                gatekeeperRecord: {
                  status: 'COMPLETE',
                  received: {},
                },
              },
            } as unknown as GatewayCoreState;
            const result = calculateFromIssuanceInReview(state);
            expect(result).to.be.undefined;
          });
        });
      });

      context('with a gatekeeperRecord complete with a transaction', () => {
        context('with a payer different from the wallet owner', () => {
          it('should return ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                  wallet: {
                    address: 'a-different-address',
                  },
                },
                gatekeeperRecord: {
                  status: InputStatus.COMPLETE,
                  received: {
                    transaction: 'test-transaction',
                  },
                },
              },
            } as GatewayCoreState;
            const result = calculateFromIssuanceInReview(state);
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND);
          });
        });

        context('with a payer equal to the wallet owner', () => {
          it('should return ISSUANCE_AWAITING_TRANSACTION_SEND', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                  wallet: {
                    address: 'test-payer',
                  },
                },
                gatekeeperRecord: {
                  status: InputStatus.COMPLETE,
                  received: {
                    transaction: 'test-transaction',
                  },
                },
              },
            } as unknown as GatewayCoreState;
            const result = calculateFromIssuanceInReview(state);
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND);
          });
        });
      });

      context('with a chainTransaction sentTxId', () => {
        it('should return ISSUANCE_AWAITING_ON_CHAIN_TOKEN', () => {
          const state = {
            inputs: {
              parameters: {
                payer: 'test-payer',
              },
            },
            internal: {
              chainTransaction: {
                sentTxId: 'test-tx-id',
              },
            },
          } as GatewayCoreState;
          const result = calculateFromIssuanceInReview(state);
          expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN);
        });
      });

      context('with a chainTransaction error', () => {
        it('should return CHAIN_TRANSACTION_ERROR', () => {
          const state = {
            inputs: {
              parameters: {
                payer: 'test-payer',
              },
            },
            internal: {
              chainTransaction: {
                error: 'test-error',
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateFromIssuanceInReview(state);
          expect(result).to.equal(ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR);
        });
      });
    });

    context('with no payer set', () => {
      it('should return ISSUANCE_AWAITING_ON_CHAIN_TOKEN', () => {
        const state = {
          inputs: {
            parameters: {},
          },
        } as GatewayCoreState;
        const result = calculateFromIssuanceInReview(state);
        expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN);
      });
    });
  });

  context('calculateIssuanceRequestedDataCollectionRestart', () => {
    context('with a civicPass event of failure', () => {
      it('should return USER_VALIDATION_FAILED', () => {
        const state = {
          inputs: {
            civicPass: {
              received: {
                event: CivicPassMessageEventResult.FAILURE,
              },
            },
          },
        } as unknown as GatewayCoreState;
        const result = calculateIssuanceRequestedDataCollectionRestart(state);
        expect(result).to.equal(ExtendedGatewayStatus.USER_VALIDATION_FAILED);
      });
    });

    context('with a civicPass event of issuance in progress', () => {
      context('with a derived validation process status', () => {
        it('should return the mapping of the payload to gateway status', () => {
          const state = {
            inputs: {
              civicPass: {
                received: {
                  action: CivicPassMessageAction.ISSUANCE,
                  event: CivicPassMessageEventResult.IN_PROGRESS,
                  payload: {
                    status: ValidationStatus.COMPLETED,
                  },
                },
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateIssuanceRequestedDataCollectionRestart(state);
          expect(result).to.equal(GatewayStatus.USER_INFORMATION_VALIDATED);
        });
      });

      context('with no derived validation process status', () => {
        it('should return GatewayStatus.COLLECTING_USER_INFORMATION', () => {
          const state = {
            inputs: {
              civicPass: {
                received: {
                  action: CivicPassMessageAction.ISSUANCE,
                  event: CivicPassMessageEventResult.IN_PROGRESS,
                },
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateIssuanceRequestedDataCollectionRestart(state);
          expect(result).to.equal(GatewayStatus.COLLECTING_USER_INFORMATION);
        });
      });
    });

    context('with a civicPass status succcess', () => {
      context('with a not-found payload', () => {
        it('should return undefined', () => {
          const state = {
            inputs: {
              civicPass: {
                received: {
                  action: CivicPassMessageAction.STATUS,
                  event: CivicPassMessageEventResult.SUCCESS,
                  payload: {
                    status: ValidationStatus.NOT_FOUND,
                  },
                },
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateIssuanceRequestedDataCollectionRestart(state);
          expect(result).to.equal(undefined);
        });
      });

      Object.entries(validationProcessToGatewayStatus).forEach(([validationStatus, gatewayStatus]) => {
        context('with a payload status of ' + validationStatus, () => {
          it('should return the mapping of the payload to gateway status', () => {
            const state = {
              inputs: {
                civicPass: {
                  received: {
                    action: CivicPassMessageAction.STATUS,
                    event: CivicPassMessageEventResult.SUCCESS,
                    payload: {
                      status: validationStatus,
                    },
                  },
                },
              },
            } as unknown as GatewayCoreState;
            const result = calculateIssuanceRequestedDataCollectionRestart(state);
            expect(result).to.equal(gatewayStatus);
          });
        });
      });
    });

    context('with a civicPass issuance succcess', () => {
      it('should return USER_INFORMATION_VALIDATED', () => {
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.ISSUANCE,
                event: CivicPassMessageEventResult.SUCCESS,
              },
            },
          },
        } as unknown as GatewayCoreState;
        const result = calculateIssuanceRequestedDataCollectionRestart(state);
        expect(result).to.equal(GatewayStatus.USER_INFORMATION_VALIDATED);
      });
    });

    context('with a civicPass issuance succcess', () => {
      it('should return USER_INFORMATION_VALIDATED', () => {
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.ISSUANCE,
                event: CivicPassMessageEventResult.SUCCESS,
              },
            },
          },
        } as unknown as GatewayCoreState;
        const result = calculateIssuanceRequestedDataCollectionRestart(state);
        expect(result).to.equal(GatewayStatus.USER_INFORMATION_VALIDATED);
      });
    });

    context('with no civicPass event', () => {
      it('should return undefined', () => {
        const state = {
          inputs: {},
        } as GatewayCoreState;
        const result = calculateIssuanceRequestedDataCollectionRestart(state);
        expect(result).to.be.undefined;
      });
    });
  });

  context('isInPartnerReview', () => {
    context('with a pending payload set in the gatekeeperRecord', () => {
      it('should return true', () => {
        const gatekeeperRecord = {
          received: {
            payload: {
              pending: 'test-pending',
            },
          },
        } as unknown as GatewayCoreState['inputs']['gatekeeperRecord'];
        const result = isInPartnerReview(gatekeeperRecord);
        expect(result).to.be.true;
      });
    });

    context('with a pending object directly set in the gatekeeperRecord', () => {
      it('should return true', () => {
        const gatekeeperRecord = {
          received: {
            pending: 'test-pending',
          },
        } as unknown as GatewayCoreState['inputs']['gatekeeperRecord'];
        const result = isInPartnerReview(gatekeeperRecord);
        expect(result).to.be.true;
      });
    });

    context('with no pending payload set', () => {
      it('should return false', () => {
        const gatekeeperRecord = {
          received: {},
        } as unknown as GatewayCoreState['inputs']['gatekeeperRecord'];
        const result = isInPartnerReview(gatekeeperRecord);
        expect(result).to.be.false;
      });
    });
  });

  context('calculateIssuanceStatus', () => {
    context('with a civicPass event of failure', () => {
      it('should return USER_VALIDATION_FAILED', () => {
        const state = {
          inputs: {
            civicPass: {
              received: {
                event: CivicPassMessageEventResult.FAILURE,
              },
            },
          },
        } as unknown as GatewayCoreState;
        const result = calculateIssuanceStatus(state);
        expect(result).to.equal(ExtendedGatewayStatus.USER_VALIDATION_FAILED);
      });
    });

    context('with a civicPass issuance succcess', () => {
      it('should return USER_INFORMATION_VALIDATED', () => {
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.ISSUANCE,
                event: CivicPassMessageEventResult.SUCCESS,
              },
            },
          },
        } as unknown as GatewayCoreState;
        const result = calculateIssuanceStatus(state);
        expect(result).to.equal(GatewayStatus.USER_INFORMATION_VALIDATED);
      });
    });

    context('with a civicPass status succcess', () => {
      it('should return the mapping of the payload to gateway status', () => {
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.STATUS,
                event: CivicPassMessageEventResult.SUCCESS,
                payload: {
                  status: ValidationStatus.COLLECTING,
                },
              },
            },
          },
        } as unknown as GatewayCoreState;
        const result = calculateIssuanceStatus(state);
        expect(result).to.equal(GatewayStatus.COLLECTING_USER_INFORMATION);
      });
    });

    context('with a GatekeeperAPIStatus of not-requested', () => {
      context('with a validation status set', () => {
        [
          { action: CivicPassMessageAction.STATUS, event: CivicPassMessageEventResult.SUCCESS },
          { action: CivicPassMessageAction.ISSUANCE, event: CivicPassMessageEventResult.IN_PROGRESS },
        ].forEach(({ action, event }) => {
          Object.entries({
            ...validationProcessToGatewayStatus,
            [ValidationStatus.COMPLETED]: GatewayStatus.NOT_REQUESTED,
          }).forEach(([validationStatus, gatewayStatus]) => {
            context(`with a civicPass action: ${action}, event: ${event} payload status: ${validationStatus}`, () => {
              it('should return ' + gatewayStatus, () => {
                const state = {
                  inputs: {
                    civicPass: {
                      received: {
                        action,
                        event,
                        payload: {
                          status: validationStatus,
                        },
                      },
                    },
                    gatekeeperRecord: {
                      status: GatekeeperAPIStatus.NOT_REQUESTED,
                    },
                  },
                } as unknown as GatewayCoreState;
                const result = calculateIssuanceStatus(state);
                expect(result).to.equal(gatewayStatus);
              });
            });
          });
        });
      });

      context('with no validation status set', () => {
        it('should return NOT_REQUESTED', () => {
          const state = {
            inputs: {
              gatekeeperRecord: {
                status: GatekeeperAPIStatus.NOT_REQUESTED,
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateIssuanceStatus(state);
          expect(result).to.equal(GatewayStatus.NOT_REQUESTED);
        });
      });
    });

    context('with a GatekeeperAPIStatus of requested', () => {
      let parameters: GatewayClientParameters;
      context('with a TX that can be reissued', () => {
        context('with a payer equal to the wallet owner', () => {
          beforeEach(() => {
            parameters = {
              wallet: { address: 'payer' },
              payer: 'payer',
            } as GatewayClientParameters;
          });
          it('should return ISSUANCE_CLIENT_SENDS_START_NEW_TX', () => {
            // Arrange
            const state = {
              inputs: {
                parameters,
                civicPass: {
                  received: {
                    action: 'OTHER',
                    event: 'SUCCESS',
                  },
                },
                gatekeeperRecord: {
                  received: {
                    state: GatekeeperAPIStatus.REQUESTED,
                    transaction: 'transaction',
                    payload: {
                      preApprovedTxAvailable: true,
                    },
                  },
                },
              },
            } as unknown as GatewayCoreState;

            // Act
            const result = calculateIssuanceStatus(state);

            // Assert
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX);
          });
        });

        context('with a payer different from the wallet owner', () => {
          beforeEach(() => {
            parameters = {
              wallet: { address: 'payer' },
              payer: 'different_payer',
            } as GatewayClientParameters;
          });
          it('should return ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX', () => {
            // Arrange
            const state = {
              inputs: {
                parameters,
                civicPass: {
                  received: {
                    action: 'OTHER',
                    event: 'SUCCESS',
                  },
                },
                gatekeeperRecord: {
                  received: {
                    state: GatekeeperAPIStatus.REQUESTED,
                    transaction: 'transaction',
                    payload: {
                      preApprovedTxAvailable: true,
                    },
                  },
                },
              },
            } as unknown as GatewayCoreState;

            // Act
            const result = calculateIssuanceStatus(state);

            // Assert
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
          });
        });
      });

      context('if the record has a pending payload', () => {
        it('should return TOKEN_IN_PARTNER_REVIEW', () => {
          const state = {
            inputs: {
              gatekeeperRecord: {
                status: InputStatus.COMPLETE,
                received: {
                  state: GatekeeperAPIStatus.REQUESTED,
                  payload: {
                    pending: 'test-pending',
                  },
                },
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateIssuanceStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW);
        });
      });

      context('if a payer is set', () => {
        context('with a civicPass event of issuance complete with no transaction', () => {
          it('should return ISSUANCE_RESTART_DATA_COLLECTION', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                },
                civicPass: {
                  received: {
                    action: 'test-action',
                  },
                },
                gatekeeperRecord: {
                  status: InputStatus.COMPLETE,
                  received: {
                    state: GatekeeperAPIStatus.REQUESTED,
                  },
                },
              },
            } as unknown as GatewayCoreState;
            const result = calculateIssuanceStatus(state);
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION);
          });
        });
      });

      context('if a payer is not set', () => {
        it('should return ISSUANCE_AWAITING_ON_CHAIN_TOKEN', () => {
          const state = {
            inputs: {
              gatekeeperRecord: {
                status: InputStatus.COMPLETE,
                received: {
                  state: GatekeeperAPIStatus.REQUESTED,
                },
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateIssuanceStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN);
        });
      });
    });
  });

  context('calculateFromGatekeeperIssuanceRequested', () => {
    context('with a civicPass event', () => {
      [
        {
          status: InputStatus.COMPLETE,
          received: {
            state: GatekeeperAPIStatus.REQUESTED,
          },
        },
        {
          status: InputStatus.IN_PROGRESS,
          received: {
            state: GatekeeperAPIStatus.NOT_REQUESTED,
          },
        },
      ].forEach((gatekeeperRecordState) => {
        context(`with a gatekeeperRecord status of ${JSON.stringify(gatekeeperRecordState)}`, () => {
          context('with a payer set', () => {
            context('with the payer equal to the wallet owner', () => {
              it('should return ISSUANCE_CLIENT_PAYER_REQUESTED', () => {
                const state = {
                  inputs: {
                    parameters: {
                      payer: 'test-payer',
                      wallet: {
                        address: 'test-payer',
                      },
                    },
                    civicPass: {
                      received: {
                        action: CivicPassMessageAction.ISSUANCE,
                      },
                    },
                    gatekeeperRecord: gatekeeperRecordState,
                  },
                } as unknown as GatewayCoreState;
                const result = calculateFromGatekeeperIssuanceRequested(state);
                expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED);
              });
            });

            context('with the payer different from the wallet owner', () => {
              it('should return IN_REVIEW', () => {
                const state = {
                  inputs: {
                    parameters: {
                      payer: 'test-payer',
                      wallet: {
                        address: 'a-different-address',
                      },
                    },
                    civicPass: {
                      received: {
                        action: CivicPassMessageAction.ISSUANCE,
                      },
                    },
                    gatekeeperRecord: gatekeeperRecordState,
                  },
                } as unknown as GatewayCoreState;
                const result = calculateFromGatekeeperIssuanceRequested(state);
                expect(result).to.equal(GatewayStatus.IN_REVIEW);
              });
            });
          });
        });
      });

      context('with a gatekeeperRecord status not in-progress and not requested', () => {
        it('should return undefined', () => {
          const state = {
            inputs: {
              parameters: {
                payer: 'test-payer',
              },
              civicPass: {
                received: {
                  action: CivicPassMessageAction.ISSUANCE,
                },
              },
              gatekeeperRecord: {
                status: InputStatus.COMPLETE,
                received: {
                  state: GatekeeperAPIStatus.REJECTED,
                },
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateFromGatekeeperIssuanceRequested(state);
          expect(result).to.be.undefined;
        });
      });
    });
  });

  context('hasExistingDataCollectionProcessInProgress', () => {
    context('with no civicPass received', () => {
      it('should return false', () => {
        const result = hasExistingDataCollectionProcessInProgress(null);
        expect(result).to.be.false;
      });
    });

    context('with a civicPass received', () => {
      context('with a STATUS SUCCESS', () => {
        context('with a payload of NOT_FOUND', () => {
          it('should return false', () => {
            const result = hasExistingDataCollectionProcessInProgress({
              action: CivicPassMessageAction.STATUS,
              event: CivicPassMessageEventResult.SUCCESS,
              payload: {
                status: ValidationStatus.NOT_FOUND,
              },
            });
            expect(result).to.be.false;
          });
        });

        context('with any other payload than NOT_FOUND', () => {
          ['COLLECTING', 'PROCESSING', 'IN_REVIEW', 'COMPLETED', 'FAILED'].forEach((status) => {
            it(`should return true for status: ${status}`, () => {
              const result = hasExistingDataCollectionProcessInProgress({
                action: CivicPassMessageAction.STATUS,
                event: CivicPassMessageEventResult.SUCCESS,
                payload: {
                  status: status as ValidationStatus,
                },
              });
              expect(result).to.be.true;
            });
          });
        });
      });

      context('with an issuance in progress event', () => {
        it('should return true', () => {
          const result = hasExistingDataCollectionProcessInProgress({
            action: CivicPassMessageAction.ISSUANCE,
            event: CivicPassMessageEventResult.IN_PROGRESS,
          });
          expect(result).to.be.true;
        });
      });

      context('with a payload status of COLLECTING', () => {
        it('should return true', () => {
          const result = hasExistingDataCollectionProcessInProgress({
            action: CivicPassMessageAction.STATUS,
            event: CivicPassMessageEventResult.SUCCESS,
            payload: {
              status: ValidationStatus.COLLECTING,
            },
          });
          expect(result).to.be.true;
        });
      });
    });
  });
});

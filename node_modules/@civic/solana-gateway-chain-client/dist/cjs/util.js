"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.raceWithTimeout = exports.errorOnTimeout = exports.TimeoutError = exports.parseTransactionErrorCode = exports.createSolanaTransactionFromBase64 = void 0;
const web3_js_1 = require("@solana/web3.js");
const gateway_client_core_1 = require("@civic/gateway-client-core");
const logger = (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation');
const createSolanaTransactionFromBase64 = (partiallySignedTx) => web3_js_1.Transaction.from(Buffer.from(partiallySignedTx, 'base64'));
exports.createSolanaTransactionFromBase64 = createSolanaTransactionFromBase64;
const insufficientFundsMessages = ['insufficient funds', 'custom program error: 0x1'];
const isClientWalletFundsError = (error) => {
    if (insufficientFundsMessages.map((msg) => { var _a; return (_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(msg); }).includes(true)) {
        return true;
    }
    return false;
};
// error: WalletSignMessageError
const isWalletSignMessageError = (error) => {
    var _a, _b;
    return !!(((_a = error === null || error === void 0 ? void 0 : error.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('walletsignmessageerror')) ||
        ((_b = error === null || error === void 0 ? void 0 : error.message) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes('walletsignmessageerror')));
};
// error: WalletSignMessageError: User rejected the request
const isUserRejectedError = (error) => {
    var _a;
    return !!((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('user rejected'));
};
const parseTransactionErrorCode = (error) => {
    if (isClientWalletFundsError(error)) {
        logger.warn('parseTransactionErrorCode - INSUFFICIENT_FUNDS error detected', error);
        return gateway_client_core_1.ErrorCode.INSUFFICIENT_FUNDS;
    }
    if (isUserRejectedError(error)) {
        logger.warn('parseTransactionErrorCode - SIGN_TRANSACTION_USER_REJECTED_ERROR error detected', error);
        return gateway_client_core_1.ErrorCode.SIGN_TRANSACTION_USER_REJECTED_ERROR;
    }
    if (isWalletSignMessageError(error)) {
        logger.warn('parseTransactionErrorCode - SIGN_TRANSACTION_ERROR error detected', error);
        return gateway_client_core_1.ErrorCode.SIGN_TRANSACTION_ERROR;
    }
    return gateway_client_core_1.ErrorCode.SIGN_TRANSACTION_UNKNOWN_ERROR;
};
exports.parseTransactionErrorCode = parseTransactionErrorCode;
class TimeoutError extends Error {
    constructor() {
        super('TimeoutError');
        Object.setPrototypeOf(this, TimeoutError.prototype); // required for instance checking
    }
}
exports.TimeoutError = TimeoutError;
const errorOnTimeout = (timeoutMs) => new Promise((_resolve, reject) => setTimeout(() => {
    reject(new TimeoutError());
}, timeoutMs));
exports.errorOnTimeout = errorOnTimeout;
const raceWithTimeout = async (fn, timeoutMs) => Promise.race([(0, exports.errorOnTimeout)(timeoutMs), fn()]);
exports.raceWithTimeout = raceWithTimeout;

import sinon, { SinonStub } from 'sinon';
import { Orchestrator } from '../src/orchestrate';
import { RemoteSignWindowEventEmitter } from '../src/remoteSign';
import { ChainClientInterface } from '../src/types/chain';
import { MessageEventInterface, PostMessageInterface, PostMessageTargetCallback } from '../src/types/eventInterface';
import { FetchConfig, InputStatus } from '../src/types/fetch';
import chai from 'chai';
import { OrchestratorInputs } from '../src/types/orchestrate';
import { ExtendedGatewayStatus } from '../src/types/gateway';
import chaiSubset from 'chai-subset';
import { GatewayCoreState } from '../src/types/gatewayCore';
import { createGatewayCoreStore, Store } from '../src/state/state';
import { ListenerManager } from '../src/listeners';
import * as getGatekeeperNetworkData from '../src/gatekeeperNetworkService';
import { IntegrationTestHelpers, sleep } from './testSupport';

chai.use(chaiSubset);
const { expect } = chai;

const sandbox = sinon.createSandbox();
describe('orchestrate', () => {
  let messageEventInterface: MessageEventInterface;
  let instanceId: string;
  let inputs: OrchestratorInputs;
  let fetchConfig: FetchConfig;
  let postMessageTargetCallback: PostMessageTargetCallback;
  let fetchImplementationStub: any;
  let testHelpers: IntegrationTestHelpers;
  let gatewayCoreStore: Store;

  afterEach(sandbox.restore);

  const dummyGKNData = { test: 'data' } as unknown as getGatekeeperNetworkData.GknData;
  let getGatekeeperNetworkDataStub: sinon.SinonStub<
    [stage: string, gknId: string],
    Promise<getGatekeeperNetworkData.GknData>
  >;
  beforeEach(() => {
    getGatekeeperNetworkDataStub = sandbox.stub(getGatekeeperNetworkData, 'getGatekeeperNetworkData');
    getGatekeeperNetworkDataStub.resolves(dummyGKNData);
    gatewayCoreStore = createGatewayCoreStore({ name: 'test' });
    fetchImplementationStub = sandbox.stub().returns(
      Promise.resolve({
        status: 200,
        json: () => Promise.resolve({ id: '123' }),
        clone: () => ({
          // Add a clone method that returns an object similar to the original response
          json: () => Promise.resolve({ id: '123' }),
        }),
      })
    );
    messageEventInterface = {
      addMessageEventListener: () => 123,
      removeMessageEventListener: () => ({}),
    } as MessageEventInterface;
    instanceId = 'testInstance';
    inputs = {
      wallet: { address: '0x123' },
      gatekeeperConfig: {
        baseUrl: 'https://example.com',
        headers: {},
      },
      gatekeeperNetwork: '0x456',
      stage: 'test',
      payer: '0x789',
      gatekeeperSendsTransaction: true,
    } as OrchestratorInputs;
    fetchConfig = { fetchImplementation: fetchImplementationStub, numRetries: 3 } as FetchConfig;
    postMessageTargetCallback = () =>
      ({
        postMessage: () => {},
      } as PostMessageInterface);
  });

  context('getRemoteSignInstance', () => {
    it('should return the remoteSignInstance', () => {
      const orchestrator = new Orchestrator(
        gatewayCoreStore,
        messageEventInterface,
        instanceId,
        inputs,
        fetchConfig,
        postMessageTargetCallback,
        {} as unknown as ChainClientInterface
      );

      const remoteSignInstance = orchestrator.getRemoteSignInstance();
      expect(remoteSignInstance).to.be.an.instanceOf(RemoteSignWindowEventEmitter);
    });

    it('should recreate after initialisation', () => {
      const orchestrator = new Orchestrator(
        gatewayCoreStore,
        messageEventInterface,
        instanceId,
        inputs,
        fetchConfig,
        postMessageTargetCallback,
        {} as unknown as ChainClientInterface
      );

      const remoteSignInstance = orchestrator.getRemoteSignInstance();
      expect(remoteSignInstance).to.be.an.instanceOf(RemoteSignWindowEventEmitter);
      orchestrator.reset();
      expect(orchestrator.remoteSignInstance).to.be.undefined;
    });
  });

  context('initialise', () => {
    it('should set remoteSignInstance to undefined', () => {
      const orchestrator = new Orchestrator(
        gatewayCoreStore,
        messageEventInterface,
        instanceId,
        inputs,
        fetchConfig,
        postMessageTargetCallback,
        {} as unknown as ChainClientInterface
      );
      orchestrator.initialise();
      expect(orchestrator.remoteSignInstance).to.be.undefined;
    });

    it('should throw for invalid chain implementation input', () => {
      expect(
        () =>
          new Orchestrator(
            gatewayCoreStore,
            messageEventInterface,
            instanceId,
            inputs,
            fetchConfig,
            postMessageTargetCallback,
            false as unknown as ChainClientInterface
          )
      ).to.throw('chainImplementation wallet and stage are required');
    });

    it('should throw for invalid wallet address input', () => {
      expect(
        () =>
          new Orchestrator(
            gatewayCoreStore,
            messageEventInterface,
            instanceId,
            {
              ...inputs,
              wallet: { address: false as unknown as string },
            },
            fetchConfig,
            postMessageTargetCallback,
            {} as unknown as ChainClientInterface
          )
      ).to.throw('chainImplementation wallet and stage are required');
    });

    it('should throw for invalid stage input', () => {
      expect(
        () =>
          new Orchestrator(
            gatewayCoreStore,
            messageEventInterface,
            instanceId,
            {
              ...inputs,
              stage: undefined,
            },
            fetchConfig,
            postMessageTargetCallback,
            {} as unknown as ChainClientInterface
          )
      ).to.throw('chainImplementation wallet and stage are required');
    });

    it('should call getOwnerDids, lookupTokenState and fetchGatekeeperNetworkData', () => {
      const chainClientInterface = {
        ownerDids: sandbox.stub().resolves([]),
      } as unknown as ChainClientInterface;
      const orchestrator = new Orchestrator(
        gatewayCoreStore,
        messageEventInterface,
        instanceId,
        inputs,
        fetchConfig,
        postMessageTargetCallback,
        chainClientInterface
      );
      const spyLookupTokenState = sandbox.spy(orchestrator, 'lookupTokenState');
      const spyFetchGatekeeperData = sandbox.spy(orchestrator, 'fetchGatekeeperNetworkData');
      orchestrator.initialise();
      expect(chainClientInterface.ownerDids).to.be.calledOnce;
      expect(spyLookupTokenState).to.be.calledOnce;
      expect(spyFetchGatekeeperData).to.be.calledOnce;
    });

    context('fetchGatekeeperNetworkData', () => {
      let orchestrator: Orchestrator;
      beforeEach(() => {
        testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
        gatewayCoreStore = testHelpers.getInitializedStore();
        const chainClientInterface = {
          ownerDids: sandbox.stub().resolves([]),
        } as unknown as ChainClientInterface;
        orchestrator = new Orchestrator(
          gatewayCoreStore,
          messageEventInterface,
          instanceId,
          inputs,
          fetchConfig,
          postMessageTargetCallback,
          chainClientInterface
        );
      });

      context('with a successful call', () => {
        it('should set the gatekeeperNetworkData', async () => {
          await orchestrator.fetchGatekeeperNetworkData();
          await sleep(10);
          const state = gatewayCoreStore.getState();
          expect(state.inputs.gatekeeperNetworkData.status).to.equal(InputStatus.COMPLETE);
          expect(state.inputs.gatekeeperNetworkData.received).to.deep.eq(dummyGKNData);
        });
      });

      context('with a failed call', () => {
        let error: Error;
        beforeEach(() => {
          error = new Error('test error');
          getGatekeeperNetworkDataStub.rejects(error);
        });
        it('should set the status to InputStatus.Error', async () => {
          await orchestrator.fetchGatekeeperNetworkData();
          await sleep(10);
          const state = gatewayCoreStore.getState();
          expect(state.inputs.gatekeeperNetworkData.status).to.equal(InputStatus.ERROR);
          expect(state.inputs.gatekeeperNetworkData.error).to.deep.eq(error);
        });
      });
    });
  });

  context('reset', () => {
    let gatewayCoreStoreResetStub: sinon.SinonStub<any[], any>;
    beforeEach(() => {
      gatewayCoreStoreResetStub = sandbox.stub();
      sandbox.stub(gatewayCoreStore, 'getState').returns({
        functions: {
          reset: gatewayCoreStoreResetStub,
        },
      } as unknown as GatewayCoreState);
    });
    it('should reset the state', () => {
      const orchestrator = new Orchestrator(
        gatewayCoreStore,
        messageEventInterface,
        instanceId,
        inputs,
        fetchConfig,
        postMessageTargetCallback,
        {} as unknown as ChainClientInterface
      );
      orchestrator.reset();
      expect(gatewayCoreStoreResetStub).to.be.calledOnce;
    });

    it('should call initialise', () => {
      const orchestrator = new Orchestrator(
        gatewayCoreStore,
        messageEventInterface,
        instanceId,
        inputs,
        fetchConfig,
        postMessageTargetCallback,
        {} as unknown as ChainClientInterface
      );
      const spy = sandbox.spy(orchestrator, 'initialise');
      orchestrator.reset();
      expect(spy).to.be.calledOnce;
    });
  });
  context('onGatwayStatusChange', () => {
    context('on internal.status change to RESTART', () => {
      it('should reset the state', async () => {
        const orchestrator = new Orchestrator(
          gatewayCoreStore,
          messageEventInterface,
          instanceId,
          inputs,
          fetchConfig,
          postMessageTargetCallback,
          {} as unknown as ChainClientInterface
        );
        const spy = sandbox.spy(orchestrator, 'reset');
        orchestrator.onInternalStatusChange(ExtendedGatewayStatus.RESTART);
        expect(spy).to.be.calledOnce;
      });
    });
  });

  context('listener registration', () => {
    let registerOnChainStub: SinonStub;
    beforeEach(() => {
      registerOnChainStub = sandbox.stub(ListenerManager.prototype, 'registerOnChainListeners');
    });
    context('on-chain listener', () => {
      it('should register on-chain listener', () => {
        const orchestrator = new Orchestrator(
          gatewayCoreStore,
          messageEventInterface,
          instanceId,
          inputs,
          fetchConfig,
          postMessageTargetCallback,
          {} as unknown as ChainClientInterface
        );
        orchestrator.orchestrate();
        expect(registerOnChainStub).to.have.been.calledOnceWith(sinon.match.func);
      });
    });
  });
});

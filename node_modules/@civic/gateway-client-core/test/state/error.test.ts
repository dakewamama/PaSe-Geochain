import { ClientCoreInternal, ExtendedGatewayStatus, GatewayCoreState, GatewayStatus } from '../../src';
import { handleChainError, handleGatekeeperError, handleUserValidationFailed } from '../../src/state/error';
import chai from 'chai';
import { CivicPassMessageAction, CivicPassMessageEventResult } from '../../src/types/civicPass';
import { InputStatus } from '../../src/types/fetch';

const { expect } = chai;

describe('error state tests', () => {
  let internalState: ClientCoreInternal;
  context('handleChainError', () => {
    context('with a civic pass failure event', () => {
      context('with a chain error action', () => {
        context('when the user has not exceeded the maximum number of client sends retries', () => {
          beforeEach(() => {
            internalState = {
              status: GatewayStatus.NOT_REQUESTED,
              userInteraction: { status: null },
              chainTransaction: {
                error: new Error('Chain error'),
                attempts: 1,
              },
              errors: {},
              ownerDids: [],
            };
          });
          context('with a gateway token', () => {
            it('should return the refresh awaiting transaction send status', () => {
              const state = {
                inputs: {
                  civicPass: {
                    status: InputStatus.COMPLETE,
                    received: {
                      event: CivicPassMessageEventResult.FAILURE,
                      action: CivicPassMessageAction.CHAIN_ERROR,
                    },
                  },
                  gatekeeperRecord: { status: null, received: null },
                  gatewayToken: { status: null, received: { state: 'ACTIVE' } },
                },
                internal: internalState,
                output: {},
              } as unknown as GatewayCoreState;
              const result = handleChainError(state);
              expect(result).to.equal('REFRESH_AWAITING_TRANSACTION_SEND');
            });
          });

          context('with no gateway token', () => {
            it('should return the issuance awaiting transaction send status', () => {
              const state = {
                inputs: {
                  civicPass: {
                    status: InputStatus.COMPLETE,
                    received: {
                      event: CivicPassMessageEventResult.FAILURE,
                      action: CivicPassMessageAction.CHAIN_ERROR,
                    },
                  },
                  gatekeeperRecord: { status: null, received: null },
                  gatewayToken: { status: InputStatus.COMPLETE, received: null },
                },
                internal: internalState,
                output: {},
              } as unknown as GatewayCoreState;
              const result = handleChainError(state);
              expect(result).to.equal('ISSUANCE_AWAITING_TRANSACTION_SEND');
            });
          });
        });

        context('when the user has exceeded the maximum number of client sends retries', () => {
          beforeEach(() => {
            internalState = {
              status: GatewayStatus.NOT_REQUESTED,
              userInteraction: { status: null },
              chainTransaction: {
                error: new Error('Chain error'),
                attempts: 4,
              },
              errors: {},
              ownerDids: [],
            };
          });
          context('with an expired gateway token', () => {
            it('should return RESTART_REFRESH', () => {
              const state = {
                inputs: {
                  civicPass: {
                    status: InputStatus.COMPLETE,
                    received: {
                      event: CivicPassMessageEventResult.FAILURE,
                      action: CivicPassMessageAction.CHAIN_ERROR,
                    },
                  },
                  gatekeeperRecord: { status: null, received: null },
                  gatewayToken: { status: null, received: { state: 'ACTIVE' } },
                },
                internal: internalState,
                output: {},
              } as unknown as GatewayCoreState;
              const result = handleChainError(state);
              expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX);
            });

            context('with a third party payer', () => {
              it('should return RESTART_REFRESH', () => {
                const state = {
                  inputs: {
                    civicPass: {
                      status: InputStatus.COMPLETE,
                      received: {
                        event: CivicPassMessageEventResult.FAILURE,
                        action: CivicPassMessageAction.CHAIN_ERROR,
                      },
                    },
                    parameters: {
                      payer: 'test-payer',
                    },
                    gatekeeperRecord: { status: null, received: null },
                    gatewayToken: { status: null, received: { state: 'ACTIVE' } },
                  },
                  internal: internalState,
                  output: {},
                } as unknown as GatewayCoreState;
                const result = handleChainError(state);
                expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
              });
            });
          });

          context('with no gateway token', () => {
            it('should return RESTART', () => {
              const state = {
                inputs: {
                  civicPass: {
                    status: InputStatus.COMPLETE,
                    received: {
                      event: CivicPassMessageEventResult.FAILURE,
                      action: CivicPassMessageAction.CHAIN_ERROR,
                    },
                  },
                  gatekeeperRecord: { status: null, received: null },
                  gatewayToken: { status: null, received: null },
                },
                internal: internalState,
                output: {},
              } as unknown as GatewayCoreState;
              const result = handleChainError(state);
              expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX);
            });
          });

          context('with a third party payer', () => {
            it('should return RESTART', () => {
              const state = {
                inputs: {
                  civicPass: {
                    status: InputStatus.COMPLETE,
                    received: {
                      event: CivicPassMessageEventResult.FAILURE,
                      action: CivicPassMessageAction.CHAIN_ERROR,
                    },
                  },
                  gatekeeperRecord: { status: null, received: null },
                  gatewayToken: { status: null, received: null },
                  parameters: {
                    payer: 'test-payer',
                  },
                },
                internal: internalState,
                output: {},
              } as unknown as GatewayCoreState;
              const result = handleChainError(state);
              expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
            });
          });
        });
      });

      context('with an error action', () => {
        beforeEach(() => {
          internalState = {
            status: GatewayStatus.NOT_REQUESTED,
            userInteraction: { status: null },
            chainTransaction: {
              error: new Error('Chain error'),
              attempts: 1,
            },
            errors: {},
            ownerDids: [],
          };
        });
        it('should return the internal status', () => {
          const state = {
            inputs: {
              civicPass: {
                status: InputStatus.COMPLETE,
                received: {
                  event: CivicPassMessageEventResult.FAILURE,
                  action: CivicPassMessageAction.ERROR,
                },
              },
              gatekeeperRecord: { status: null, received: null },
              gatewayToken: { status: null, received: null },
            },
            internal: internalState,
            output: {},
          } as unknown as GatewayCoreState;
          const result = handleChainError(state);
          expect(result).to.equal(GatewayStatus.NOT_REQUESTED);
        });
      });
    });

    context('with a civic sign failure', () => {
      context('with a gateway token', () => {
        it('should return RESTART_REFRESH', () => {
          const state = {
            inputs: {
              civicSign: {
                status: InputStatus.ERROR,
              },
              civicPass: {
                status: InputStatus.COMPLETE,
                received: {
                  event: CivicPassMessageEventResult.FAILURE,
                  action: CivicPassMessageAction.ERROR,
                },
              },
              gatekeeperRecord: { status: null, received: null },
              gatewayToken: { status: null, received: { state: 'ACTIVE' } },
            },
            internal: internalState,
            output: {},
          } as unknown as GatewayCoreState;
          const result = handleGatekeeperError(state);
          expect(result).to.equal(ExtendedGatewayStatus.RESTART_REFRESH);
        });
      });

      context('with no gateway token', () => {
        it('should return RESTART', () => {
          const state = {
            inputs: {
              civicSign: {
                status: InputStatus.ERROR,
              },
              civicPass: {
                status: InputStatus.COMPLETE,
                received: {
                  event: CivicPassMessageEventResult.FAILURE,
                  action: CivicPassMessageAction.ERROR,
                },
              },
              gatekeeperRecord: { status: null, received: null },
              gatewayToken: { status: null, received: null },
            },
            internal: internalState,
            output: {},
          } as unknown as GatewayCoreState;
          const result = handleGatekeeperError(state);
          expect(result).to.equal(ExtendedGatewayStatus.RESTART);
        });
      });
    });
  });

  context('handleGatekeeperError', () => {
    context('with a civic pass failure event', () => {
      context('with an error action', () => {
        context('with a gateway token', () => {
          it('should return RESTART_REFRESH', () => {
            const state = {
              inputs: {
                civicPass: {
                  status: InputStatus.COMPLETE,
                  received: {
                    event: CivicPassMessageEventResult.FAILURE,
                    action: CivicPassMessageAction.ERROR,
                  },
                },
                gatekeeperRecord: { status: null, received: null },
                gatewayToken: { status: null, received: { state: 'ACTIVE' } },
              },
              internal: internalState,
              output: {},
            } as unknown as GatewayCoreState;
            const result = handleGatekeeperError(state);
            expect(result).to.equal(ExtendedGatewayStatus.RESTART_REFRESH);
          });
        });

        context('with no gateway token', () => {
          it('should return RESTART', () => {
            const state = {
              inputs: {
                civicPass: {
                  status: InputStatus.COMPLETE,
                  received: {
                    event: CivicPassMessageEventResult.FAILURE,
                    action: CivicPassMessageAction.ERROR,
                  },
                },
                gatekeeperRecord: { status: null, received: null },
                gatewayToken: { status: null, received: null },
              },
              internal: internalState,
              output: {},
            } as unknown as GatewayCoreState;
            const result = handleGatekeeperError(state);
            expect(result).to.equal(ExtendedGatewayStatus.RESTART);
          });
        });
      });

      context('with a chain error action', () => {
        it('should return the internal status', () => {
          const state = {
            inputs: {
              civicPass: {
                status: InputStatus.COMPLETE,
                received: {
                  event: CivicPassMessageEventResult.FAILURE,
                  action: CivicPassMessageAction.CHAIN_ERROR,
                },
              },
              gatekeeperRecord: { status: null, received: null },
              gatewayToken: { status: null, received: null },
            },
            internal: internalState,
            output: {},
          } as unknown as GatewayCoreState;
          const result = handleGatekeeperError(state);
          expect(result).to.equal(GatewayStatus.NOT_REQUESTED);
        });
      });
    });
  });

  context('handleUserValidationFailed', () => {
    it('should return RESTART state if disableAutoRestartOnValidationFailure is not defined', () => {
      const state = {
        inputs: {
          parameters: {},
        },
      } as unknown as GatewayCoreState;
      const result = handleUserValidationFailed(state);
      expect(result).to.equal(ExtendedGatewayStatus.RESTART);
    });

    it('should return RESTART state if disableAutoRestartOnValidationFailure is false', () => {
      const state = {
        inputs: {
          parameters: {
            options: {
              disableAutoRestartOnValidationFailure: false,
            },
          },
        },
      } as unknown as GatewayCoreState;
      const result = handleUserValidationFailed(state);
      expect(result).to.equal(ExtendedGatewayStatus.RESTART);
    });

    it('should return USER_VALIDATION_FAILED state if disableAutoRestartOnValidationFailure is true', () => {
      const state = {
        inputs: {
          parameters: {
            options: {
              disableAutoRestartOnValidationFailure: true,
            },
          },
        },
      } as unknown as GatewayCoreState;
      const result = handleUserValidationFailed(state);
      expect(result).to.equal(ExtendedGatewayStatus.USER_VALIDATION_FAILED);
    });
  });
});

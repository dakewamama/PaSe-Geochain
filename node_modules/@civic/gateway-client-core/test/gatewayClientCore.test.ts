import chai from 'chai';
import sinon from 'sinon';
import {
  GatewayClientCore,
  getInstanceInputObject,
  getInstanceName,
  hasRequiredInputs,
  shouldUpdateInstance,
} from '../src/GatewayClientCore';
import { IntegrationTestHelpers } from './testSupport';
import sinonChai from 'sinon-chai';
import { ClientCoreInput } from '../src/types/clientCore';
import { ChainClientInterface } from '../src/types/chain';
import { GknData, Stage } from '../src';
import * as state from '../src/state/state';
import { Store, WritableDraft } from '../src/state/state';
import { UserInteractionStatus } from '../src/types/userInteraction';
import { UIManager } from '../src/ui';
import { Orchestrator } from '../src/orchestrate';
import { InputStatus } from '../src/types/fetch';

chai.use(sinonChai);
const { expect } = chai;
const sandbox = sinon.createSandbox();

describe('GatewayClientCore tests', () => {
  let testHelpers: IntegrationTestHelpers;
  let coreInput: ClientCoreInput;

  beforeEach(() => {
    testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
    testHelpers.stubSuccessfulFetchCalls({ postResponsePayload: { transaction: undefined }, payer: null });
  });

  afterEach(() => {
    testHelpers.cleanup();
    sandbox.restore();
  });

  context('getSingleInstance', () => {
    context('with no existing instance', () => {
      it('should return a new instance', () => {
        expect(GatewayClientCore.currentInstance).to.be.undefined;
        // Arrange
        coreInput = testHelpers.getCoreInputs();

        // Act
        const result = GatewayClientCore.getSingleInstance(coreInput);

        // Assert
        expect(result).to.be.an.instanceOf(GatewayClientCore);
        expect(GatewayClientCore.currentInstance).to.equal(result);
        expect(result?.instanceId).to.be.a('string');
      });
    });

    context('with an existing instance', () => {
      let existingInstance: GatewayClientCore;
      let abortStub: sinon.SinonStub<[], void>;
      beforeEach(() => {
        coreInput = testHelpers.getCoreInputs();
        existingInstance = new GatewayClientCore(coreInput);
        abortStub = sandbox.stub(existingInstance, 'abort');
        GatewayClientCore.currentInstance = existingInstance;
      });
      context('with no wallet address or chain implementation', () => {
        it('should abort the existing instance', () => {
          // Act
          const result = GatewayClientCore.getSingleInstance({
            ...coreInput,
            parameters: { ...coreInput.parameters, wallet: undefined },
          });

          // Assert
          expect(abortStub).to.have.been.calledOnce;
          expect(result).to.be.undefined;
        });
      });

      context('when the inputs change', () => {
        context('with a change that should cause a new instance to be created', () => {
          [
            { wallet: { address: 'new_wallet' } },
            {
              gatekeeperConfig: { headers: { test: 'header' }, baseUrl: 'https://api.example.com' },
            },
            { gatekeeperNetwork: 'new_gatekeeperNetwork' },
            { payer: 'new_payer' },
            { gatekeeperSendsTransaction: false },
            { stage: 'dev' as Stage },
            { redirectUrl: 'new_redirectUrl' },
            { options: { autoShowModal: false } },
            { expiryMarginSeconds: 789 },
            { partnerAppId: 'new_partnerAppId' },
            { expectTokenTimeoutSeconds: 9876 },
            { clientSendMaxRetries: 9 },
            { disableInitialGatekeeperLookup: true },
            { flowIdPrefix: 'new_flowIdPrefix' },
            { xCivicClientHeader: 'new_xCivicClientHeader' },
            { referrer: 'new_referrer' },
          ].forEach((coreInputChange) => {
            context(`with a change in parameters of ${JSON.stringify(coreInputChange)}`, () => {
              beforeEach(() => {
                coreInput = testHelpers.getCoreInputs(coreInputChange);
              });
              it('should abort the existing instance and return a new instance', () => {
                const prevInstanceId = GatewayClientCore.currentInstance?.instanceId;
                const result = GatewayClientCore.getSingleInstance(coreInput);
                expect(abortStub).to.have.been.calledOnce;
                expect(result).to.be.an.instanceOf(GatewayClientCore);
                expect(GatewayClientCore.currentInstance?.instanceId).to.be.a('string').and.not.equal(prevInstanceId);
              });
            });
          });

          [
            {
              on: () => {},
              findGatewayToken: () => {},
              proveWalletOwnership: () => {},
              ownerDids: () => {},
              onDestroy: () => {},
              chainDetails: { chainType: 'new_chainType', chainNetwork: 'new_chainType' },
            },
          ].forEach((chainImplOverride) => {
            context(`with a change in chain implementation of ${JSON.stringify(chainImplOverride)}`, () => {
              beforeEach(() => {
                coreInput = testHelpers.getCoreInputs({}, chainImplOverride as unknown as ChainClientInterface);
              });
              it('should abort the existing instance and return a new instance', () => {
                const prevInstanceId = GatewayClientCore.currentInstance?.instanceId;
                const result = GatewayClientCore.getSingleInstance(coreInput);
                expect(abortStub).to.have.been.calledOnce;
                expect(result).to.be.an.instanceOf(GatewayClientCore);
                expect(GatewayClientCore.currentInstance?.instanceId).to.be.a('string').and.not.equal(prevInstanceId);
              });
            });
          });
        });

        context('with a change that should not cause a new instance to be created', () => {
          beforeEach(() => {
            coreInput = testHelpers.getCoreInputs();
          });
          it('should return the existing instance without aborting', () => {
            const prevInstanceId = GatewayClientCore.currentInstance?.instanceId;
            const result = GatewayClientCore.getSingleInstance({
              ...coreInput,
              fetchConfig: { fetchImplementation: fetch, numRetries: 8 },
            });
            expect(abortStub.callCount).to.equal(0);
            expect(result).to.be.an.instanceOf(GatewayClientCore);
            expect(GatewayClientCore.currentInstance?.instanceId).to.be.a('string').and.equal(prevInstanceId);
          });
        });
      });

      context('when the inputs stay the same', () => {
        beforeEach(() => {
          coreInput = testHelpers.getCoreInputs();
        });
        it('should return the existing instance without aborting', () => {
          const prevInstanceId = GatewayClientCore.currentInstance?.instanceId;
          const result = GatewayClientCore.getSingleInstance(coreInput);
          expect(abortStub.callCount).to.equal(0);
          expect(result).to.be.an.instanceOf(GatewayClientCore);
          expect(GatewayClientCore.currentInstance?.instanceId).to.be.a('string').and.equal(prevInstanceId);
        });
      });
    });
  });

  context('startOrResumeFlow', () => {
    let store: WritableDraft<Store>;
    beforeEach(() => {
      store = state.createGatewayCoreStore({ name: 'test' });
      sandbox.stub(state, 'createGatewayCoreStore').returns(store);
    });
    it('should set the user interaction status to STARTED', () => {
      // Arrange
      coreInput = testHelpers.getCoreInputs();
      const instance = new GatewayClientCore(coreInput);

      // Act
      instance.startOrResumeFlow();

      // Assert
      const newState = store.getState();
      expect(newState.internal.userInteraction.status).to.equal(UserInteractionStatus.STARTED);
    });
  });

  context('abort', () => {
    it('should call orchestrate.abort', () => {
      coreInput = testHelpers.getCoreInputs();
      const instance = new GatewayClientCore(coreInput);
      const orchestratorAbortStub = sandbox.stub(Orchestrator.prototype, 'abort');
      instance.abort();
      expect(orchestratorAbortStub.callCount).to.eq(1);
    });
  });

  context('updateDynamicParameters', () => {
    let store: WritableDraft<Store>;
    beforeEach(() => {
      store = state.createGatewayCoreStore({ name: 'test' });
      sandbox.stub(state, 'createGatewayCoreStore').returns(store);
    });
    it('should update the dynamic parameters in the store', () => {
      // Arrange
      coreInput = testHelpers.getCoreInputs();
      const instance = new GatewayClientCore(coreInput);
      const dynamicParameters = { forceRequireRefresh: true };

      // Act
      instance.updateDynamicParameters(dynamicParameters);

      // Assert
      const newState = store.getState();
      expect(newState.inputs.dynamicParameters).to.deep.equal(dynamicParameters);
    });
  });

  context('updateGatekeeperNetworkServiceData', () => {
    let store: WritableDraft<Store>;
    beforeEach(() => {
      store = state.createGatewayCoreStore({ name: 'test' });
      sandbox.stub(state, 'createGatewayCoreStore').returns(store);
    });
    it('should update the gatekeeper network data in the store', () => {
      // Arrange
      coreInput = testHelpers.getCoreInputs();
      const instance = new GatewayClientCore(coreInput);
      const gknData: GknData = {
        id: 'gknId',
        chains: {
          ethereum: { chainSpecificId: '123' },
          solana: { chainSpecificId: '456' },
          casper: { chainSpecificId: '789' },
        },
        client: {
          tokenActiveDisplay: 'default',
        },
      };

      // Act
      instance.updateGatekeeperNetworkServiceData({ status: InputStatus.COMPLETE, received: gknData });

      // Assert
      const newState = store.getState();
      expect(newState.inputs.gatekeeperNetworkData.received).to.deep.equal(gknData);
    });
  });

  context('ui', () => {
    let store: WritableDraft<Store>;
    beforeEach(() => {
      store = state.createGatewayCoreStore({ name: 'test' });
      sandbox.stub(state, 'createGatewayCoreStore').returns(store);
    });

    context('onShow', () => {
      it('should call onShow on the UIManager', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const onShowStub = sandbox.stub(UIManager.prototype, 'onShow').returns(undefined);
        const instance = new GatewayClientCore(coreInput);

        // Act
        instance.ui.onShow();

        // Assert
        expect(onShowStub.callCount).to.eq(1);
      });
    });

    context('onHide', () => {
      it('should call onHide on the UIManager', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const onHideStub = sandbox.stub(UIManager.prototype, 'onHide').returns(undefined);
        const instance = new GatewayClientCore(coreInput);

        // Act
        instance.ui.onHide();

        // Assert
        expect(onHideStub.callCount).to.eq(1);
      });
    });

    context('onLoad', () => {
      it('should call onLoad on the UIManager', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const onLoadStub = sandbox.stub(UIManager.prototype, 'onLoad').returns(undefined);
        const instance = new GatewayClientCore(coreInput);

        // Act
        instance.ui.onLoad();

        // Assert
        expect(onLoadStub.callCount).to.eq(1);
      });
    });
  });

  context('getInstanceInputObject', () => {
    context('with a valid input object', () => {
      it('should return the instance input object', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();

        // Act
        const result = getInstanceInputObject(coreInput);

        // Assert
        expect(result).to.deep.equal({
          ...coreInput.parameters,
          ...coreInput.chainImplementation.chainDetails,
        });
      });
    });

    context('with an undefined input object', () => {
      it('should return an empty object', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const undefinedInput = undefined;

        // Act
        const result = getInstanceInputObject(undefinedInput);

        // Assert
        expect(result).to.deep.equal({});
      });
    });
  });

  context('shouldUpdateInstance', () => {
    context('with no instance', () => {
      it('should return true', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const instance = undefined;

        // Act
        const result = shouldUpdateInstance(coreInput, instance);

        // Assert
        expect(result).to.be.true;
      });
    });

    context('with an instance and different inputs', () => {
      it('should return true', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const instance = new GatewayClientCore(coreInput);
        const differentInputs = testHelpers.getCoreInputs({ wallet: { address: 'new_wallet' } });

        // Act
        const result = shouldUpdateInstance(differentInputs, instance);

        // Assert
        expect(result).to.be.true;
      });
    });

    context('with an instance and the same inputs', () => {
      it('should return false', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();
        const instance = new GatewayClientCore(coreInput);

        // Act
        const result = shouldUpdateInstance(coreInput, instance);

        // Assert
        expect(result).to.be.false;
      });
    });
  });

  context('hasRequiredInputs', () => {
    context('with no wallet address', () => {
      it('should return false', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs({ wallet: undefined });

        // Act
        const result = hasRequiredInputs(coreInput);

        // Assert
        expect(result).to.be.false;
      });
    });

    context('with no chain implementation', () => {
      it('should return false', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs({}, null as unknown as ChainClientInterface);

        // Act
        const result = hasRequiredInputs(coreInput);

        // Assert
        expect(result).to.be.false;
      });
    });

    context('with a wallet address and a chain implementation', () => {
      it('should return true', () => {
        // Arrange
        coreInput = testHelpers.getCoreInputs();

        // Act
        const result = hasRequiredInputs(coreInput);

        // Assert
        expect(result).to.be.true;
      });
    });
  });

  context('getInstanceName', () => {
    it('should return the instance name', () => {
      // Arrange
      coreInput = testHelpers.getCoreInputs();
      const instance = new GatewayClientCore(coreInput);

      // Act
      const result = getInstanceName(coreInput, instance.instanceId);

      // Assert
      expect(result).to.equal(
        `gcc_${coreInput.parameters.wallet?.address?.substring(
          0,
          4
        )}_${coreInput.parameters?.gatekeeperNetwork?.substring(0, 4)}_${
          coreInput.chainImplementation?.chainDetails?.chainType
        }_${coreInput.chainImplementation?.chainDetails?.chainNetwork}_${instance.instanceId.substring(0, 4)}`
      );
    });
  });
});

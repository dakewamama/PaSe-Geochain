import { GatekeeperHttpConfig } from './parameters';

export enum State {
  ACTIVE = 'ACTIVE',
  REVOKED = 'REVOKED',
  FROZEN = 'FROZEN',
}

export type GatewayToken = {
  readonly issuingGatekeeper: string;
  readonly gatekeeperNetworkAddress: string;
  readonly owner: string;
  readonly state: State;
  readonly identifier: string;
  readonly expiryTime?: number;
};

export enum TokenState {
  REQUESTED = 'REQUESTED',
  ACTIVE = 'ACTIVE',
  REVOKED = 'REVOKED',
  FROZEN = 'FROZEN',
  REJECTED = 'REJECTED',
}

export enum ChainType {
  SOLANA = 'solana',
  ETHEREUM = 'ethereum',
  CASPER = 'casper',
  ICP = 'icp',
}

export interface ChainImplementationProps {
  network?: string;
  owner?: string;
  gatekeeperNetwork?: string;
  stage?: string;
}

export enum SignatureMethod {
  TRANSACTION,
  MESSAGE,
}

export type ProveWalletOwnershipResponse = {
  proof: string;
  signatureMethod: SignatureMethod;
};
type DIDMethod = string;
type DIDIdentifier = string;
// or string if that makes things easier
export type DID = `did:${DIDMethod}:${DIDIdentifier}`;

export type ChainEvent = 'TOKEN_CREATED' | 'TOKEN_CHANGED';
export type ChainDetails = {
  chainType: ChainType;
  chainNetwork: string;
};
export interface ChainClientInterface {
  on: (event: ChainEvent, listener: (GatewayToken: GatewayToken) => void) => this;
  findGatewayToken: () => Promise<GatewayToken | undefined>;
  proveWalletOwnership: (message?: string) => Promise<ProveWalletOwnershipResponse>;
  handleTransaction?: (partiallySignedTx: string, frontendPollingTimeoutSeconds?: number) => Promise<string>;
  // dids that own the passed-in address
  ownerDids: () => Promise<DID[]>;
  chainDetails: ChainDetails;
  // In some cases, chain listeners have to be explicitly de-registered, for example.
  onDestroy: () => Promise<void>;
  // Exposed so we can emit an analytics event if the page is closed with a tx still pending.
  pendingTransaction: string | undefined;
  signMessage?: (message: Uint8Array) => Promise<Uint8Array>;
}

export interface ChainLegacy {
  addOnGatewayTokenChangeListener: (
    gatewayToken: GatewayToken,
    tokenDidChange: (GatewayToken: GatewayToken) => void
  ) => Promise<number>;
  // optional because not all chains may support having a listener for a token that hasn't been created yet
  addOnGatewayTokenCreatedOrChangedListener?: (tokenChange: (GatewayToken: GatewayToken) => void) => number;
  removeOnGatewayTokenChangeListener: (listenerId: number) => void;
  findGatewayToken: () => Promise<GatewayToken | undefined>;
  proveWalletOwnership: (message?: string) => Promise<ProveWalletOwnershipResponse>;
  signMessage?: (message: Uint8Array) => Promise<Uint8Array>;
  handleUserSignedTransaction: (partiallySignedTx: string) => Promise<string>;
  did: string;
  httpConfig: GatekeeperHttpConfig;
  chainType: ChainType;
  chainNetwork: string;
  dAppHandlesTransactions: boolean;
  initProps: ChainImplementationProps;
  onDestroy: () => void; // used to trigger clean up when instance is being destroyed
}

import { step } from 'mocha-steps';
import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import chaiAsPromised from 'chai-as-promised';
import sinonChai from 'sinon-chai';
import { IntegrationTestHelpers, sleep } from '../testSupport';
import { GatekeeperAPIStatus } from '../../src/types/gatekeeperApi';

chai.use(sinonChai);
chai.use(chaiSubset);
chai.use(chaiAsPromised);

const sandbox = sinon.createSandbox();

/**
 * This tests the case where the user already finished data collection and made a request to the gatekeeper
 * however, for whatever reason, the transaction wasn't sent, so the data collection process needs to be resumed/restarted
 * and the request to the gatekeeper made again
 */
describe('GatewayClientCore issuance resume after the client has already requested integration tests', () => {
  let testHelpers: IntegrationTestHelpers;
  before(() => {
    testHelpers = new IntegrationTestHelpers(sandbox);
    testHelpers.stubSuccessfulFetchCalls();
    // override the gatekeeper GET response to indicate a requested token, allowing a fresh TX to be requested
    testHelpers.stubGetFetchCall({
      getResponsePayload: [GatekeeperAPIStatus.REQUESTED, { preApprovedTxAvailable: true }],
    });
    testHelpers.stubFreshTransactionPostFetchCall();
  });

  after(() => {
    testHelpers.cleanup();
    sandbox.restore();
  });

  afterEach(() => {
    testHelpers.expectFlowIdToBeSet('GWRC_issuance_');
  });

  step('1. expect the Gatekeeper client to successfully initialize', async () => {
    testHelpers.initializeGatewayCore();
    // wait for GK and on-chain checks to complete
    await sleep(110);
  });

  step('2. Expect gateway status to change to start new-transaction flow', async () => {
    await sleep(110);
    testHelpers.expectStartNewTx();
  });

  step('3. Expect successful civic-sign public-key, did and POWO flows', async () => {
    await testHelpers.expectSuccessfulCivicSignProofFlow();
  });

  step('4. Prepare a successfull client sending of transaction when presented to the user', async () => {
    testHelpers.prepareSuccessfulHandleTransaction();
  });

  step('5. Emit a civic-pass event to initiate the GK-API issuance request', async () => {
    await testHelpers.simulateIframeEventTriggeringFreshTransactionRequest();
  });

  step('6. The user should be presented with a screen to re-fetch the transaction', async () => {
    await sleep(120);
    testHelpers.expectClientSendsRequestNewTransaction();
  });

  step('7. Wait for the transaction to be returned and sent by the client', async () => {
    await sleep(200);
    await testHelpers.expectClientSendTransactionToBeSent();
  });

  step(
    '8. OnChain listener fires with active token and gateway status and gateway token are updated to active',
    async () => {
      await testHelpers.simulateActiveOnChainToken();
      testHelpers.expectActiveToken();
    }
  );
});

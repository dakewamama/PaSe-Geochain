import sinon from 'sinon';
import chai from 'chai';
import {
  GatekeeperClient,
  getGatekeeperEndpoint,
  isGkApiStatusFailure,
  isGkApiStatusRequestedRetriesExhausted,
} from '../src/gatekeeperClient';
import { GatekeeperAPIStatus, GatekeeperClientConfig, TokenRequest } from '../src/types/gatekeeperApi';
import chaiAsPromised from 'chai-as-promised';
import { ChainType } from '../src/types/chain';
import { AbortError } from 'node-fetch';

chai.use(chaiAsPromised);

const { expect } = chai;
const sandbox = sinon.createSandbox();

describe('GatekeeperClient', function () {
  let fetchStub: sinon.SinonStub<any[], any>;
  let client: GatekeeperClient;
  let abortController: AbortController;
  let walletAddress: string;

  afterEach(sandbox.restore);

  beforeEach(() => {
    // Setup the AbortController
    abortController = new AbortController();

    // Create a fetch stub
    fetchStub = sandbox.stub().returns(
      Promise.resolve({
        status: 200,
        json: () => Promise.resolve({ id: '123' }),
        clone: () => ({
          // Add a clone method that returns an object similar to the original response
          json: () => Promise.resolve({ id: '123' }),
        }),
      })
    );

    walletAddress = '0x123';

    // Configuration for the GatekeeperClient with the fetch stub
    const config: GatekeeperClientConfig = {
      abortController: abortController,
      baseUrl: 'https://api.example.com',
      fetchImplementation: fetchStub,
      numRetries: 3,
      walletAddress,
      stage: 'prod',
      chainType: ChainType.SOLANA,
    };

    // Initialize the GatekeeperClient with the stubbed fetch
    client = new GatekeeperClient(config);
  });

  describe('getGatekeeperEndpoint', () => {
    it('should return correct endpoint for stage "dev"', () => {
      expect(getGatekeeperEndpoint('dev', ChainType.SOLANA)).to.equal(
        'https://dev-gatekeeper-api.civic.com/v1/token/solana'
      );
    });
    it('should return correct endpoint for stage "preprod"', () => {
      expect(getGatekeeperEndpoint('preprod', ChainType.SOLANA)).to.equal(
        'https://preprod-gatekeeper-api.civic.com/v1/token/solana'
      );
    });
    it('should return correct endpoint for stage "prod"', () => {
      expect(getGatekeeperEndpoint('prod', ChainType.SOLANA)).to.equal(
        'https://gatekeeper-api.civic.com/v1/token/solana'
      );
    });
    it('should return "dev" endpoint for unknown stage', () => {
      expect(getGatekeeperEndpoint('unknown', ChainType.SOLANA)).to.equal(
        'https://dev-gatekeeper-api.civic.com/v1/token/solana'
      );
    });
  });

  describe('getGatekeeperRecordWithPayload', function () {
    it('should return null if the fetch call is aborted', async () => {
      fetchStub.rejects(new Error('AbortError'));
      return expect(client.getGatekeeperRecordWithPayload()).to.be.rejectedWith('AbortError');
    });

    it('should return gatekeeper record response if successful', async () => {
      fetchStub.resolves({
        status: 200,
        json: () => Promise.resolve({ id: '123' }),
        clone: () => ({ json: () => Promise.resolve({ id: '123' }) }), // Ensure `clone` is also stubbed
      });
      const result = await client.getGatekeeperRecordWithPayload();
      expect(result?.payload?.id).to.equal('123');
    });
  });

  describe('isGkApiStatusRequestedRetriesExhausted', () => {
    it('should return true if status is 429', () => {
      expect(isGkApiStatusRequestedRetriesExhausted(GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED)).to.be.true;
    });

    it('should return false if status is not 429', () => {
      expect(isGkApiStatusRequestedRetriesExhausted(200)).to.be.false;
    });
  });

  describe('isGkApiStatusFailure', () => {
    it('should return false if GK API status is REQUESTED', () => {
      expect(isGkApiStatusFailure(GatekeeperAPIStatus.REQUESTED)).to.be.false;
    });

    it('should return false if GK API status is RETRIES_EXHAUSTED', () => {
      expect(isGkApiStatusFailure(GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED)).to.be.false;
    });

    it('should return false if code is below 400', () => {
      expect(isGkApiStatusFailure(300)).to.be.false;
    });

    it('should return true if it is not REQUESTED, not RETRIES_EXHAUSTED and code is above 400', () => {
      expect(isGkApiStatusFailure(GatekeeperAPIStatus.REJECTED)).to.be.true;
    });
  });

  describe('abort', () => {
    it('it should call abort on the AbortController', () => {
      client.abort();
      expect(abortController.signal.aborted).to.be.true;
    });
  });

  // TODO: Add more tests to cover different scenarios like retries, error responses, etc.
  context('getGatekeeperStatus', () => {
    context('with a successful call', () => {
      it('should return the status', async () => {
        fetchStub.resolves({
          status: 200,
          json: () => Promise.resolve({ status: 200 }),
          clone: () => ({ json: () => Promise.resolve({ status: 200 }) }), // Ensure `clone` is also stubbed
        });
        const result = await client.getGatekeeperStatus();
        expect(result).to.equal(200);
      });

      it('with an AbortError should return SERVER_FAILURE', async () => {
        fetchStub.rejects(new AbortError('test'));
        const result = await client.getGatekeeperStatus();
        expect(result).to.equal(GatekeeperAPIStatus.SERVER_FAILURE);
      });

      it('with a non-abort error should throw the error', async () => {
        fetchStub.rejects(new Error('Some error'));
        return expect(client.getGatekeeperStatus()).to.be.rejectedWith('Some error');
      });
    });
  });

  context('requestGatewayTokenFromGatekeeper', () => {
    context('with a successful call', () => {
      it('should map the state from the gatekeeper response', async () => {
        fetchStub.resolves({
          status: 200,
          json: () => Promise.resolve({ status: 200 }),
          clone: () => ({ json: () => Promise.resolve({ status: 200 }) }), // Ensure `clone` is also stubbed
        });
        const result = await client.requestGatewayTokenFromGatekeeper({
          payload: { test: 'test' },
        });
        expect(result).to.deep.equal({
          status: 200,
          state: GatekeeperAPIStatus.ISSUED,
        });
      });
    });

    context('with an error response', () => {
      context('with an AbortError', () => {
        it('should return null', () => {
          fetchStub.rejects(new AbortError('Some error'));
          return expect(client.requestGatewayTokenFromGatekeeper({ payload: { test: 'test' } })).eventually.to.be.null;
        });
      });
      context('with a non-abort error', () => {
        it('should throw the error', () => {
          fetchStub.rejects(new Error('Some error'));
          return expect(client.requestGatewayTokenFromGatekeeper({ payload: { test: 'test' } })).to.be.rejectedWith(
            'Some error'
          );
        });
      });
    });
  });

  context('refreshToken', () => {
    let refreshTokenArgs: TokenRequest;
    beforeEach(() => {
      const payload = { test: 'test' };
      const proof = 'proof';
      const payer = 'payer';
      refreshTokenArgs = { payload, proof, payer };
    });
    it('should map the state from the gatekeeper response', async () => {
      fetchStub.resolves({
        status: 200,
        json: () => Promise.resolve({ status: 200 }),
        clone: () => ({ json: () => Promise.resolve({ status: 200 }) }), // Ensure `clone` is also stubbed
      });
      const result = await client.refreshToken(refreshTokenArgs);
      expect(result).to.deep.equal({
        status: 200,
        state: GatekeeperAPIStatus.ISSUED,
      });
    });

    context('with an error response', () => {
      context('with an AbortError', () => {
        it('should return null', () => {
          fetchStub.rejects(new AbortError('Some error'));
          return expect(client.refreshToken(refreshTokenArgs)).eventually.to.be.null;
        });
      });
      context('with a non-abort error', () => {
        it('should throw the error', () => {
          fetchStub.rejects(new Error('Some error'));
          return expect(client.refreshToken(refreshTokenArgs)).to.be.rejectedWith('Some error');
        });
      });
    });
  });

  describe('updateTransactionStatus', function () {
    const txId = 'tx123';
    const status = 'sent';

    it('should succeed with status 204', async () => {
      fetchStub.resolves({
        status: 204,
        json: () => Promise.resolve({}),
        clone: () => ({ json: () => Promise.resolve({}) }), // Ensure `clone` is also stubbed
      });

      await client.updateTransactionStatus(txId);

      expect(fetchStub.calledOnce).to.be.true;
      const fetchArgs = fetchStub.firstCall.args;
      expect(fetchArgs[0]).to.include(`${walletAddress}/transaction/${txId}`);
      expect(fetchArgs[1]).to.deep.include({
        method: 'PATCH',
        body: JSON.stringify({ status }),
      });
    });

    it('should handle AbortError and return null', async () => {
      fetchStub.rejects(new AbortError('Aborted'));

      const result = await client.updateTransactionStatus(txId);
      expect(result).to.be.null;
      expect(fetchStub.calledOnce).to.be.true;
    });

    it('should throw an error for non-204 status', async () => {
      fetchStub.rejects(new Error('Failed to update transaction status: Internal Server Error'));

      await expect(client.updateTransactionStatus(txId)).to.be.rejectedWith(
        'Failed to update transaction status: Internal Server Error'
      );

      expect(fetchStub.calledOnce).to.be.true;
    });
  });
});

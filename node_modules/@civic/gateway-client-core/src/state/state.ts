/**
 * the state manaer takes inputs from a variety of different sources and determines the current state of the application
 * based on those inputs. It then updates the gatewayStatus and flowParameters
 *
 * Inputs:
 *  UserFlowEvents: { start, abort }
 *  Config: { stage, walletAddress, gatekeeperNetwork, payer }
 *  CivicPass events (from iframe or potentially other sources in future): { fetchStatus: FetchStatus, event: CivicPassMessageResponse | null }
 *  GK-API Record events: { fetchStatus: FetchStatus, record: GatekeeperRecordResponse | null }
 *  On-Chain Token events: { fetchStatus: FetchStatus, token: GatewayToken | null }
 *
 * States:
 * initialisation: when data is being fetched from various sources: civicPass iframe, gk-api, on-chain
 *
 * -- Token does not exist states: nothing on-chain, nothing from gk-api, no validation in progress from civic-pass
 * tokenNotFound
 * issuanceValidationInProgress: the iframe indicates that the user has an existing flow they are completing
 * issuanceProofCollectionInProgress: user has initiated a proof collection flow: UserFlowEvents.start
 * issuanceProofCollectionComplete: the iframe has returned all the information needed for a gk-api request
 * issuanceProofCollectionError: an error occurred during the proof collection process
 *
 * -- Token exists states:
 * tokenActive
 * tokenExpired
 * tokenRevoked
 * refreshValidationInProgress: the iframe indicates that the user has an existing refresh flow they are completing
 * refreshProofCollectionInProgress: user has initiated a proof collection flow: UserFlowEvents.start
 * refreshProofCollectionComplete: the iframe has returned all the information needed for a gk-api request
 * refreshProofCollectionError: an error occurred during the proof collection process
 *
 * Outputs/Derived states:
 *  External gateway status
 *  Internal gateway status (more detailed subset of above)
 *  Flow parameters (params that can be passed to the iframe)
 */
import { createStore, Mutate, StateCreator, StoreApi } from 'zustand/vanilla';
import { immer } from 'zustand/middleware/immer';
import { DevtoolsOptions, subscribeWithSelector } from 'zustand/middleware';
import { devtools } from 'zustand/middleware';
import { computed, compute } from 'zustand-computed-state';
import { GatewayStatus } from '../types/gateway';
import { GatewayCoreState } from '../types/gatewayCore';
import { internalToOutputGatewayStatus } from './stateMapping';
import { flowStatusFromState } from '../utils/flow';
import { computeInternalStatus } from './gatewayStatus';
import { computeFlowParameters } from './flowParameters';
import { produce } from 'immer';
import { Draft } from 'immer';
import { getPendingRequestFromGatekeeperRecord } from '../utils/partnerReview';
import { computeUiState } from './ui';
import { UIOutput } from '../types/ui';
import { FlowStatus } from '../types/flow';

export type Store = Mutate<
  StoreApi<GatewayCoreState>,
  [['zustand/subscribeWithSelector', never], ['zustand/immer', never]]
>;

export type WritableDraft<T> = {
  -readonly [K in keyof T]: Draft<T[K]>;
};

// Define default states for internal and output states
const initialInternalState = {
  status: GatewayStatus.UNKNOWN,
  userInteraction: {
    status: null,
  },
  errors: {},
  ownerDids: [], // Dids will be queried using async chainImplementation.ownerDids() and updated here
  chainDetails: undefined,
};

export const initialOutputState = {
  flowParameters: undefined,
  flowState: {
    status: undefined,
    userInteraction: {
      status: null,
      count: 0,
    },
  },
  gatewayStatus: GatewayStatus.UNKNOWN,
  gatewayToken: undefined,
  gatewayTokenTransaction: undefined,
  pendingRequests: undefined,
  ui: undefined,
};

export const initialInputState = {
  civicSign: { status: null, received: null },
  civicPass: { status: null, received: null },
  gatewayToken: { status: null, received: null },
  gatekeeperRecord: { status: null, received: null },
  parameters: null,
  dynamicParameters: { forceRequireRefresh: false },
  gatekeeperNetworkData: { status: null, received: null },
};

const initialState = {
  inputs: initialInputState,
  internal: initialInternalState,
  output: initialOutputState,
};

// the business logic of how all the different inputs create the gateway status and outputs can go here
const computeState = (state: GatewayCoreState): Partial<GatewayCoreState> => {
  const computedInternalStatus = computeInternalStatus(state);
  const flowParameters = computeFlowParameters(state, computedInternalStatus) || undefined;
  const flowStatus = flowStatusFromState(state, computedInternalStatus);

  const ui = {
    ...state.output?.ui,
    ...computeUiState(state, flowStatus, flowParameters),
  };

  // If the token active screen should not be shown we set the status to null so it can be detected when flow status is re-computed
  // It will be reset when the user restarts a flow
  const computedUserInteractionStatus =
    [FlowStatus.RESULT, FlowStatus.FINISHED].includes(flowStatus as FlowStatus) &&
    state.inputs.gatekeeperNetworkData?.received?.client?.tokenActiveDisplay === 'hidden'
      ? null
      : state.internal.userInteraction.status;

  return {
    internal: {
      ...state.internal,
      status: computedInternalStatus,
      userInteraction: {
        ...state.internal.userInteraction,
        status: computedUserInteractionStatus,
      },
    },
    output: {
      ...state.output,
      ui: ui as UIOutput,
      flowParameters,
      flowState: {
        status: flowStatus,
        userInteraction: {
          ...state.internal.userInteraction,
          status: computedUserInteractionStatus,
        },
      },
      gatewayStatus: internalToOutputGatewayStatus(computedInternalStatus),
      gatewayToken: state.inputs.gatewayToken.received || undefined,
      gatewayTokenTransaction: state.inputs.gatekeeperRecord?.received?.transaction,
      pendingRequests: getPendingRequestFromGatekeeperRecord(state.inputs.gatekeeperRecord),
    },
  };
};

// Explicitly type the combined middleware
const combinedMiddleware = (options: DevtoolsOptions) => (config: StateCreator<GatewayCoreState>) =>
  subscribeWithSelector(computed(immer(devtools(config, options)))) as StateCreator<
    GatewayCoreState,
    [['zustand/subscribeWithSelector', never], ['zustand/immer', never]],
    [],
    GatewayCoreState
  >;
// Define the store creator with a helper function to correctly chain the middlewares
export const createGatewayCoreStore = (options: DevtoolsOptions): WritableDraft<Store> =>
  createStore<GatewayCoreState>(
    combinedMiddleware(options)((set, get) => ({
      ...initialState,
      functions: {
        reset: () =>
          set(
            produce((state) => {
              // Don't clear input parameters across resets
              state.inputs = {
                ...initialInputState,
                // don't override dynamic parameters
                dynamicParameters: state.inputs.dynamicParameters,
                parameters: state.inputs.parameters,
              };
              // Keep instanceId intact across resets as it's still the same store.
              state.internal = {
                ...initialInternalState,
                userInteraction: {
                  status: state.internal.userInteraction.status,
                },
                instanceId: state.internal.instanceId,
                ownerDids: [], // Dids will be queried using async chainImplementation.ownerDids() and updated here
                chainDetails: state.internal.chainDetails,
              };
              state.output = { ...initialOutputState, ui: state.output?.ui };
            })
          ),
      },
      ...compute(get, computeState),
    }))
  );

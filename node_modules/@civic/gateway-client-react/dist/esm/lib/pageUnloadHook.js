import { logger, sendOnCloseAnalyticsEvent } from '@civic/gateway-client-core';
import { useCallback, useEffect, useRef } from 'react';
export const usePageUnload = (flowParameters, coreInst) => {
    const pageCloseEventSentRef = useRef(false); // Prevents duplicate analytics events on page close.
    // Attaches a handler that fires when closing the tab, and sends an analytics event if a tx is currently pending in the chainImplementation.
    const useBeforeUnload = () => {
        // We detect 'page unload' in one of several ways, with fallback as follows:
        // 1. visibilitychange to 'hidden'. Most reliable but not implemented by all browsers.
        // 2. pagehide: Unreliable on mobile but supported on a wider range of browsers
        // 3. beforeunload: Unreliable on mobile but supported on a wider range of browsers
        // This is described under "Avoid unload and beforeunload" here: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon
        var _a, _b;
        const handler = useCallback(async () => {
            var _a, _b, _c, _d;
            if (!flowParameters) {
                logger.debug('No flowParameters. Cannot send analytics event.');
                return;
            }
            if (pageCloseEventSentRef.current) {
                logger.debug('Page close analytics event already sent. Not sending again.');
                return;
            }
            // The core will check for a pending tx on the chainImplementation, and emit an event with a BROWSER_CLOSED_WHILE_TRANSACTION_PENDING error code.
            if ((_b = (_a = coreInst === null || coreInst === void 0 ? void 0 : coreInst.inputs) === null || _a === void 0 ? void 0 : _a.chainImplementation) === null || _b === void 0 ? void 0 : _b.pendingTransaction) {
                logger.debug('Sending analytics event on page close.');
                pageCloseEventSentRef.current = true;
                await sendOnCloseAnalyticsEvent(flowParameters, (_d = (_c = coreInst === null || coreInst === void 0 ? void 0 : coreInst.inputs) === null || _c === void 0 ? void 0 : _c.chainImplementation) === null || _d === void 0 ? void 0 : _d.pendingTransaction, navigator.sendBeacon.bind(navigator));
            }
        }, [JSON.stringify(flowParameters), (_b = (_a = coreInst === null || coreInst === void 0 ? void 0 : coreInst.inputs) === null || _a === void 0 ? void 0 : _a.chainImplementation) === null || _b === void 0 ? void 0 : _b.pendingTransaction]);
        const visibilityStateCallback = useCallback(() => {
            if (document.visibilityState === 'hidden') {
                logger.debug('visibilitychange to hidden. Calling sendOnCloseAnalyticsEvent.');
                handler();
            }
        }, [handler]);
        const pageHideCallback = useCallback(() => {
            logger.debug('pagehide event fired. Calling abort on core.');
            handler();
        }, [handler]);
        const beforeUnloadCallback = useCallback(async (event) => {
            await handler();
            // eslint-disable-next-line no-param-reassign
            event.returnValue = ''; // Legacy method for cross-browser support
        }, [handler]);
        const removeAllListeners = useCallback(() => {
            logger.debug('Removing all page close listeners');
            window.removeEventListener('beforeunload', beforeUnloadCallback);
            window.removeEventListener('visibilitychange', visibilityStateCallback);
            window.removeEventListener('pagehide', pageHideCallback);
        }, [beforeUnloadCallback, visibilityStateCallback, pageHideCallback]);
        useEffect(() => {
            if (document.visibilityState) {
                logger.debug('Browser supports visibilitychange event. Registering listener for it (core).');
                document.addEventListener('visibilitychange', visibilityStateCallback);
                return removeAllListeners;
            }
            if ('onpagehide' in window) {
                logger.debug('Browser supports pagehide event. Registering listener for it.');
                window.addEventListener('pagehide', pageHideCallback);
                return removeAllListeners;
            }
            // If all else fails, use beforeunload
            logger.debug('Adding beforeunload listener');
            window.addEventListener('beforeunload', beforeUnloadCallback);
            // eslint-disable-next-line consistent-return
            return removeAllListeners;
        }, [handler, removeAllListeners]);
    };
    useBeforeUnload();
};

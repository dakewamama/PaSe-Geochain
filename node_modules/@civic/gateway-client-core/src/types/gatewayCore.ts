import { GknData } from '../../src/gatekeeperNetworkService';
import { ChainConfirmationTimeout, ChainError } from '../utils/errors';
import { ChainDetails, ChainType, GatewayToken } from './chain';
import { CivicPassMessageResponse } from './civicPass';
import { CivicSignEventTypeRequestMessage } from './civicSign';
import { InputStatus } from './fetch';
import { FlowStatus, FlowType } from './flow';
import { GatekeeperRecordResponse, PendingPayload } from './gatekeeperApi';
import { GatewayStatus, InternalGatewayStatus } from './gateway';
import { DynamicGatewayClientParameters, GatewayClientParameters } from './parameters';
import { UIInput, UIOutput } from './ui';
import { UserInteraction } from './userInteraction';

// a new generic type GatewayInput that assigns the generic type T to a payload and has a status property of type FetchStatus
export type GatewayInput<T, E = unknown, S = unknown> = {
  received: T | null;
  status: InputStatus | null;
  error?: E | Error | Record<string, unknown> | null;
  sent?: S;
};

export type FlowParameters = {
  redirectUrl?: string;
  networkAddress?: string;
  action?: string;
  wallet: string; // mandatory without default, should always be provided
  chain?: ChainType;
  chainNetwork?: string;
  ownerSigns: boolean;
  gatekeeperSendsTransaction: boolean;
  errorCode?: string;
  partnerAppId?: string;
  instanceId: string;
  signedTx?: string;
  flowId: string;
  did?: string;
  flowType?: FlowType;
  payload?: string;
  referrer?: string;
  domain?: string;
  hideWalletPrompts?: boolean;
  // Set to params.xCivicClientHeader if passed in, otherwise this package's (core) version from package.json.
  civicClient: string;
  stage?: string;
  gatewayStatus?: InternalGatewayStatus | null; // Helps when debugging null errorCodes in analytics events.
};

export type ClientCoreOutput = {
  gatewayStatus: GatewayStatus;
  gatewayToken?: GatewayToken;
  flowParameters?: FlowParameters; // Consider changing to `FlowParameters` if it should always be provided even when empty
  gatewayTokenTransaction?: string;
  pendingRequests?: PendingPayload;
  flowState?: {
    status?: FlowStatus;
    userInteraction: UserInteraction;
  };
  ui?: UIOutput;
};

export type ChainTransaction = {
  sentTxId?: string;
  error?: Error | ChainError;
  attempts?: number;
};

export type ClientCoreInternal = {
  status: InternalGatewayStatus | null;
  chainTransaction?: ChainTransaction;
  instanceId?: string;
  userInteraction: UserInteraction;
  refreshInterval?: any;
  errors: {
    expectedOnChainToken?: ChainConfirmationTimeout | null;
    expectedTokenGatekeeperRecord?: ChainError | null;
  };
  ownerDids: string[]; // Dids are queried via the chainImplementation using the async ownerDids() function.
  chainDetails?: ChainDetails;
};

export type ClientCoreInput = {
  civicSign: GatewayInput<CivicSignEventTypeRequestMessage, ChainError>;
  civicPass: GatewayInput<CivicPassMessageResponse>;
  gatewayToken: GatewayInput<GatewayToken>;
  gatekeeperRecord: GatewayInput<GatekeeperRecordResponse>;
  gatekeeperNetworkData: GatewayInput<GknData>;
  parameters: GatewayClientParameters | null;
  dynamicParameters?: DynamicGatewayClientParameters;
};

export interface GatewayCoreState {
  inputs: ClientCoreInput;
  internal: ClientCoreInternal;
  output?: ClientCoreOutput;
  functions: {
    reset: () => void;
  };
}

export interface GatewayClientCoreInterface {
  abort: () => void;
  instanceId: string;
  ui: UIInput;
}

export type Transition<T extends R[], R> = {
  nextState: T;
  compute?: (state: GatewayCoreState) => R;
};

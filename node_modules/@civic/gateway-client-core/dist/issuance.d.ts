import { GatekeeperClient } from './gatekeeperClient';
import { LoggingInterface } from './logger/provider.logger';
import { OrchestratorFlow } from './orchestratorFlow';
import { Store } from './state/state';
import { ChainClientInterface } from './types/chain';
import { CivicPassMessagePayload } from './types/civicPass';
import { GatewayCoreState } from './types/gatewayCore';
export declare class Issuance extends OrchestratorFlow {
    readonly gatewayCoreStore: Store;
    readonly chainImplementation: ChainClientInterface;
    readonly gatekeeperClient: GatekeeperClient;
    readonly abortController: AbortController;
    readonly expectTokenTimeoutSeconds: number;
    protected log: LoggingInterface;
    private timers;
    currentPayload: CivicPassMessagePayload;
    constructor(gatewayCoreStore: Store, chainImplementation: ChainClientInterface, gatekeeperClient: GatekeeperClient, abortController: AbortController, expectTokenTimeoutSeconds?: number);
    sendTransaction(): Promise<void>;
    gatekeeperRequest(payer: string | undefined, fullState: GatewayCoreState): Promise<import("./types/gatekeeperApi").RequestTokenIssuanceResponse | null>;
    freshTransactionGatekeeperRequest(payer: string | undefined): Promise<import("./types/gatekeeperApi").RequestTokenIssuanceResponse | null>;
    clearStateBeforeGatekeeperRequest(isFreshTransactionRequest?: boolean): void;
    makeGatekeeperRequest({ payer, isFreshTransactionRequest, }: {
        payer: string | undefined;
        isFreshTransactionRequest?: boolean;
    }): Promise<void>;
    retrieveFreshTransaction(payer: string | undefined): Promise<void>;
    statusHasValidToken(): boolean;
    expectOnChainToken(): void;
    abort(): void;
    abortExpectedTokenTimer(): void;
    onActiveTokenFound(): void;
    startRefreshCountdownTimer(): void;
    abortRefreshCountdownTimer(): void;
    restartDataCollection(): void;
}

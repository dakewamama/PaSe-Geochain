import sinon from 'sinon';
import chai from 'chai';
import { createGatewayCoreStore, Store } from '../src/state/state';
import { ChainType, GatekeeperClient } from '../src';
import { GatekeeperClientConfig } from '../src/types/gatekeeperApi';
import { OrchestratorFlow } from '../src/orchestratorFlow';

const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('Orchestrator Flow', () => {
  let gatewayCoreStore: Store;
  let abortController: AbortController;
  let gatekeeperClient: GatekeeperClient;
  let getStateStub: sinon.SinonStub<any[], any>;
  beforeEach(() => {
    abortController = new AbortController();
    gatewayCoreStore = createGatewayCoreStore({ name: 'test' });
    getStateStub = sinon.stub();
    gatewayCoreStore.getState = getStateStub;

    const config: GatekeeperClientConfig = {
      abortController: abortController,
      baseUrl: 'https://api.example.com',
      fetchImplementation: sandbox.stub(),
      numRetries: 3,
      walletAddress: '0x123',
      stage: 'prod',
      queryParams: { network: 'test_network', gatekeeperNetworkAddress: 'test_gatekeeperNetworkAddress' },
      chainType: ChainType.ETHEREUM,
    };

    // Initialize the GatekeeperClient with the stubbed fetch
    gatekeeperClient = new GatekeeperClient(config);
  });
  context('setGatekeeperClientFlowId', () => {
    let orchestratorFlow: OrchestratorFlow;
    beforeEach(() => {
      getStateStub.returns({ output: {} });
      orchestratorFlow = new OrchestratorFlow(gatewayCoreStore, gatekeeperClient, abortController);
    });
    context('with no flowId', () => {
      it('should throw an error', () => {
        expect(() => orchestratorFlow.setGatekeeperClientFlowId()).to.throw('Missing flowId');
      });
    });
  });
});

/* eslint-disable max-classes-per-file */
import * as R from 'ramda';
import { findGatewayToken, onGatewayTokenChange, onGatewayToken, removeAccountChangeListener, getGatewayTokenAddressForOwnerAndGatekeeperNetwork, } from '@civic/solana-gateway-ts';
import { PublicKey, SendTransactionError, } from '@solana/web3.js';
import { create, proveTransaction } from '@civic/prove-solana-wallet';
import { ChainType, State, ChainError, SignatureMethod, ErrorCode, prefixLogger, } from '@civic/gateway-client-core';
import { makeConfig } from './config';
import { TimeoutError, createSolanaTransactionFromBase64, parseTransactionErrorCode, raceWithTimeout, } from './util';
const logDebug = prefixLogger('SolanaChainImplementation').debug;
const logWarn = prefixLogger('SolanaChainImplementation').warn;
const isUnsupportedOperationError = (error) => { var _a; return error.code === -32603 || ((_a = error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('unsupportedoperation')); };
// How long we will give confirmTransaction to return before assuming it's been dropped.
// We show a retry screen after 30 seconds (product-level decision) so we can't wait longer than that.
const SOLANA_DROPPED_TX_TIMEOUT_MS = 25000;
const createSignMessageProofIfSupported = async (proveTransactionFn, proveSignMessageFn) => {
    try {
        if (!proveSignMessageFn) {
            logDebug('createSignMessageProofIfSupported no signMessageFn passed, using proveTransactionFn...');
            const proof = await proveTransactionFn();
            logDebug('createSignMessageProofIfSupported proveTransactionFn successful', {
                proof,
                signatureMethod: SignatureMethod.TRANSACTION,
            });
            return { proof, signatureMethod: SignatureMethod.TRANSACTION };
        }
        logDebug('createSignMessageProofIfSupported signMessageFn exists, calling proveSignMessageFn...');
        const proof = await proveSignMessageFn();
        logDebug('createSignMessageProofIfSupported proveSignMessageFn successful', {
            proof,
            signatureMethod: SignatureMethod.MESSAGE,
        });
        return { proof, signatureMethod: SignatureMethod.MESSAGE };
    }
    catch (error) {
        const useError = error;
        logWarn('createSignMessageProofIfSupported error', { error, useError });
        if (isUnsupportedOperationError(useError)) {
            logDebug('error is an unsupported operation error, trying proveTransaction');
            const proof = await proveTransactionFn();
            logDebug('createSignMessageProofIfSupported proveTransactionFn successful', {
                proof,
                signatureMethod: SignatureMethod.TRANSACTION,
            });
            return { proof, signatureMethod: SignatureMethod.TRANSACTION };
        }
        throw error;
    }
};
export class SolanaChainImplementation {
    constructor(inputs) {
        this.inputs = inputs;
        // We keep track of the listeners here, because they are registered in global state
        // of solana-gateway-ts and therefore should be removed when this object goes away.
        this.listeners = [];
        this.chainDetails = {
            chainType: ChainType.SOLANA,
            chainNetwork: inputs.cluster,
        };
    }
    async ownerDids() {
        return [`did:sol:${this.inputs.publicKey.toBase58()}`];
    }
    on(event, listener) {
        var _a;
        if (event === 'TOKEN_CREATED') {
            const newListener = onGatewayToken(this.inputs.connection, this.inputs.publicKey, this.inputs.gatekeeperNetworkAddress, (token) => {
                if (this.gatewayToken) {
                    // A token already existed before this callback fired.
                    // Don't call the TOKEN_CREATED listener. The TOKEN_CHANGED listener will be called in this case.
                    return;
                }
                this.gatewayToken = token;
                listener({
                    issuingGatekeeper: token.issuingGatekeeper.toBase58(),
                    gatekeeperNetworkAddress: token.gatekeeperNetwork.toBase58(),
                    owner: token.owner.toBase58(),
                    state: State[token.state],
                    identifier: token.publicKey.toBase58(),
                    expiryTime: token.expiryTime,
                });
            });
            this.listeners.push(newListener);
            return this;
        }
        if (event === 'TOKEN_CHANGED') {
            // If we don't have a gatewayToken yet, derive the token address from the wallet + gatekeeperNetwork combo.
            const gatewayTokenAddress = ((_a = this.gatewayToken) === null || _a === void 0 ? void 0 : _a.publicKey.toBase58()) ||
                getGatewayTokenAddressForOwnerAndGatekeeperNetwork(this.inputs.publicKey, this.inputs.gatekeeperNetworkAddress);
            const newListener = onGatewayTokenChange(this.inputs.connection, new PublicKey(gatewayTokenAddress), (token) => {
                listener({
                    issuingGatekeeper: token.issuingGatekeeper.toBase58(),
                    gatekeeperNetworkAddress: token.gatekeeperNetwork.toBase58(),
                    owner: token.owner.toBase58(),
                    state: State[token.state],
                    identifier: token.publicKey.toBase58(),
                    expiryTime: token.expiryTime,
                });
            });
            this.listeners.push(newListener);
            return this;
        }
        return this;
    }
    async findGatewayToken() {
        const { connection, publicKey, gatekeeperNetworkAddress } = this.inputs;
        const onChainToken = await findGatewayToken(connection, publicKey, new PublicKey(gatekeeperNetworkAddress), true);
        if (!onChainToken)
            return undefined;
        return {
            issuingGatekeeper: onChainToken.issuingGatekeeper.toBase58(),
            gatekeeperNetworkAddress: onChainToken.gatekeeperNetwork.toBase58(),
            owner: onChainToken.owner.toBase58(),
            state: State[onChainToken.state],
            identifier: onChainToken.publicKey.toBase58(),
            expiryTime: onChainToken.expiryTime,
        };
    }
    async proveWalletOwnership(message) {
        const { publicKey, signMessage, signTransaction, connection, cluster } = this.inputs;
        try {
            logDebug('proveWalletOwnership', { message });
            const proveSignMessageFn = signMessage && message ? () => create((input) => signMessage(Buffer.from(input)), message) : undefined;
            const proveTransactionFn = () => proveTransaction(publicKey, signTransaction, makeConfig(connection.rpcEndpoint, cluster)).then((proveTxResult) => proveTxResult.toString('base64'));
            const response = await createSignMessageProofIfSupported(proveTransactionFn, proveSignMessageFn);
            logDebug('proveWalletOwnership', response);
            return response;
        }
        catch (error) {
            const parsedError = error;
            logDebug('proveWalletOwnership', {
                error,
                errorMessage: parsedError.message,
                parsedErrorCode: parseTransactionErrorCode(parsedError),
                useErrorCode: ErrorCode.POWO_ERROR,
            });
            throw new ChainError(parsedError.message, ErrorCode.POWO_ERROR);
        }
    }
    async signMessage(message) {
        const { signMessage } = this.inputs;
        if (!signMessage) {
            throw new ChainError('signMessage not implemented');
        }
        return signMessage(message);
    }
    async handleTransaction(partiallySignedTx, frontendPollingTimeoutSeconds) {
        const { handleTransaction, signTransaction } = this.inputs;
        logDebug('handleUserSignedTransaction, user-provided handleTransaction', !!handleTransaction);
        const transaction = createSolanaTransactionFromBase64(partiallySignedTx);
        if (handleTransaction) {
            logDebug('custom handleTransaction function present, calling now...');
            return handleTransaction(transaction).catch((error) => {
                throw new ChainError(error.message, ErrorCode.CUSTOM_HANDLE_TRANSACTION_ERROR, prefixLogger('SolanaChainImplementation'));
            });
        }
        let transactionToSend = transaction;
        if (this.requiresSignature(transaction)) {
            transactionToSend = await signTransaction(transaction).catch((error) => {
                throw new ChainError(error.message, parseTransactionErrorCode(error), prefixLogger('SolanaChainImplementation'));
            });
        }
        const frontendPollingTimeoutMs = frontendPollingTimeoutSeconds
            ? frontendPollingTimeoutSeconds * 1000
            : SOLANA_DROPPED_TX_TIMEOUT_MS;
        return this.submitTransaction(transactionToSend, frontendPollingTimeoutMs).catch((error) => {
            if (error instanceof ChainError) {
                // submitTransaction threw a granular ChainError. Re-throw it.
                throw error;
            }
            // A different error was thrown from submitTransaction which we could not handle. Throw a generic SEND_TRANSACTION_ERROR
            throw new ChainError(error.message, ErrorCode.SEND_TRANSACTION_ERROR, prefixLogger('SolanaChainImplementation'));
        });
    }
    requiresSignature(transaction) {
        return transaction.signatures.find((sig) => sig.publicKey.equals(this.inputs.publicKey)) !== undefined;
    }
    // eslint-disable-next-line class-methods-use-this
    handleTxSendError(err) {
        // Tx failed to send. Try to parse a specific error like 'insufficient funds'. Otherwise just throw a generic SEND_TRANSACTION_ERROR.
        const parsedErrorCode = parseTransactionErrorCode(err);
        if (err instanceof SendTransactionError || parsedErrorCode !== ErrorCode.SIGN_TRANSACTION_UNKNOWN_ERROR) {
            throw new ChainError(err.message, parsedErrorCode, prefixLogger('SolanaChainImplementation'));
        }
        // Tx rejected by the RPC or simulation failed for an unknown reason.
        throw new ChainError(`sendRawTransaction failed ${err === null || err === void 0 ? void 0 : err.message}`, ErrorCode.SEND_TRANSACTION_ERROR, prefixLogger('SolanaChainImplementation'));
    }
    async handleTxConfirmError(txSig, confirmTxErr, frontendPollingTimeoutMs) {
        var _a;
        const { connection } = this.inputs;
        if (confirmTxErr instanceof ChainError) {
            // We already determined a granular error case for this.
            throw confirmTxErr;
        }
        if (confirmTxErr instanceof TimeoutError) {
            // confirmTransaction timed out. Check the tx status to see if it's been dropped.
            const sigStatusResponse = await connection.getSignatureStatuses([txSig]);
            const sigStatus = (_a = sigStatusResponse === null || sigStatusResponse === void 0 ? void 0 : sigStatusResponse.value) === null || _a === void 0 ? void 0 : _a[0];
            if (!sigStatus) {
                // The tx has been dropped.
                throw new ChainError(`confirmTransaction timed out after ${frontendPollingTimeoutMs} ms and tx not found on-chain`, ErrorCode.TRANSACTION_DROPPED_ERROR, prefixLogger('SolanaChainImplementation'));
            }
            // For some reason confirmTransaction timed out even though the tx was actually confirmed.
            if (sigStatus.err) {
                // Tx failed on-chain.
                throw new ChainError(`Transaction failed on-chain ${sigStatus.err.toString()}`, ErrorCode.TRANSACTION_FAILED_ON_CHAIN_ERROR, prefixLogger('SolanaChainImplementation'));
            }
            // Tx succeeded.
            return txSig;
        }
        // confirmTransaction threw a different error.
        throw new ChainError(`confirmTransaction threw an error: ${confirmTxErr === null || confirmTxErr === void 0 ? void 0 : confirmTxErr.message}`, ErrorCode.TRANSACTION_CONFIRMATION_UNKNOWN_ERROR, prefixLogger('SolanaChainImplementation'));
    }
    async submitTransaction(transaction, frontendPollingTimeoutMs) {
        const { connection } = this.inputs;
        let txSig = '';
        try {
            const serialized = transaction.serialize();
            txSig = await connection.sendRawTransaction(serialized);
            // Store the tx hash so we can emit it in an analytics event if the user closes the tab at this point.
            this.pendingTransaction = txSig;
        }
        catch (err) {
            this.pendingTransaction = undefined;
            this.handleTxSendError(err);
        }
        // override connection commitment as we will poll/listen for confirmation of the token being created/refreshed
        const blockhash = await connection.getLatestBlockhash('processed');
        try {
            const confirmationResponse = await raceWithTimeout(() => connection.confirmTransaction(Object.assign(Object.assign({}, blockhash), { signature: txSig }), 'processed'), frontendPollingTimeoutMs);
            this.pendingTransaction = undefined;
            if (confirmationResponse.value.err) {
                // Tx failed on-chain.
                throw new ChainError(`Transaction failed on-chain ${confirmationResponse.value.err.toString()}`, ErrorCode.TRANSACTION_FAILED_ON_CHAIN_ERROR, prefixLogger('SolanaChainImplementation'));
            }
            // Tx confirmed (reached 'processed' commitment).
            return txSig;
        }
        catch (confirmTxErr) {
            this.pendingTransaction = undefined;
            return this.handleTxConfirmError(txSig, confirmTxErr, frontendPollingTimeoutMs);
        }
    }
    async onDestroy() {
        const promises = this.listeners
            .filter(R.complement(R.isNil))
            .map((listener) => removeAccountChangeListener(this.inputs.connection, listener));
        await Promise.all(promises);
        this.listeners = [];
        this.pendingTransaction = undefined;
    }
}

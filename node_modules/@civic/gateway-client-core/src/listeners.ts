// A Class to register the different listeners we need to orchestrate the different parts of the gateway
// when a listener is registered, we set it up to update the appropriate part of the state
// which will then trigger state updates and orchestration, if required
import { prefixLogger } from './logger';
import { MessageEventInterface } from './types/eventInterface';
import { CivicPassMessageAction, CivicPassMessageEventResponse, CivicPassMessageResponse } from './types/civicPass';
import { LoggingInterface } from './logger/provider.logger';
import { CivicSignEventTypeRequest, CivicSignEventTypeRequestMessage } from './types/civicSign';
import { ChainClientInterface, GatewayToken } from './types/chain';

type ListenerHandler = (arg: unknown) => void;
export class ListenerManager {
  readonly messageListeners: Record<string, ListenerHandler> = {};

  constructor(
    readonly messageEventInterface: MessageEventInterface,
    readonly chainImplementation: ChainClientInterface,
    readonly instanceId: string,
    readonly log: LoggingInterface = prefixLogger('ListenerManager')
  ) {}

  registerCivicPassListener(onMessage: (data: CivicPassMessageResponse) => void) {
    const handler = (response: CivicPassMessageEventResponse) => {
      if (!response.data) {
        this.log.error('No data in response');
        return; // Exit if there is no data in the response
      }

      // Checking instanceId matching
      if (response.data?.instanceId !== this.instanceId) {
        if (response.data?.instanceId && response.data.source !== '@devtools-page') {
          this.log.debug('instanceId for different instance', { event: response.data, instanceId: this.instanceId });
        }
        return;
      }
      // ensure we only process civic-pass events
      if (!Object.values(CivicPassMessageAction).includes(response.data.action)) {
        return;
      }
      this.log.debug('received CivicPassListener postMessage', response.data);
      onMessage(response.data);
    };

    this.log.debug('Adding event listener for civic-pass events');
    this.messageEventInterface.addMessageEventListener(handler);
    this.messageListeners.civicPass = handler;
  }

  registerCivicSignListener(onMessage: (data: CivicSignEventTypeRequestMessage) => void) {
    const handler = (response: MessageEvent<CivicSignEventTypeRequestMessage>) => {
      if (!response.data) {
        this.log.error('No data in response');
        return; // Exit if there is no data in the response
      }

      // Checking instanceId matching
      if (response.data?.instanceId !== this.instanceId) {
        if (response.data?.instanceId && response.data.source !== '@devtools-page') {
          this.log.debug('instanceId for different instance', { event: response.data, instanceId: this.instanceId });
        }
        return;
      }
      // ensure we only process civic-sign events
      if (!Object.values(CivicSignEventTypeRequest).includes(response.data.request)) {
        return;
      }

      this.log.debug('received CivicSignListener postMessage', response.data);
      onMessage(response.data);
    };

    this.log.debug('Adding event listener for civic-sign events');
    this.messageEventInterface.addMessageEventListener(handler);
    this.messageListeners.civicSign = handler;
  }

  registerOnChainListeners(onTokenChange: (gatewayToken: GatewayToken) => void) {
    this.chainImplementation.on('TOKEN_CREATED', onTokenChange);
    this.chainImplementation.on('TOKEN_CHANGED', onTokenChange);
  }

  unregisterAllListeners() {
    Object.entries(this.messageListeners).forEach(([key, handler]) => {
      this.log.debug('Removing message event listener', key);
      this.messageEventInterface.removeMessageEventListener(handler);
      delete this.messageListeners[key];
    });
  }
}

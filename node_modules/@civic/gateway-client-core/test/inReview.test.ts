import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import { Store } from '../src/state/state';
import { GatekeeperAPIStatus, GatekeeperClientConfig } from '../src/types/gatekeeperApi';
import { GatekeeperClient } from '../src/gatekeeperClient';
import { PartnerReview } from '../src/partnerReview';
import { ChainType } from '../src/types/chain';
import { IntegrationTestHelpers } from './testSupport';

chai.use(chaiSubset);
const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('partnerReview tests', () => {
  let fetchImplementationStub: any;

  let gatewayCoreStore: Store;

  let abortController: AbortController;
  let gatekeeperClient: GatekeeperClient;
  let partnerReview: PartnerReview;
  let testHelpers: IntegrationTestHelpers;

  afterEach(() => {
    sandbox.restore();
    partnerReview?.abort();
  });

  beforeEach(() => {
    abortController = new AbortController();
    testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
    gatewayCoreStore = testHelpers.getInitializedStore();
    fetchImplementationStub = sandbox.stub();

    const config: GatekeeperClientConfig = {
      abortController: abortController,
      baseUrl: 'https://api.example.com',
      fetchImplementation: fetchImplementationStub,
      numRetries: 3,
      walletAddress: '0x123',
      stage: 'prod',
      queryParams: { network: 'test_network', gatekeeperNetworkAddress: 'test_gatekeeperNetworkAddress' },
      chainType: ChainType.SOLANA,
    };

    // Initialize the GatekeeperClient with the stubbed fetch
    gatekeeperClient = new GatekeeperClient(config);
    gatekeeperClient.requestGatewayTokenFromGatekeeper = sandbox.stub();
  });

  context('pollForReviewFinished', () => {
    context('when the gatekeeper call returns a record with state not REQUESTED', () => {
      it('should call getGatekeeperRecordWithPayload and update the store', async () => {
        // Arrange
        const getGatekeeperRecordWithPayloadStub = sandbox
          .stub(gatekeeperClient, 'getGatekeeperRecordWithPayload')
          .resolves({
            state: GatekeeperAPIStatus.ISSUED,
          });
        partnerReview = new PartnerReview(gatewayCoreStore, gatekeeperClient, abortController);

        // Act
        await partnerReview.pollForReviewFinished();

        // Assert
        expect(getGatekeeperRecordWithPayloadStub.called).to.be.true;
        const fullState = gatewayCoreStore.getState();
        expect(fullState.inputs.gatekeeperRecord.status).to.equal('COMPLETE');
        expect(fullState.inputs.gatekeeperRecord.received).to.containSubset({ state: GatekeeperAPIStatus.ISSUED });
      });
    });

    context('when the gatekeeper call returns a record with state is REQUESTED', () => {
      it('should call getGatekeeperRecordWithPayload but not update the store', async () => {
        // Arrange
        const getGatekeeperRecordWithPayloadStub = sandbox
          .stub(gatekeeperClient, 'getGatekeeperRecordWithPayload')
          .resolves({
            state: GatekeeperAPIStatus.REQUESTED,
          });
        partnerReview = new PartnerReview(gatewayCoreStore, gatekeeperClient, abortController);

        // Act
        await partnerReview.pollForReviewFinished();

        // Assert
        expect(getGatekeeperRecordWithPayloadStub.called).to.be.true;
        const fullState = gatewayCoreStore.getState();
        expect(fullState.inputs.gatekeeperRecord.status).to.equal(null);
        expect(fullState.inputs.gatekeeperRecord.received).to.equal(null);
      });
    });

    context('when the gatekeeper call is initially REQUESTED and then changes to ISSUED', () => {
      beforeEach(() => {
        sandbox.useFakeTimers();
      });
      it('should call getGatekeeperRecordWithPayload and update the store', async () => {
        // Arrange
        const getGatekeeperRecordWithPayloadStub = sandbox.stub(gatekeeperClient, 'getGatekeeperRecordWithPayload');
        getGatekeeperRecordWithPayloadStub.onFirstCall().resolves({
          state: GatekeeperAPIStatus.REQUESTED,
        });
        getGatekeeperRecordWithPayloadStub.onSecondCall().resolves({
          state: GatekeeperAPIStatus.ISSUED,
        });
        partnerReview = new PartnerReview(gatewayCoreStore, gatekeeperClient, abortController);

        // Act
        const promise = partnerReview.pollForReviewFinished();
        sandbox.clock.tick(3000); // the polling is set to 2000ms
        await promise;

        // Assert
        expect(getGatekeeperRecordWithPayloadStub.calledTwice).to.be.true;
        const fullState = gatewayCoreStore.getState();
        expect(fullState.inputs.gatekeeperRecord.status).to.equal('COMPLETE');
        expect(fullState.inputs.gatekeeperRecord.received).to.containSubset({ state: GatekeeperAPIStatus.ISSUED });
      });
    });
  });
});

import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import { createGatewayCoreStore, Store } from '../src/state/state';
import { GatekeeperAPIStatus, GatekeeperClientConfig } from '../src/types/gatekeeperApi';
import { GatekeeperClient } from '../src/gatekeeperClient';
import { ChainClientInterface, ChainType, ExtendedGatewayStatus, GatewayCoreState } from '../src';
import { Refresh } from '../src/refresh';
import * as expiryUtils from '../src/utils/expiry';
import { calculateFromRefreshInReview } from '../src/state/refresh';
import { InputStatus } from '../src/types/fetch';

chai.use(chaiSubset);
const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('refresh tests', () => {
  let fetchImplementationStub: any;

  let gatewayCoreStore: Store;

  let abortController: AbortController;
  let gatekeeperClient: GatekeeperClient;
  let chainImplementation: ChainClientInterface;
  let setStateStub: sinon.SinonStub<any[], any>;
  let getStateStub: sinon.SinonStub<any[], any>;
  let isTokenRefreshRequiredStub: sinon.SinonStub<any[], any>;
  let refresh: Refresh;

  afterEach(() => {
    sandbox.restore();
    refresh?.abort();
  });

  afterEach(sandbox.restore);

  beforeEach(() => {
    abortController = new AbortController();

    gatewayCoreStore = createGatewayCoreStore({ name: 'test' });
    setStateStub = sinon.stub();
    getStateStub = sinon.stub();
    gatewayCoreStore.setState = setStateStub;
    gatewayCoreStore.getState = getStateStub;

    isTokenRefreshRequiredStub = sandbox.stub(expiryUtils, 'isTokenRefreshRequired');

    fetchImplementationStub = sandbox.stub();

    const config: GatekeeperClientConfig = {
      abortController: abortController,
      baseUrl: 'https://api.example.com',
      fetchImplementation: fetchImplementationStub,
      numRetries: 3,
      walletAddress: '0x123',
      stage: 'prod',
      queryParams: { network: 'test_network', gatekeeperNetworkAddress: 'test_gatekeeperNetworkAddress' },
      chainType: ChainType.ETHEREUM,
    };

    chainImplementation = {
      httpConfig: {
        baseUrl: 'https://example.com',
        queryParams: {
          network: '0x123',
        },
        headers: {},
      },
    } as unknown as ChainClientInterface;

    // Initialize the GatekeeperClient with the stubbed fetch
    gatekeeperClient = new GatekeeperClient(config);
    gatekeeperClient.refreshToken = sandbox.stub();
    gatekeeperClient.updateTransactionStatus = sandbox.stub().resolves();
  });

  context('clearStateBeforeGatekeeperRequest', () => {
    it('should set state with initial values', async () => {
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      refresh.clearStateBeforeGatekeeperRequest();
      expect(setStateStub.callCount).to.eq(1);
    });
  });

  context('gatekeeperRequest', () => {
    it('should throw an error if there is no civicPass received data', async () => {
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: undefined,
          },
        },
      } as unknown as GatewayCoreState;
      return expect(refresh.gatekeeperRequest('payer', state)).to.be.rejectedWith('Missing civicPass payload');
    });

    it('should throw an error if there is no civicPass input payload', async () => {
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: {
              payload: undefined,
            },
          },
        },
      } as GatewayCoreState;
      return expect(refresh.gatekeeperRequest('payer', state)).to.be.rejectedWith('Missing civicPass payload');
    });

    it('should call refreshToken with the correct parameters', async () => {
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: {
              payload: { test: true },
            },
          },
        },
      } as unknown as GatewayCoreState;
      await refresh.gatekeeperRequest('payer', state);
      expect(gatekeeperClient.refreshToken).to.have.been.calledOnceWith({
        payload: { test: true },
        payer: 'payer',
      });
    });
  });

  context('statusHasValidToken', () => {
    it('should return false if there is no token with expiryTime in state', () => {
      getStateStub.returns({
        inputs: {
          gatewayToken: {
            received: {
              expiryTime: undefined,
            },
          },
        },
      });
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const status = refresh.statusHasValidToken();
      expect(getStateStub).to.have.been.calledOnce;
      expect(status).to.be.false;
    });

    it('should return true if gatewayToken is valid and isTokenRefreshRequired returns false', () => {
      isTokenRefreshRequiredStub.returns(false);
      getStateStub.returns({
        inputs: {
          gatewayToken: {
            received: {
              expiryTime: 12345678,
            },
          },
        },
      });
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const status = refresh.statusHasValidToken();
      expect(getStateStub).to.have.been.calledOnce;
      expect(status).to.be.true;
    });

    it('should return false if isTokenRefreshRequired returns true', () => {
      isTokenRefreshRequiredStub.returns(true);
      getStateStub.returns({
        inputs: {
          gatewayToken: {
            received: {
              expiryTime: 12345678,
            },
          },
        },
      });
      refresh = new Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const status = refresh.statusHasValidToken();
      expect(getStateStub).to.have.been.calledOnce;
      expect(status).to.be.false;
    });
  });

  context('calculateFromRefreshInReview', () => {
    context('with a payer', () => {
      context('with a gatekeeperRecord complete with no transaction', () => {
        it('should return undefined', () => {
          const state = {
            inputs: {
              parameters: {
                payer: 'test-payer',
                wallet: {
                  address: 'a-different-address',
                },
              },
              gatekeeperRecord: {
                status: InputStatus.COMPLETE,
                received: {
                  transaction: undefined,
                },
              },
            },
          } as GatewayCoreState;
          const result = calculateFromRefreshInReview(state);
          expect(result).to.equal(undefined);
        });
      });

      context('with a gatekeeperRecord complete with a transaction', () => {
        context('with a payer different from the wallet owner', () => {
          it('should return REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                  wallet: {
                    address: 'a-different-address',
                  },
                },
                gatekeeperRecord: {
                  status: InputStatus.COMPLETE,
                  received: {
                    transaction: 'test-transaction',
                  },
                },
              },
            } as GatewayCoreState;
            const result = calculateFromRefreshInReview(state);
            expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND);
          });
        });

        context('with a payer equal to the wallet owner', () => {
          it('should return REFRESH_AWAITING_TRANSACTION_SEND', () => {
            const state = {
              inputs: {
                parameters: {
                  payer: 'test-payer',
                  wallet: {
                    address: 'test-payer',
                  },
                },
                gatekeeperRecord: {
                  status: InputStatus.COMPLETE,
                  received: {
                    transaction: 'test-transaction',
                  },
                },
              },
            } as unknown as GatewayCoreState;
            const result = calculateFromRefreshInReview(state);
            expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND);
          });
        });
      });

      context('with a chainTransaction sentTxId', () => {
        it('should return REFRESH_AWAITING_ON_CHAIN_TOKEN', () => {
          const state = {
            inputs: {
              parameters: {
                payer: 'test-payer',
              },
            },
            internal: {
              chainTransaction: {
                sentTxId: 'test-tx-id',
              },
            },
          } as GatewayCoreState;
          const result = calculateFromRefreshInReview(state);
          expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN);
        });

        it('should patch the txId', async () => {
          const handleTransactionStub = sandbox.stub().resolves('txId');
          chainImplementation = {
            httpConfig: {
              baseUrl: 'https://example.com',
              queryParams: {
                network: '0x123',
              },
              headers: {},
            },
            handleTransaction: handleTransactionStub,
          } as unknown as ChainClientInterface;
          const store = createGatewayCoreStore({ name: 'test' });
          store.setState((draft) => {
            draft.inputs.gatekeeperRecord = {
              status: InputStatus.COMPLETE,
              received: {
                state: GatekeeperAPIStatus.REQUESTED,
                transaction: 'test_transaction',
              },
            };
          });
          refresh = new Refresh(store, chainImplementation, gatekeeperClient, abortController);
          await refresh.sendTransaction();
          expect(gatekeeperClient.updateTransactionStatus).to.have.been.calledOnceWith('txId');
        });
      });

      context('with a chainTransaction error', () => {
        it('should return CHAIN_TRANSACTION_ERROR', () => {
          const state = {
            inputs: {
              parameters: {
                payer: 'test-payer',
              },
            },
            internal: {
              chainTransaction: {
                error: 'test-error',
              },
            },
          } as unknown as GatewayCoreState;
          const result = calculateFromRefreshInReview(state);
          expect(result).to.equal(ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR);
        });
      });
    });

    context('with no payer set', () => {
      it('should return REFRESH_AWAITING_ON_CHAIN_TOKEN', () => {
        const state = {
          inputs: {
            parameters: {},
          },
        } as GatewayCoreState;
        const result = calculateFromRefreshInReview(state);
        expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN);
      });
    });
  });
});

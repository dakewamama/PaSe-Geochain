import { GatekeeperClient } from './gatekeeperClient';
import { prefixLogger } from './logger';
import { LoggingInterface } from './logger/provider.logger';
import { OrchestratorFlow } from './orchestratorFlow';
import { Store } from './state/state';
import { InputStatus } from './types/fetch';
import { GatekeeperAPIStatus, GatekeeperRecordResponse } from './types/gatekeeperApi';

export class PartnerReview extends OrchestratorFlow {
  protected log: LoggingInterface;

  private timers: Partial<Record<'pollForReviewFinishedTimer', any>> = {};

  constructor(
    readonly gatewayCoreStore: Store,
    readonly gatekeeperClient: GatekeeperClient,
    readonly abortController: AbortController,
    readonly pollingIntervalSeconds: number = 2
  ) {
    super(gatewayCoreStore, gatekeeperClient, abortController);
    this.log = prefixLogger('PartnerReview instance');
  }

  /**
   * Call the gatekeeper to get the latest record and check if it's changed from REQUESTED,
   * once it changes, update the gatekeeerRecord state and let the orchestration logic finish
   */
  async pollForReviewFinished() {
    this.setGatekeeperClientFlowId();
    const callGatekeeperForReviewFinished = async () => {
      if (this.abortController?.signal.aborted) {
        clearInterval(this.timers.pollForReviewFinishedTimer);
        return;
      }
      this.gatekeeperClient.getGatekeeperRecordWithPayload().then((record: GatekeeperRecordResponse) => {
        if (!record || record?.state === undefined || record?.state === GatekeeperAPIStatus.SERVER_FAILURE) {
          this.log.error('Error polling gatekeeper, no state returned', record);
          clearInterval(this.timers.pollForReviewFinishedTimer);
          throw new Error('Error polling gatekeeper, no state returned');
        }
        this.log.debug('pollUntilNotRequested record.state', record.state);
        if (record.state !== GatekeeperAPIStatus.REQUESTED) {
          this.gatewayCoreStore.setState((state) => {
            state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
            state.inputs.gatekeeperRecord.received = record;
          });
          clearInterval(this.timers.pollForReviewFinishedTimer);
        }
      });
    };
    callGatekeeperForReviewFinished();
    this.timers.pollForReviewFinishedTimer = setInterval(
      callGatekeeperForReviewFinished,
      this.pollingIntervalSeconds * 1000
    );
  }

  abort() {
    clearInterval(this.timers.pollForReviewFinishedTimer);
  }
}

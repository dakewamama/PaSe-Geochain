import { GatewayCoreState, GatewayInput } from '../types/gatewayCore';
import { ExtendedGatewayStatus, GatewayStatus, InternalGatewayStatus } from '../types/gateway';
import { ChainConfirmationTimeout, ErrorCode } from '../utils/errors';
import {
  statusIfGatekeeperRecordRejected,
  statusFromGatewayTokenIfExists,
  validationProcessToGatewayStatus,
  payerIsWalletOwner,
  GatewayTokenCheckType,
  StatusIfGatekeeperRecordRejectedType,
  ValidationGatewayStatusType,
  CheckValidationStatusType,
} from './common';
import { InputStatus } from '../types/fetch';
import {
  CivicPassMessageAction,
  CivicPassMessageEventResult,
  CivicPassMessageResponse,
  ValidationStatus,
} from '../types/civicPass';
import { GatekeeperAPIStatus, GatekeeperRecordResponse } from '../types/gatekeeperApi';
import { getPendingRequestFromGatekeeperRecord } from '../utils/partnerReview';

// we're waiting on a civic pass to provide us with a payload to send to the gatekeeper
// when we get the issuance payload, then return ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
export const calculateIssuanceStartPreApprovedTransaction = (
  state: GatewayCoreState
):
  | ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
  | ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX
  | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  if (
    civicPassEvent?.action === CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS &&
    civicPassEvent?.payload !== undefined
  ) {
    return payerIsWalletOwner(state)
      ? ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
      : ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
  }
};

// Civic pass emits a data-collection status event for longer-running data-collection processes
// to give more granular data-collection status updates
export const hasExistingDataCollectionProcessInProgress = (civicPassEvent: CivicPassMessageResponse | null): boolean =>
  (civicPassEvent?.action === CivicPassMessageAction.STATUS &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS &&
    civicPassEvent.payload?.status !== ValidationStatus.NOT_FOUND) ||
  (civicPassEvent?.action === CivicPassMessageAction.ISSUANCE &&
    civicPassEvent?.event === CivicPassMessageEventResult.IN_PROGRESS);

export const isInPartnerReview = (gatekeeperRecord: GatewayInput<GatekeeperRecordResponse> | undefined): boolean => {
  return !!getPendingRequestFromGatekeeperRecord(gatekeeperRecord);
};

export const preApprovedTxAvailable = (
  gatekeeperRecord: GatewayInput<GatekeeperRecordResponse> | undefined
): boolean => {
  return !!gatekeeperRecord?.received?.payload?.preApprovedTxAvailable;
};

export type CalculateFromIssuanceAwaitingOnChainReturn = ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR;
export const calculateFromIssuanceAwaitingOnChain = (
  state: GatewayCoreState
): CalculateFromIssuanceAwaitingOnChainReturn | undefined => {
  if (
    (state.internal.errors?.expectedOnChainToken as ChainConfirmationTimeout)?.errorCode ===
    ErrorCode.CHAIN_CONFIRMATION_TIMEOUT_ERROR
  ) {
    return ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR;
  }
};

export type CalculateFromIssuanceInReviewReturn = InternalGatewayStatus;

export const calculateFromIssuanceInReview = (
  state: GatewayCoreState
): CalculateFromIssuanceInReviewReturn | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  const gatekeeperRecord = state.inputs.gatekeeperRecord;

  if (gatekeeperRecord?.status === InputStatus.IN_PROGRESS) {
    return state.internal.status as InternalGatewayStatus;
  }
  if (isInPartnerReview(gatekeeperRecord)) {
    return ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW;
  }

  if (state.inputs.parameters?.payer) {
    // this is the case where we're restarting a flow and we need a new transaction, so we need to check if we have proof
    // otherwise restart the flow
    if (
      gatekeeperRecord?.status === InputStatus.COMPLETE &&
      civicPassEvent?.action !== CivicPassMessageAction.ISSUANCE &&
      !gatekeeperRecord.received?.transaction
    ) {
      return ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION;
    }
    if (state.internal?.chainTransaction?.sentTxId) {
      return ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
    }
    if (state.internal?.chainTransaction?.error) {
      return ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR;
    }
    if (gatekeeperRecord.received?.transaction) {
      if (payerIsWalletOwner(state)) {
        return ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND;
      }
      return ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
    }
    return undefined;
  }
  // civic-sends case
  return ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
};

export type CalculateFromGatekeeperIssuanceRequestedReturn =
  | ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED
  | GatewayStatus.IN_REVIEW;
export const calculateFromGatekeeperIssuanceRequested = (
  state: GatewayCoreState
): CalculateFromGatekeeperIssuanceRequestedReturn | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  const gatekeeperRecord = state.inputs.gatekeeperRecord;
  // post-gatekeeper-issuance request
  if (
    civicPassEvent && // we need a civic pass event to know data collection is complete
    (gatekeeperRecord?.received?.state === GatekeeperAPIStatus.REQUESTED ||
      gatekeeperRecord?.status === InputStatus.IN_PROGRESS)
  ) {
    return state.inputs.parameters?.payer && payerIsWalletOwner(state)
      ? ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED
      : GatewayStatus.IN_REVIEW;
  }
};

export type CalculateIssuanceRequestedDataCollectionRestartReturn =
  | ExtendedGatewayStatus.RESTART
  | InternalGatewayStatus
  | GatewayStatus.USER_INFORMATION_VALIDATED
  | GatewayStatus.COLLECTING_USER_INFORMATION;
export const calculateIssuanceRequestedDataCollectionRestart = (
  state: GatewayCoreState
): CalculateIssuanceRequestedDataCollectionRestartReturn | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  // handle the case where the user has an expired validation process
  // TODO check the action when the iframe is updated to send the correct action
  if (civicPassEvent?.event === CivicPassMessageEventResult.FAILURE) {
    return ExtendedGatewayStatus.USER_VALIDATION_FAILED;
  }
  const gatewayStatusFromValidationProcess =
    validationProcessToGatewayStatus[civicPassEvent?.payload?.status as CheckValidationStatusType];
  if (
    civicPassEvent?.action === CivicPassMessageAction.STATUS &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS &&
    gatewayStatusFromValidationProcess
  ) {
    // check that we have a payload before returning USER_INFORMATION_VALIDATED
    // otherwise restart the flow by returning NOT_REQUESTED
    if (gatewayStatusFromValidationProcess === GatewayStatus.USER_INFORMATION_VALIDATED) {
      return civicPassEvent.payload ? GatewayStatus.USER_INFORMATION_VALIDATED : GatewayStatus.NOT_REQUESTED;
    }
    return gatewayStatusFromValidationProcess;
  }
  if (
    civicPassEvent?.action === CivicPassMessageAction.ISSUANCE &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS
  ) {
    return GatewayStatus.USER_INFORMATION_VALIDATED;
  }
  if (hasExistingDataCollectionProcessInProgress(civicPassEvent)) {
    return gatewayStatusFromValidationProcess || GatewayStatus.COLLECTING_USER_INFORMATION;
  }
};

export type ComputeIssuanceDataCollectionRestartType =
  | GatewayTokenCheckType
  | CalculateIssuanceRequestedDataCollectionRestartReturn;
export const computeIssuanceDataCollectionRestart = (
  state: GatewayCoreState
): ComputeIssuanceDataCollectionRestartType =>
  statusFromGatewayTokenIfExists(state) ||
  calculateIssuanceRequestedDataCollectionRestart(state) ||
  (state.internal?.status as ComputeIssuanceDataCollectionRestartType);

export type ComputeIssuanceRequestedType = GatewayTokenCheckType | CalculateFromGatekeeperIssuanceRequestedReturn;
export const computeIssuanceRequested = (state: GatewayCoreState): ComputeIssuanceRequestedType =>
  statusFromGatewayTokenIfExists(state) ||
  calculateFromGatekeeperIssuanceRequested(state) ||
  (state.internal?.status as ComputeIssuanceRequestedType);

export const computeIssuanceAwaitingOnChainToken = (
  state: GatewayCoreState
): GatewayTokenCheckType | CalculateFromIssuanceAwaitingOnChainReturn =>
  statusFromGatewayTokenIfExists(state) ||
  calculateFromIssuanceAwaitingOnChain(state) ||
  (state.internal?.status as GatewayTokenCheckType | CalculateFromIssuanceAwaitingOnChainReturn);

export type ComputeIssuanceInReviewType =
  | GatewayTokenCheckType
  | StatusIfGatekeeperRecordRejectedType
  | CalculateFromIssuanceInReviewReturn;

export const computeIssuanceInReview = (state: GatewayCoreState): ComputeIssuanceInReviewType =>
  statusFromGatewayTokenIfExists(state) ||
  statusIfGatekeeperRecordRejected(state) ||
  calculateFromIssuanceInReview(state) ||
  (state.internal?.status as ComputeIssuanceInReviewType);

export type CalculateIssuanceStatusReturn = ValidationGatewayStatusType | InternalGatewayStatus;

export const calculateIssuanceStatus = (state: GatewayCoreState): CalculateIssuanceStatusReturn | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  const gatekeeperRecord = state.inputs.gatekeeperRecord;

  if (civicPassEvent?.event === CivicPassMessageEventResult.FAILURE) {
    return ExtendedGatewayStatus.USER_VALIDATION_FAILED;
  }

  if (
    civicPassEvent?.action === CivicPassMessageAction.ISSUANCE &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS
  ) {
    return GatewayStatus.USER_INFORMATION_VALIDATED;
  }

  // pre-gatekeeper-issuance request
  if (!gatekeeperRecord?.received || gatekeeperRecord?.received?.state === GatekeeperAPIStatus.NOT_REQUESTED) {
    if (hasExistingDataCollectionProcessInProgress(civicPassEvent)) {
      const gatewayStatusFromValidationProcess =
        validationProcessToGatewayStatus[civicPassEvent?.payload?.status as CheckValidationStatusType];

      // we don't currently support jumping to issuance if the data collection is still in progress
      if (gatewayStatusFromValidationProcess === GatewayStatus.USER_INFORMATION_VALIDATED) {
        return GatewayStatus.NOT_REQUESTED;
      }
      return gatewayStatusFromValidationProcess || GatewayStatus.COLLECTING_USER_INFORMATION;
    }

    return GatewayStatus.NOT_REQUESTED;
  }

  // the issuance request has been made
  if (gatekeeperRecord?.received?.state === GatekeeperAPIStatus.REQUESTED) {
    if (preApprovedTxAvailable(gatekeeperRecord)) {
      if (payerIsWalletOwner(state)) {
        return ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX;
      }
      return ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
    }

    if (isInPartnerReview(gatekeeperRecord)) {
      return ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW;
    }

    if (state.inputs.parameters?.payer) {
      // in the case where a payer has been set, a transaction is required to move forward
      // either by the client sending themselves, or a third party sending
      // in either case, if we don't have a transaction, we need to restart data collection to make the
      // gatekeeper request again to get a new transaction
      if (
        gatekeeperRecord?.status === InputStatus.COMPLETE &&
        civicPassEvent?.action !== CivicPassMessageAction.ISSUANCE &&
        !gatekeeperRecord.received?.transaction
      ) {
        return ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION;
      }
    } else {
      // civic-sends case
      return ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
    }
  }
};

export const computeIssuanceStatus = (state: GatewayCoreState): GatewayTokenCheckType | CalculateIssuanceStatusReturn =>
  statusFromGatewayTokenIfExists(state) ||
  calculateIssuanceStatus(state) ||
  (state.internal?.status as GatewayTokenCheckType | CalculateIssuanceStatusReturn);

export const computeIssuanceStartPreApprovedTransaction = (
  state: GatewayCoreState
):
  | GatewayTokenCheckType
  | ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
  | ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX =>
  statusFromGatewayTokenIfExists(state) ||
  calculateIssuanceStartPreApprovedTransaction(state) ||
  (state.internal?.status as GatewayTokenCheckType | ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX);

import { GatewayCoreState } from '../../src/types/gatewayCore';
import {
  calculateFromGatekeeperRefreshRequested,
  calculateFromRefreshAwaitingOnChain,
  calculateFromRefreshInReview,
  calculateRefreshStartPreApprovedTransaction,
  calculateRefreshStatus,
  tokenNotRefreshRequired,
} from '../../src/state/refresh';
import { ExtendedGatewayStatus, GatewayStatus } from '../../src/types/gateway';
import { expect } from 'chai';
import { InputStatus } from '../../src/types/fetch';
import { GatekeeperAPIStatus } from '../../src/types/gatekeeperApi';
import { CivicPassMessageAction, CivicPassMessageEventResult } from '../../src/types/civicPass';
import { ChainConfirmationTimeout } from '../../src/utils/errors';
import { GatewayClientParameters } from '../../src/types/parameters';

describe('refresh state functions', () => {
  context('calculateFromRefreshInReview', () => {
    context('with an input payer', () => {
      context('with a sent transaction', () => {
        it('returns REFRESH_AWAITING_ON_CHAIN_TOKEN', () => {
          // Arrange
          const state = {
            inputs: {
              parameters: {
                payer: 'payer',
              },
            },
            internal: {
              chainTransaction: {
                sentTxId: 'sentTxId',
              },
            },
          } as unknown as GatewayCoreState;

          // Act
          const result = calculateFromRefreshInReview(state);

          // Assert
          expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN);
        });
      });

      context('with a transaction error', () => {
        it('returns CHAIN_TRANSACTION_ERROR', () => {
          // Arrange
          const state = {
            inputs: {
              parameters: {
                payer: 'payer',
              },
            },
            internal: {
              chainTransaction: {
                error: 'error',
              },
            },
          } as unknown as GatewayCoreState;

          // Act
          const result = calculateFromRefreshInReview(state);

          // Assert
          expect(result).to.equal(ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR);
        });
      });

      context('with a gatekeeper record transaction', () => {
        context('if the payer is the wallet owner', () => {
          it('returns REFRESH_AWAITING_TRANSACTION_SEND', () => {
            // Arrange
            const state = {
              inputs: {
                parameters: {
                  wallet: { address: 'payer' },
                  payer: 'payer',
                },
                gatekeeperRecord: {
                  received: {
                    transaction: 'transaction',
                  },
                },
              },
            } as unknown as GatewayCoreState;

            // Act
            const result = calculateFromRefreshInReview(state);

            // Assert
            expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND);
          });
        });
        context('is the payer is not the wallet owner', () => {
          it('returns REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND', () => {
            // Arrange
            const state = {
              inputs: {
                parameters: {
                  payer: 'payer',
                },
                gatekeeperRecord: {
                  received: {
                    transaction: 'transaction',
                  },
                },
              },
            } as unknown as GatewayCoreState;

            // Act
            const result = calculateFromRefreshInReview(state);

            // Assert
            expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND);
          });
        });
      });
    });

    context('with no payer set', () => {
      it('returns REFRESH_AWAITING_ON_CHAIN_TOKEN', () => {
        // Arrange
        const state = {
          inputs: {
            parameters: {
              payer: undefined,
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateFromRefreshInReview(state);

        // Assert
        expect(result).to.equal(ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN);
      });
    });
  });

  context('calculateFromGatekeeperRefreshRequested', () => {
    context('with a gatekeeper record in state', () => {
      [
        {
          received: {
            state: GatekeeperAPIStatus.REQUESTED,
          },
        },
        {
          status: InputStatus.IN_PROGRESS,
        },
      ].forEach((gatekeeperRecordState) => {
        context('with a gatekeeper record requested', () => {
          context('with a payer set', () => {
            context('with the payer the same as wallet owner', () => {
              it('returns REFRESH_CLIENT_PAYER_REQUESTED', () => {
                // Arrange
                const state = {
                  inputs: {
                    parameters: {
                      wallet: { address: 'payer' },
                      payer: 'payer',
                    },
                    gatekeeperRecord: gatekeeperRecordState,
                  },
                } as unknown as GatewayCoreState;

                // Act
                const result = calculateFromGatekeeperRefreshRequested(state);

                // Assert
                expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED);
              });
            });

            context('if the payer is not the wallet owner', () => {
              it('returns REFRESH_IN_REVIEW', () => {
                // Arrange
                const state = {
                  inputs: {
                    parameters: {
                      payer: 'payer',
                    },
                    gatekeeperRecord: gatekeeperRecordState,
                  },
                } as unknown as GatewayCoreState;

                // Act
                const result = calculateFromGatekeeperRefreshRequested(state);

                // Assert
                expect(result).to.equal(ExtendedGatewayStatus.REFRESH_IN_REVIEW);
              });
            });
          });
        });
      });
    });

    context('with no gatekeeper record in state', () => {
      it('returns undefined', () => {
        // Arrange
        const state = {
          inputs: {
            gatekeeperRecord: undefined,
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateFromGatekeeperRefreshRequested(state);

        // Assert
        expect(result).to.be.undefined;
      });
    });
  });

  context('tokenNotRefreshRequired', () => {
    context('with a token status', () => {
      context('with a token status that is not REFRESH_AWAITING_ON_CHAIN_TOKEN or REFRESH_TOKEN_REQUIRED', () => {
        [GatewayStatus.ACTIVE, GatewayStatus.FROZEN, GatewayStatus.REVOKED].forEach((tokenStatus) => {
          it('returns the token status', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    state: tokenStatus,
                  },
                },
              },
            } as unknown as GatewayCoreState;

            // Act
            const result = tokenNotRefreshRequired(state);

            // Assert
            expect(result).to.equal(tokenStatus);
          });
        });
      });
    });
  });

  context('calculateRefreshStatus', () => {
    context('with a civic pass REFRESH SUCCESS', () => {
      it('should return REFRESH_USER_INFORMATION_VALIDATED', () => {
        // Arrange
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.REFRESH,
                event: CivicPassMessageEventResult.SUCCESS,
              },
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateRefreshStatus(state);

        // Assert
        expect(result).to.equal(ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED);
      });
    });

    context('with a non REFRESH civic pass event', () => {
      it('should return undefined', () => {
        // Arrange
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: 'OTHER',
                event: 'SUCCESS',
              },
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateRefreshStatus(state);

        // Assert
        expect(result).to.be.undefined;
      });
    });

    context('with a TX that can be reissued', () => {
      let parameters: GatewayClientParameters;

      context('with a payer the same as the wallet owner', () => {
        beforeEach(() => {
          parameters = {
            wallet: { address: 'payer' },
            payer: 'payer',
          } as GatewayClientParameters;
        });
        it('should return REFRESH_CLIENT_SENDS_START_NEW_TX', () => {
          // Arrange
          const state = {
            inputs: {
              parameters,
              civicPass: {
                received: {
                  action: 'OTHER',
                  event: 'SUCCESS',
                },
              },
              gatekeeperRecord: {
                received: {
                  transaction: 'transaction',
                  payload: {
                    preApprovedTxAvailable: true,
                  },
                },
              },
            },
          } as unknown as GatewayCoreState;

          // Act
          const result = calculateRefreshStatus(state);

          // Assert
          expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX);
        });
      });

      context('with a payer different from the wallet owner', () => {
        beforeEach(() => {
          parameters = {
            wallet: { address: 'payer' },
            payer: 'different_payer',
          } as GatewayClientParameters;
        });

        it('should return REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX', () => {
          // Arrange
          const state = {
            inputs: {
              parameters,
              civicPass: {
                received: {
                  action: 'OTHER',
                  event: 'SUCCESS',
                },
              },
              gatekeeperRecord: {
                received: {
                  transaction: 'transaction',
                  payload: {
                    preApprovedTxAvailable: true,
                  },
                },
              },
            },
          } as unknown as GatewayCoreState;

          // Act
          const result = calculateRefreshStatus(state);

          // Assert
          expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
        });
      });
    });
  });

  context('calculateFromRefreshAwaitingOnChain', () => {
    context('with a chain timeout error', () => {
      it('returns CHAIN_TIMEOUT_ERROR', () => {
        // Arrange
        const state = {
          internal: {
            errors: {
              expectedOnChainToken: new ChainConfirmationTimeout('message'),
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateFromRefreshAwaitingOnChain(state);

        // Assert
        expect(result).to.equal(ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR);
      });
    });

    context('with no chain timeout error', () => {
      it('returns undefined', () => {
        // Arrange
        const state = {
          internal: {
            chainTransaction: {
              error: undefined,
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateFromRefreshAwaitingOnChain(state);

        // Assert
        expect(result).to.be.undefined;
      });
    });

    context('with a non timeout error', () => {
      it('returns undefined', () => {
        // Arrange
        const state = {
          internal: {
            chainTransaction: {
              error: new Error('message'),
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateFromRefreshAwaitingOnChain(state);

        // Assert
        expect(result).to.equal(undefined);
      });
    });
  });

  context('calculateRefreshStartPreApprovedTransaction', () => {
    context('with a successful civic pass pre-approved tx event', () => {
      it('should return REFRESH_CLIENT_SENDS_REQUEST_NEW_TX', () => {
        // Arrange
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION,
                event: CivicPassMessageEventResult.SUCCESS,
                payload: {},
              },
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateRefreshStartPreApprovedTransaction(state);

        // Assert
        expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX);
      });

      context('with a third party payer', () => {
        it('should return REFRESH_CLIENT_SENDS_REQUEST_NEW_TX', () => {
          // Arrange
          const state = {
            inputs: {
              civicPass: {
                received: {
                  action: CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION,
                  event: CivicPassMessageEventResult.SUCCESS,
                  payload: {},
                },
              },
              parameters: {
                payer: 'payer',
              },
            },
          } as unknown as GatewayCoreState;

          // Act
          const result = calculateRefreshStartPreApprovedTransaction(state);

          // Assert
          expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
        });
      });
    });

    context('with an unsuccessful civic pass refresh event', () => {
      it('should return undefined', () => {
        // Arrange
        const state = {
          inputs: {
            civicPass: {},
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateRefreshStartPreApprovedTransaction(state);

        // Assert
        expect(result).to.be.undefined;
      });
    });

    context('with a non-refresh civic pass event', () => {
      it('should return undefined', () => {
        // Arrange
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.REFRESH,
                event: CivicPassMessageEventResult.FAILURE,
                payload: undefined,
              },
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateRefreshStartPreApprovedTransaction(state);

        // Assert
        expect(result).to.be.undefined;
      });
    });

    context('with no payload in civic pass event', () => {
      it('should return undefined', () => {
        // Arrange
        const state = {
          inputs: {
            civicPass: {
              received: {
                action: CivicPassMessageAction.REFRESH,
                event: CivicPassMessageEventResult.SUCCESS,
                payload: undefined,
              },
            },
          },
        } as unknown as GatewayCoreState;

        // Act
        const result = calculateRefreshStartPreApprovedTransaction(state);

        // Assert
        expect(result).to.be.undefined;
      });
    });
  });
});

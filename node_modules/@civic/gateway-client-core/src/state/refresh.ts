import { GatewayCoreState } from '../types/gatewayCore';
import { ExtendedGatewayStatus, GatewayStatus, InternalGatewayStatus } from '../types/gateway';
import {
  statusIfGatekeeperRecordRejected,
  statusFromGatewayTokenIfExists,
  payerIsWalletOwner,
  StatusIfGatekeeperRecordRejectedType,
  GatewayTokenCheckType,
} from './common';
import { InputStatus } from '../types/fetch';
import { CivicPassMessageAction, CivicPassMessageEventResult } from '../types/civicPass';
import { GatekeeperAPIStatus } from '../types/gatekeeperApi';
import { ChainConfirmationTimeout, ErrorCode } from '../utils/errors';
import { preApprovedTxAvailable } from './issuance';

export type CalculateFromRefreshInReviewReturnType =
  | ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN
  | ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR
  | ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND
  | ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND;

// we're waiting on a civic pass to provide us with a payload to send to the gatekeeper
// when we get the refresh payload, then return REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
export const calculateRefreshStartPreApprovedTransaction = (
  state: GatewayCoreState
):
  | ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
  | ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX
  | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  if (
    civicPassEvent?.action === CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS &&
    civicPassEvent?.payload !== undefined
  ) {
    return payerIsWalletOwner(state)
      ? ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
      : ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
  }
};

export const calculateFromRefreshInReview = (
  state: GatewayCoreState
): CalculateFromRefreshInReviewReturnType | undefined => {
  const gatekeeperRecord = state.inputs.gatekeeperRecord;

  if (state.inputs.parameters?.payer) {
    // this is the case where we're restarting a flow and we need a new transaction, so we need to check if we have proof
    // otherwise restart the flow
    if (state.internal?.chainTransaction?.sentTxId) {
      return ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN;
    }
    if (state.internal?.chainTransaction?.error) {
      return ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR;
    }
    if (gatekeeperRecord.received?.transaction) {
      if (payerIsWalletOwner(state)) {
        return ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND;
      }
      return ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
    }
  } else {
    // civic-sends case
    return ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN;
  }
};

export type CalculateFromGatekeeperRefreshRequestedReturnType =
  | ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED
  | ExtendedGatewayStatus.REFRESH_IN_REVIEW;

export const calculateFromGatekeeperRefreshRequested = (
  state: GatewayCoreState
): CalculateFromGatekeeperRefreshRequestedReturnType | undefined => {
  const gatekeeperRecord = state.inputs.gatekeeperRecord;
  // post-gatekeeper request
  if (
    gatekeeperRecord?.received?.state === GatekeeperAPIStatus.REQUESTED ||
    gatekeeperRecord?.status === InputStatus.IN_PROGRESS
  ) {
    return state.inputs.parameters?.payer && payerIsWalletOwner(state)
      ? ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED
      : ExtendedGatewayStatus.REFRESH_IN_REVIEW;
  }
};

export type TokenNotRefreshRequiredReturnType =
  | GatewayTokenCheckType
  | ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN
  | GatewayStatus.REFRESH_TOKEN_REQUIRED;

export const tokenNotRefreshRequired = (state: GatewayCoreState): TokenNotRefreshRequiredReturnType | undefined => {
  const tokenStatus = statusFromGatewayTokenIfExists(state);
  return tokenStatus &&
    // we don't want to trigger a change to active until the gatewayToken expiry changes
    ![ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN, GatewayStatus.REFRESH_TOKEN_REQUIRED].includes(tokenStatus)
    ? tokenStatus
    : undefined;
};

export type ComputeRefreshRequestedReturnType = InternalGatewayStatus;

export const computeRefreshRequested = (state: GatewayCoreState): ComputeRefreshRequestedReturnType =>
  tokenNotRefreshRequired(state) ||
  calculateFromGatekeeperRefreshRequested(state) ||
  (state.internal?.status as InternalGatewayStatus);

export type ComputeRefreshInReviewReturnType =
  | InternalGatewayStatus
  | ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN
  | ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR
  | ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND
  | ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND;

export const computeRefreshInReview = (state: GatewayCoreState): ComputeRefreshInReviewReturnType =>
  tokenNotRefreshRequired(state) ||
  statusIfGatekeeperRecordRejected(state) ||
  calculateFromRefreshInReview(state) ||
  (state.internal?.status as InternalGatewayStatus);

export type CalculateRefreshStatusReturnType = InternalGatewayStatus;

export const calculateRefreshStatus = (state: GatewayCoreState): CalculateRefreshStatusReturnType | undefined => {
  const civicPassEvent = state.inputs.civicPass?.received;
  if (preApprovedTxAvailable(state.inputs.gatekeeperRecord)) {
    if (payerIsWalletOwner(state)) {
      return ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX;
    }
    return ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
  }
  if (
    civicPassEvent?.action === CivicPassMessageAction.REFRESH &&
    civicPassEvent?.event === CivicPassMessageEventResult.SUCCESS
  ) {
    return ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED;
  }
};

export type ComputeRefreshStatusReturnType =
  | InternalGatewayStatus
  | ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN
  | ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR
  | ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND
  | ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND
  | ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED;

export const computeRefreshStatus = (state: GatewayCoreState): ComputeRefreshStatusReturnType =>
  tokenNotRefreshRequired(state) ||
  statusIfGatekeeperRecordRejected(state) ||
  calculateRefreshStatus(state) ||
  (state.internal?.status as InternalGatewayStatus);

export type CalculateFromRefreshAwaitingOnChainReturnType =
  | InternalGatewayStatus
  | ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR;

export const calculateFromRefreshAwaitingOnChain = (
  state: GatewayCoreState
): CalculateFromRefreshAwaitingOnChainReturnType | undefined => {
  if (
    (state.internal.errors?.expectedOnChainToken as ChainConfirmationTimeout)?.errorCode ===
    ErrorCode.CHAIN_CONFIRMATION_TIMEOUT_ERROR
  ) {
    return ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR;
  }
};

export type ComputeRefreshAwaitingOnChainTokenReturnType =
  | TokenNotRefreshRequiredReturnType
  | StatusIfGatekeeperRecordRejectedType
  | CalculateFromRefreshAwaitingOnChainReturnType;

export const computeRefreshAwaitingOnChainToken = (
  state: GatewayCoreState
): ComputeRefreshAwaitingOnChainTokenReturnType =>
  tokenNotRefreshRequired(state) ||
  statusIfGatekeeperRecordRejected(state) ||
  calculateFromRefreshAwaitingOnChain(state) ||
  (state.internal?.status as InternalGatewayStatus);

export const computeRefreshStartPreApprovedTransaction = (
  state: GatewayCoreState
):
  | TokenNotRefreshRequiredReturnType
  | ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
  | ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX =>
  tokenNotRefreshRequired(state) ||
  calculateRefreshStartPreApprovedTransaction(state) ||
  (state.internal?.status as
    | TokenNotRefreshRequiredReturnType
    | ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX);

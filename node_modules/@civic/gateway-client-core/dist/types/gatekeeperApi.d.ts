import { RequestInitRetryParams } from 'fetch-retry';
import { ChainType } from './chain';
export declare enum GatekeeperAPIStatus {
    REQUESTING = 0,
    NOT_REQUESTED = 404,
    REQUESTED = 202,
    ISSUED = 200,
    ISSUED_EXPIRY_APPROACHING = 205,
    ISSUED_EXPIRED = 426,
    LOCATION_NOT_SUPPORTED = 401,
    REJECTED = 403,
    VPN_NOT_SUPPORTED = 421,
    ISSUED_LOCATION_NOT_SUPPORTED = 412,
    ISSUED_VPN_NOT_SUPPORTED = 451,
    SERVER_FAILURE = 500,
    REQUESTED_RETRIES_EXHAUSTED = 408
}
export type TokenRequest = {
    payload: Record<string, unknown>;
    proof?: string;
    payer?: string;
};
export type GatekeeperClientConfig = {
    baseUrl?: string;
    queryParams?: Record<string, string>;
    headers?: Record<string, string>;
    stage: string;
    fetchImplementation: (input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>;
    numRetries: number;
    walletAddress: string;
    chainType: ChainType;
    abortController: AbortController;
};
export type PendingPayload = {
    presentationRequestId: string;
};
export type GatekeeperErrorResponse = {
    errorCode?: string;
    payload?: Record<string, unknown>;
};
export type GatekeeperRecordResponse = GatekeeperErrorResponse & {
    state: GatekeeperAPIStatus;
    transaction?: string;
    preApprovedTxAvailable?: boolean;
    pending?: {
        presentationRequestId: string;
    };
};
export type RequestTokenIssuanceResponse = GatekeeperRecordResponse & {
    status: number;
};
export type RequestTokenRefreshResponse = RequestTokenIssuanceResponse;
export type FetchWithRetry = (input: RequestInfo, init?: (RequestInit & RequestInitRetryParams<typeof fetch>) | undefined) => Promise<Response>;

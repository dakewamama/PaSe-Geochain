import chai from 'chai';
import {
  handleGatewayTokenExistsStatus,
  statusFromGatewayTokenIfExists,
  statusIfGatekeeperRecordRejected,
} from '../../src/state/common';
import { GatewayCoreState, GatewayStatus, GatewayToken } from '../../src';
import { nowSeconds } from '../../src/utils/expiry';
import { GatekeeperAPIStatus } from '../../src/types/gatekeeperApi';
import sinon from 'sinon';

const { expect } = chai;
const sandbox = sinon.createSandbox();

describe('common state functions unit tests', () => {
  afterEach(sandbox.restore);
  context('statusFromGatewayTokenIfExists', () => {
    context('with an ACTIVE token', () => {
      context('with an expired token', () => {
        it('should return REFRESH_TOKEN_REQUIRED', () => {
          // Arrange
          const state = {
            inputs: {
              gatewayToken: {
                received: {
                  expiryTime: nowSeconds() - 1000,
                  state: 'ACTIVE',
                },
              },
              dynamicParameters: {
                forceRequireRefresh: false,
              },
            },
          } as GatewayCoreState;
          // Act
          const result = statusFromGatewayTokenIfExists(state);
          // Assert
          expect(result).to.equal(GatewayStatus.REFRESH_TOKEN_REQUIRED);
        });
      });

      context('with a non-expired token', () => {
        context('with forceRequireRefresh set to true', () => {
          it('should return REFRESH_TOKEN_REQUIRED', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: true,
                },
              },
            } as GatewayCoreState;
            // Act
            const result = statusFromGatewayTokenIfExists(state);
            // Assert
            expect(result).to.equal(GatewayStatus.REFRESH_TOKEN_REQUIRED);
          });
        });

        context('with forceRequireRefresh set to false', () => {
          it('should return ACTIVE', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
            } as GatewayCoreState;
            // Act
            const result = statusFromGatewayTokenIfExists(state);
            // Assert
            expect(result).to.equal(GatewayStatus.ACTIVE);
          });
        });
      });
    });

    context('with a FROZEN token', () => {
      it('should return FROZEN', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: {
              received: {
                state: 'FROZEN',
              },
            },
          },
        } as GatewayCoreState;
        // Act
        const result = statusFromGatewayTokenIfExists(state);
        // Assert
        expect(result).to.equal(GatewayStatus.FROZEN);
      });
    });

    context('with a REVOKED token', () => {
      it('should return REVOKED', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: {
              received: {
                state: 'REVOKED',
              },
            },
          },
        } as GatewayCoreState;
        // Act
        const result = statusFromGatewayTokenIfExists(state);
        // Assert
        expect(result).to.equal(GatewayStatus.REVOKED);
      });
    });

    context('with an unsupported token state', () => {
      it('should return ERROR', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: {
              received: {
                state: 'UNSUPPORTED',
              },
            } as unknown as GatewayToken,
          },
        } as unknown as GatewayCoreState;
        // Act
        const result = statusFromGatewayTokenIfExists(state);
        // Assert
        expect(result).to.equal(GatewayStatus.ERROR);
      });
    });
  });

  context('handleGatewayTokenExistsStatus', () => {
    context('with statusFromGatewayTokenIfExists returning a valid status', () => {
      it('should return the status', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: {
              received: {
                state: 'ACTIVE',
              },
            },
          },
        } as GatewayCoreState;
        // Act
        const result = handleGatewayTokenExistsStatus(state);
        // Assert
        expect(result).to.equal(GatewayStatus.ACTIVE);
      });
    });

    context('with statusFromGatewayTokenIfExists returning an unsupported state', () => {
      it('should log an error and return ERROR', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: {
              received: {
                state: 'UNSUPPORTED',
              },
            } as unknown as GatewayToken,
          },
        } as unknown as GatewayCoreState;
        // Act
        const result = handleGatewayTokenExistsStatus(state);
        // Assert
        expect(result).to.equal(GatewayStatus.ERROR);
      });
    });

    context('with statusFromGatewayTokenIfExists returning undefined', () => {
      it('should log an error and return ERROR', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: undefined,
          },
        } as unknown as GatewayCoreState;
        // Act
        const result = handleGatewayTokenExistsStatus(state);
        // Assert
        expect(result).to.equal(GatewayStatus.ERROR);
      });
    });

    context('with statusFromGatewayTokenIfExists returning undefined', () => {
      it('should log an error and return ERROR', () => {
        // Arrange
        const state = {
          inputs: {
            gatewayToken: {
              received: {
                state: undefined,
              },
            } as unknown as GatewayToken,
          },
        } as unknown as GatewayCoreState;
        // Act
        const result = handleGatewayTokenExistsStatus(state);
        // Assert
        expect(result).to.equal(GatewayStatus.ERROR);
      });
    });
  });

  context('statusIfGatekeeperRecordRejected', () => {
    it('with a REJECTED API state, should return REJECTED', () => {
      // Arrange
      const state = {
        inputs: {
          gatekeeperRecord: {
            received: {
              state: GatekeeperAPIStatus.REJECTED,
            },
          },
        },
      } as unknown as GatewayCoreState;
      // Act
      const result = statusIfGatekeeperRecordRejected(state);
      // Assert
      expect(result).to.equal(GatewayStatus.REJECTED);
    });

    it('with a LOCATION_NOT_SUPPORTED or ISSUED_LOCATION_NOT_SUPPORTED API state, should return LOCATION_NOT_SUPPORTED', () => {
      // Arrange
      [GatekeeperAPIStatus.LOCATION_NOT_SUPPORTED, GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED].forEach(
        (recordState) => {
          const state = {
            inputs: {
              gatekeeperRecord: {
                received: {
                  state: recordState,
                },
              },
            },
          } as unknown as GatewayCoreState;
          // Act
          const result = statusIfGatekeeperRecordRejected(state);
          // Assert
          expect(result).to.equal(GatewayStatus.LOCATION_NOT_SUPPORTED);
        }
      );
    });

    it('with a VPN_NOT_SUPPORTED or ISSUED_VPN_NOT_SUPPORTED API state, should return VPN_NOT_SUPPORTED', () => {
      // Arrange
      [GatekeeperAPIStatus.VPN_NOT_SUPPORTED, GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED].forEach((recordState) => {
        const state = {
          inputs: {
            gatekeeperRecord: {
              received: {
                state: recordState,
              },
            },
          },
        } as unknown as GatewayCoreState;
        // Act
        const result = statusIfGatekeeperRecordRejected(state);
        // Assert
        expect(result).to.equal(GatewayStatus.VPN_NOT_SUPPORTED);
      });
    });

    it('with a REQUESTED_RETRIES_EXHAUSTED API state, should return ERROR', () => {
      // Arrange
      const state = {
        inputs: {
          gatekeeperRecord: {
            received: {
              state: GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED,
            },
          },
        },
      } as unknown as GatewayCoreState;
      // Act
      const result = statusIfGatekeeperRecordRejected(state);
      // Assert
      expect(result).to.equal(GatewayStatus.ERROR);
    });

    context('with an ISSUED_EXPIRED API state', () => {
      context('with a gatewayToken received', () => {
        it('should return undefined', () => {
          // Arrange
          const state = {
            inputs: {
              gatekeeperRecord: {
                received: {
                  state: GatekeeperAPIStatus.ISSUED_EXPIRED,
                },
              },
              gatewayToken: {
                received: {
                  state: 'ACTIVE',
                },
              },
            },
          } as GatewayCoreState;
          // Act
          const result = statusIfGatekeeperRecordRejected(state);
          // Assert
          expect(result).to.be.undefined;
        });
      });

      context('with no gatewayToken received', () => {
        it('should return ERROR', () => {
          // Arrange
          const state = {
            inputs: {
              gatekeeperRecord: {
                received: {
                  state: GatekeeperAPIStatus.ISSUED_EXPIRED,
                },
              },
              gatewayToken: {
                received: null,
              } as unknown as GatewayToken,
            },
          } as unknown as GatewayCoreState;
          // Act
          const result = statusIfGatekeeperRecordRejected(state);
          // Assert
          expect(result).to.equal(GatewayStatus.ERROR);
        });
      });
    });
  });
});

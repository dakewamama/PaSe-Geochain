import { default as fetchBuilder } from 'fetch-retry';
import { RequestInitRetryParams } from 'fetch-retry';
import { objectToURLParams } from './utils/url';
import { prefixLogger } from './logger';
import {
  FetchWithRetry,
  GatekeeperAPIStatus,
  GatekeeperClientConfig,
  GatekeeperRecordResponse,
  RequestTokenIssuanceResponse,
  RequestTokenRefreshResponse,
  TokenRequest,
} from './types/gatekeeperApi';
import { ChainType } from './types/chain';

export const GATEKEEPER_BASE_ENDPOINTS: Record<string, string> = {
  local: `http://localhost:3001/local`,
  test: `https://dev-gatekeeper-api.civic.com`, // for automated tests
  dev: `https://dev-gatekeeper-api.civic.com`,
  preprod: `https://preprod-gatekeeper-api.civic.com`,
  prod: `https://gatekeeper-api.civic.com`,
};

const logDebug = prefixLogger('GatekeeperClient').debug;
const logWarn = prefixLogger('GatekeeperClient').warn;
const logError = prefixLogger('GatekeeperClient').error;

export const getGatekeeperEndpoint = (stage: string, chainType: ChainType): string => {
  let baseUrl = GATEKEEPER_BASE_ENDPOINTS[stage];
  if (!baseUrl) {
    logWarn(`No Gatekeeper endpoint for stage ${stage} . Using dev endpoint.`);
    baseUrl = GATEKEEPER_BASE_ENDPOINTS.dev;
  }
  return `${baseUrl}/v1/token/${chainType}`;
};

export const isGkApiStatusTokenCreated = (code: number): boolean => code === GatekeeperAPIStatus.ISSUED;
export const isGkApiStatusTokenPending = (code: number): boolean => code === GatekeeperAPIStatus.REQUESTED;
export const isGkApiStatusRequestedRetriesExhausted = (code: number): boolean =>
  code === GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED;
export const isGkApiStatusFailure = (code: number): boolean =>
  !isGkApiStatusTokenPending(code) && !isGkApiStatusRequestedRetriesExhausted(code) && code >= 400;
export const withoutUndefined = (obj: Record<string, unknown>): Record<string, unknown> =>
  Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined));

export class GatekeeperClient {
  private abortController: AbortController;

  private baseUrl: string;

  private queryParams: Record<string, string> | undefined;

  private headers: Record<string, string> | undefined;

  private defaultRetryParams: RequestInitRetryParams<typeof fetch>;

  // Fetch can be overridden with a stub for unit tests
  private fetchImplementation: (input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>;

  private fetchWithRetry: FetchWithRetry;

  constructor(public initConfig: GatekeeperClientConfig, flowId?: string) {
    this.abortController = initConfig.abortController;
    this.baseUrl = initConfig.baseUrl || getGatekeeperEndpoint(initConfig.stage, initConfig.chainType);
    this.queryParams = initConfig.queryParams;
    this.headers = objectToURLParams({ ...initConfig.headers, 'x-civic-flowid': flowId });
    this.fetchImplementation = initConfig.fetchImplementation;
    const retries = initConfig.numRetries;
    // By default retry on every 5xx or other Error (e.g. network failure):
    this.defaultRetryParams = {
      retries,
      retryOn: async (attempt: number, error: Error | null, response: Response | null): Promise<boolean> => {
        const body = response ? await response.clone().json() : {};
        if (response && response.status >= 500) {
          if (body?.message?.includes('NO_AUTO_RETRY')) {
            return false;
          }

          if (attempt >= retries) {
            logError('retryOn error run out of retries', { error, attempt, retries, response, body });
            throw error as Error;
          }
          logDebug('retrying on 5xx error', { error, attempt, retries, response, body });
          return true;
        }
        logDebug('retryOn returning false as error was not a 5xx error');
        return false;
      },
      retryDelay: (attempt: number): number => {
        const retryDelay = 10 + 2 ** attempt * 1000; // 10 seconds is the minimum allowed retry time on the GK-API side
        logDebug('retryDelay', { attempt: attempt + 1, retryDelay });
        return retryDelay;
      },
    };

    this.fetchWithRetry = fetchBuilder(this.fetchImplementation, this.defaultRetryParams);
  }

  public setFlowId(flowId: string): void {
    this.headers = objectToURLParams({ ...(this.headers || {}), 'x-civic-flowid': flowId });
  }

  private instanceName() {
    return this.queryParams?.gatekeeperNetworkAddress?.substring(0, 6);
  }

  public abort(): void {
    logDebug(`abort ${this.queryParams?.gatekeeperNetworkAddress?.substring(0, 6)}`);
    this.abortController.abort();
  }

  private addQueryParams(url: URL) {
    if (!this.queryParams) return;
    Object.entries(this.queryParams).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });
  }

  private continueIfNotAborted<T>(fn: () => T): T | null {
    logDebug(
      `continueIfNotAborted ${this.instanceName()} this.abortController.signal.aborted: ${
        this.abortController.signal.aborted
      }`,
      this.queryParams
    );
    if (!this.abortController.signal.aborted) {
      return fn();
    }
    return null;
  }

  private urlForWallet(walletAddress: string = this.initConfig.walletAddress): string {
    const url = new URL(`${this.baseUrl}/${walletAddress}`);
    this.addQueryParams(url);
    return url.toString();
  }

  public async getGatekeeperRecordWithPayload(
    walletAddress: string = this.initConfig.walletAddress
  ): Promise<GatekeeperRecordResponse | null> {
    logDebug(
      `url: ${this.urlForWallet(
        walletAddress
      )} getGatekeeperRecordWithPayload: ${this.instanceName()}  this.abortController.signal.aborted: ${
        this.abortController.signal.aborted
      }`
    );
    return this.fetchWithRetry(this.urlForWallet(walletAddress), {
      method: 'GET',
      headers: this.headers,
      signal: this.abortController.signal,
    })
      .then(
        this.continueIfNotAborted(() => async (response) => ({
          state: GatekeeperAPIStatus[GatekeeperAPIStatus[response.status] as keyof typeof GatekeeperAPIStatus],
          payload: await response.json(),
        }))
      )
      .catch((error) => {
        if (error.name === 'AbortError') {
          logDebug('error due to abort controller signal aborted');
          return null;
        }
        throw error;
      });
  }

  public async getGatekeeperStatus(
    walletAddress: string = this.initConfig.walletAddress
  ): Promise<GatekeeperAPIStatus> {
    logDebug(
      `getGatekeeperStatus: ${this.instanceName()}  this.abortController.signal.aborted: ${
        this.abortController.signal.aborted
      }`
    );
    return this.fetchWithRetry(this.urlForWallet(walletAddress), {
      method: 'HEAD',
      headers: this.headers,
      signal: this.abortController.signal,
    })
      .then(
        this.continueIfNotAborted(
          () =>
            ({ status }) =>
              status
        )
      )
      .catch((error) => {
        logError('getGatekeeperStatus', error);
        if (error.name === 'AbortError') {
          logDebug('error due to abort controller signal aborted');
          return GatekeeperAPIStatus.SERVER_FAILURE;
        }
        throw error;
      });
  }

  public async requestGatewayTokenFromGatekeeper({
    payload,
    proof,
    payer,
  }: TokenRequest): Promise<RequestTokenIssuanceResponse | null> {
    logDebug(
      `requestGatewayTokenFromGatekeeper: ${this.instanceName()}  this.abortController.signal.aborted: ${
        this.abortController.signal.aborted
      }`,
      {
        ...payload,
        proof,
      }
    );

    // We only pass the wallet public key as part of the request if
    // it was not passed as part of the presentation.
    const body = withoutUndefined({
      ...(payload as Record<string, unknown>),
      proof,
      address: this.initConfig.walletAddress,
      payer,
    });
    logDebug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', body);

    const url = new URL(this.baseUrl);
    this.addQueryParams(url);

    return this.fetchWithRetry(url.toString(), {
      method: 'POST',
      headers: {
        ...this.headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
      signal: this.abortController.signal,
    })
      .then(
        this.continueIfNotAborted(() => async (resp) => {
          const { status } = resp;
          const result = (await resp.json()) as unknown as RequestTokenIssuanceResponse;
          return {
            ...result,
            state: GatekeeperAPIStatus[GatekeeperAPIStatus[status] as keyof typeof GatekeeperAPIStatus],
            status,
          };
        })
      )
      .catch((error) => {
        logError('requestGatewayTokenFromGatekeeper', error);
        if (error.name === 'AbortError') {
          logDebug('error due to abort controller signal aborted');
          return null;
        }
        throw error;
      });
  }

  /**
   * Tries to refresh a token.
   * If it fails with a 5xx, handleFetchError will retry a number of times.
   */
  public async refreshToken({ payload, proof, payer }: TokenRequest): Promise<RequestTokenRefreshResponse | null> {
    logDebug(
      `refreshToken: ${this.urlForWallet(
        this.initConfig.walletAddress
      )}${this.queryParams?.gatekeeperNetworkAddress?.substring(0, 6)}  this.abortController.signal.aborted: ${
        this.abortController.signal.aborted
      }`,
      { payload }
    );
    const body = withoutUndefined({
      ...(payload as Record<string, unknown>),
      proof,
      request: 'refresh',
      payer,
    });
    return this.fetchWithRetry(this.urlForWallet(this.initConfig.walletAddress), {
      method: 'PATCH',
      headers: { ...this.headers, 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      signal: this.abortController.signal,
    })
      .then(async (resp) => {
        const { status } = resp;
        const result = (await resp.json()) as unknown as RequestTokenRefreshResponse;
        return {
          ...result,
          state: GatekeeperAPIStatus[GatekeeperAPIStatus[status] as keyof typeof GatekeeperAPIStatus],
          status,
        };
      })
      .catch((error) => {
        logError('refreshToken', error);
        if (error.name === 'AbortError') {
          logDebug('error due to abort controller signal aborted');
          return null;
        }
        throw error;
      });
  }

  /**
   * Tries to fetch a new transaction for any flow
   * If it fails with a 5xx, handleFetchError will retry a number of times.
   */
  public async fetchFreshTransaction({ payer }: TokenRequest): Promise<RequestTokenRefreshResponse | null> {
    const url = new URL(`${this.baseUrl}/${this.initConfig.walletAddress}/transaction`);
    this.addQueryParams(url);
    logDebug(
      `fetchFreshTransaction: ${url.toString()}${this.queryParams?.gatekeeperNetworkAddress?.substring(
        0,
        6
      )}  this.abortController.signal.aborted: ${this.abortController.signal.aborted}`
    );
    const body = withoutUndefined({
      payer,
    });
    return this.fetchWithRetry(`${url.toString()}`, {
      method: 'POST',
      headers: { ...this.headers, 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      signal: this.abortController.signal,
    })
      .then(async (resp) => {
        const { status } = resp;
        const result = (await resp.json()) as unknown as RequestTokenRefreshResponse;
        return {
          ...result,
          state: GatekeeperAPIStatus[GatekeeperAPIStatus[status] as keyof typeof GatekeeperAPIStatus],
          status,
        };
      })
      .catch((error) => {
        logError('fetchFreshTransaction', error);
        if (error.name === 'AbortError') {
          logDebug('error due to abort controller signal aborted');
          return null;
        }
        throw error;
      });
  }

  public async updateTransactionStatus(txId: string, status = 'sent'): Promise<void | null> {
    const url = new URL(`${this.baseUrl}/${this.initConfig.walletAddress}/transaction/${txId}`);
    this.addQueryParams(url);
    const body = { status };

    return this.fetchWithRetry(url.toString(), {
      method: 'PATCH',
      headers: {
        ...this.headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
      signal: this.abortController.signal,
    })
      .then(
        this.continueIfNotAborted(() => async () => {
          logDebug('updateTransactionStatus successful', {
            txId,
            url,
            wallet: this.initConfig.walletAddress,
          });
        })
      )
      .catch((error) => {
        if (error.name === 'AbortError') {
          logDebug('error due to abort controller signal aborted');
          return null;
        }
        logError('updateTransactionStatus', error);
        throw error;
      });
  }
}

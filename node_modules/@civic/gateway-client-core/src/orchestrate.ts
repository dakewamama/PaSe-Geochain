/**
 * 1. register listeners:
 * onChain listener from chainImplementation
 * civicPass listener (postMessage)
 * (potentially handle separately) civicSign listener and responder (postMessage)
 * call gatekeeperClient.getRecord (if GKN requires it) to get gatekeeperRecord, then update gatekeeperRecord state
 *
 * 2. Respond to specific internal states for things that we need to take action on:
 *  - issuanceProofCollectionComplete: use gatekeeperClient to request a token using the proof from  civicPass, then update gatekeeperRecord state
 *  - refreshProofCollectionComplete: use gatekeeperClient to request a token refresh using the proof from civicPass, then update gatekeeperRecord state
 */
import { ListenerManager } from './listeners';
import { MessageEventInterface, PostMessageTargetCallback } from './types/eventInterface';
import { prefixLogger } from './logger';
import { FetchConfig, InputStatus } from './types/fetch';
import { GatekeeperClient } from './gatekeeperClient';
import { ChainClientInterface, DID, GatewayToken } from './types/chain';
import { WalletAdapter } from './types/parameters';
import { ExtendedGatewayStatus, GatewayStatus, InternalGatewayStatus } from './types/gateway';
import { getPayer } from './utils/inputs';
import { eventEmitter, handleRemoteSignEvent, RemoteSignWindowEventEmitter } from './remoteSign';
import { LoggingInterface } from './logger/provider.logger';
import { OrchestratorInputs } from './types/orchestrate';
import { Issuance } from './issuance';
import { CivicPassMessageAction } from './types/civicPass';
import { Store } from './state/state';
import { Refresh } from './refresh';
import { getUserInteractionStatusFromAction } from './utils/userInteraction';
import { PartnerReview } from './partnerReview';
import { tokenNoGatekeeperRecordError } from './state/common';
import { ChainError, ErrorCode } from './utils/errors';
import { getGatekeeperNetworkData } from './gatekeeperNetworkService';

export class Orchestrator {
  readonly listenerManager: ListenerManager;

  readonly gatekeeperClient: GatekeeperClient;

  readonly payer: string | undefined;

  readonly wallet: WalletAdapter;

  remoteSignInstance: RemoteSignWindowEventEmitter | undefined;

  private log: LoggingInterface;

  private abortController: AbortController;

  private _issuance: Issuance | undefined;

  private _refresh: Refresh | undefined;

  private _partnerReview: PartnerReview | undefined;

  constructor(
    readonly gatewayCoreStore: Store,
    readonly messageEventInterface: MessageEventInterface,
    readonly instanceId: string,
    readonly inputs: OrchestratorInputs,
    fetchConfig: FetchConfig,
    readonly postMessageTargetCallback: PostMessageTargetCallback,
    readonly chainImplementation: ChainClientInterface
  ) {
    this.abortController = new AbortController();
    if (!this.chainImplementation || !inputs.wallet?.address || !inputs.stage) {
      throw new Error('chainImplementation wallet and stage are required');
    }
    this.wallet = inputs.wallet;
    this.payer = getPayer(inputs);
    this.log = prefixLogger(`Orchestrator[${this.instanceId}]`);

    this.listenerManager = new ListenerManager(this.messageEventInterface, this.chainImplementation, this.instanceId);
    const chainNetwork = this.chainImplementation?.chainDetails?.chainNetwork;

    this.gatekeeperClient = new GatekeeperClient({
      abortController: this.abortController,
      baseUrl: inputs.gatekeeperConfig?.baseUrl, // if not set, this will be derived from the stage in gatekeeperClient.ts
      queryParams: inputs.gatekeeperNetwork
        ? { network: chainNetwork, gatekeeperNetworkAddress: inputs.gatekeeperNetwork }
        : undefined,
      headers: {
        ...(inputs.gatekeeperConfig?.headers || {}),
        ...(inputs.xCivicClientHeader ? { 'x-civic-client': inputs.xCivicClientHeader } : {}),
      },
      stage: inputs.stage,
      fetchImplementation: fetchConfig.fetchImplementation,
      numRetries: fetchConfig.numRetries,
      walletAddress: inputs.wallet?.address,
      chainType: this.chainImplementation?.chainDetails?.chainType,
    });

    this.log.debug('Orchestrator created');
  }

  private get issuance() {
    if (!this._issuance) {
      this._issuance = new Issuance(
        this.gatewayCoreStore,
        this.chainImplementation,
        this.gatekeeperClient,
        this.abortController,
        this.inputs.expectTokenTimeoutSeconds
      );
    }
    return this._issuance;
  }

  private get refresh() {
    if (!this._refresh) {
      this._refresh = new Refresh(
        this.gatewayCoreStore,
        this.chainImplementation,
        this.gatekeeperClient,
        this.abortController,
        this.inputs.expectTokenTimeoutSeconds
      );
    }
    return this._refresh;
  }

  private get partnerReview() {
    if (!this._partnerReview) {
      this._partnerReview = new PartnerReview(
        this.gatewayCoreStore,
        this.gatekeeperClient,
        this.abortController,
        this.inputs.gatekeeperPollingIntervalSeconds
      );
    }
    return this._partnerReview;
  }

  getRemoteSignInstance() {
    if (!this.remoteSignInstance) {
      this.remoteSignInstance = new RemoteSignWindowEventEmitter(
        eventEmitter(this.postMessageTargetCallback(this.instanceId)),
        this.instanceId
      );
    }
    return this.remoteSignInstance;
  }

  async getOwnerDids() {
    // The dids are exported as part of the computed flowParameters, but they are async on the chainImplementation,
    // so we fetch them here and set them on state so zustand-compute can get them synchronously.
    const dids = await this.chainImplementation.ownerDids();
    this.gatewayCoreStore.setState((state) => {
      state.internal.ownerDids = dids;
    });
  }

  async fetchGatekeeperNetworkData() {
    // We need the GKN data for control flow, so we fetch it here and set it on state so zustand-compute can get it synchronously.
    this.gatewayCoreStore.setState((state) => {
      state.inputs.gatekeeperNetworkData.status = InputStatus.IN_PROGRESS;
    });
    return getGatekeeperNetworkData(this.inputs.stage || 'prod', this.inputs.gatekeeperNetwork || '')
      .then((response) => {
        this.log.debug('getGatekeeperNetworkData', response);
        if (this.abortController.signal.aborted) return;
        this.gatewayCoreStore.setState((state) => {
          state.inputs.gatekeeperNetworkData.status = InputStatus.COMPLETE;
          state.inputs.gatekeeperNetworkData.received = response;
        });
      })
      .catch((error) => {
        this.log.error('Error retrieving gatekeeper network data', error);
        if (this.abortController.signal.aborted) return;
        this.gatewayCoreStore.setState((state) => {
          state.inputs.gatekeeperNetworkData.status = InputStatus.ERROR;
          state.inputs.gatekeeperNetworkData.error = error;
        });
      });
  }

  async lookupTokenState() {
    const retrieveGKRecord = async () => {
      // call gatekeeperClient.getRecord to get gatekeeperRecord (if GKN requires it)
      // update gatekeeperRecord state before and after
      this.gatewayCoreStore.setState((state) => {
        state.inputs.gatekeeperRecord.status = InputStatus.IN_PROGRESS;
      });
      return this.gatekeeperClient
        .getGatekeeperRecordWithPayload()
        .then((response) => {
          this.log.debug('getGatekeeperRecordWithPayload record', response);
          if (this.abortController.signal.aborted) return;
          this.gatewayCoreStore.setState((state) => {
            state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
            state.inputs.gatekeeperRecord.received = response;
          });
        })
        .catch((error) => {
          this.log.error('Error retrieving gatekeeper record', error);
          if (this.abortController.signal.aborted) return;
          this.gatewayCoreStore.setState((state) => {
            state.inputs.gatekeeperRecord.status = InputStatus.ERROR;
            state.inputs.gatekeeperRecord.error = error;
          });
        });
    };

    const retrieveGatewayToken = async () => {
      this.gatewayCoreStore.setState((state) => {
        state.inputs.gatewayToken.status = InputStatus.IN_PROGRESS;
      });
      return this.chainImplementation
        .findGatewayToken()
        .then((response) => {
          if (this.abortController.signal.aborted) return;
          this.gatewayCoreStore.setState((state) => {
            state.inputs.gatewayToken.status = InputStatus.COMPLETE;
            if (response) {
              state.inputs.gatewayToken.received = response;
            }
          });
        })
        .catch((error) => {
          if (this.abortController.signal.aborted) return;
          this.log.error('Error retrieving gateway token', error);
          this.gatewayCoreStore.setState((state) => {
            state.inputs.gatewayToken.status = InputStatus.ERROR;
            state.inputs.gatewayToken.error = error;
          });
        });
    };

    // call the gatekeeper unless the initial call is disabled
    const lookupFunctions = [retrieveGatewayToken()];
    if (!this.inputs.disableInitialGatekeeperLookup) {
      lookupFunctions.push(retrieveGKRecord());
    }
    // update on-chain state before and after
    // TODO handle results and set error state if necessary
    await Promise.allSettled(lookupFunctions);
  }

  async initialise() {
    this.log.debug('Initialising orchestrator');
    this.abortController = new AbortController();
    this.remoteSignInstance = undefined;
    this.gatewayCoreStore.getState().functions.reset();

    await Promise.allSettled([
      // The dids are exported as part of the computed flowParameters, but they are async on the chainImplementation,
      // so we fetch them here and set them on state so zustand-compute can get them synchronously.
      this.getOwnerDids(),
      this.lookupTokenState(),
      this.fetchGatekeeperNetworkData(),
    ]);
  }

  reset() {
    this.log.debug('resetting orchestrator');
    this.initialise();
  }

  onInternalStatusChange(status: InternalGatewayStatus | null, previousStatus?: InternalGatewayStatus | null) {
    if (status === GatewayStatus.ERROR) {
      const fullState = this.gatewayCoreStore.getState();
      if (tokenNoGatekeeperRecordError(fullState)) {
        this.gatewayCoreStore.setState((state) => {
          if (!state.internal.errors) {
            state.internal.errors = {};
          }
          state.internal.errors.expectedTokenGatekeeperRecord = new ChainError(
            'Token has no gatekeeper record',
            ErrorCode.EXPECTED_GATEKEEPER_RECORD
          );
        });
      }
      return;
    }
    if (status === GatewayStatus.ACTIVE) {
      // if the token has just turned active, finish the appropriate flow
      if (previousStatus !== GatewayStatus.ACTIVE) {
        this._refresh?.onActiveTokenFound();
        if (!this._refresh) {
          this._issuance?.onActiveTokenFound();
        }
      }
      return;
    }
    if (status === ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION) {
      return this.issuance.restartDataCollection();
    }
    if (status === GatewayStatus.USER_INFORMATION_VALIDATED) {
      return this.issuance.makeGatekeeperRequest({ payer: this.payer });
    }
    if (
      [
        ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX,
        ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
      ].includes(status as ExtendedGatewayStatus)
    ) {
      return this.issuance.makeGatekeeperRequest({ payer: this.payer, isFreshTransactionRequest: true });
    }
    if (
      [
        ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
        ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
      ].includes(status as ExtendedGatewayStatus)
    ) {
      return this.issuance.sendTransaction();
    }
    if (status === ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN) {
      return this.issuance.expectOnChainToken();
    }
    if (status === ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED) {
      return this.refresh.makeGatekeeperRequest({ payer: this.payer });
    }
    if (
      [
        ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX,
        ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
      ].includes(status as ExtendedGatewayStatus)
    ) {
      return this.refresh.makeGatekeeperRequest({ payer: this.payer, isFreshTransactionRequest: true });
    }
    if (status === ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND) {
      return this.refresh.sendTransaction();
    }
    if (status === ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN) {
      return this.refresh.expectOnChainToken();
    }

    if (status === ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW) {
      return this.partnerReview.pollForReviewFinished();
    }
    if (
      [ExtendedGatewayStatus.RESTART, ExtendedGatewayStatus.RESTART_REFRESH].includes(status as ExtendedGatewayStatus)
    ) {
      // Check if this does a record lookup. If it does a record lookupp,
      // The record lookup should update to the correct GT status
      return this.reset();
    }
  }

  orchestrate() {
    this.log.debug('running orchestrate()');
    this.gatewayCoreStore.subscribe(
      (state) => state.internal.status,
      (status, previousStatus) => this.onInternalStatusChange(status, previousStatus)
    );

    // handle the expiry changing on the gateway token: if it's increased, reset the force refresh flag
    this.gatewayCoreStore.subscribe(
      (state) => state.inputs.gatewayToken.received?.expiryTime,
      (expiryTime, previousExpiryTime) => {
        if (expiryTime && previousExpiryTime && expiryTime > previousExpiryTime) {
          this.gatewayCoreStore.setState((state) => {
            if (state.inputs.dynamicParameters?.forceRequireRefresh !== undefined) {
              state.inputs.dynamicParameters.forceRequireRefresh = false;
            }
          });
        }
      }
    );
    // handle specific user interactions from civicPass, like user finishing flows
    this.gatewayCoreStore.subscribe(
      (state) => state.inputs.civicPass.received,
      (civicPass) => {
        return this.gatewayCoreStore.setState((state) => {
          const userIteractionStatus = getUserInteractionStatusFromAction(
            state,
            civicPass?.action as CivicPassMessageAction
          );
          state.internal.userInteraction.status = userIteractionStatus;
        });
      }
    );

    this.listenerManager.registerCivicPassListener((response) => {
      this.gatewayCoreStore.setState((state) => {
        state.inputs.civicPass.status = InputStatus.COMPLETE;
        state.inputs.civicPass.received = response;
      });
    });

    this.listenerManager.registerCivicSignListener((response) => {
      this.gatewayCoreStore.setState((state) => {
        state.inputs.civicSign.status = InputStatus.RECEIVED;
        state.inputs.civicSign.received = response;
      });
      const ownerDids = this.gatewayCoreStore.getState().internal.ownerDids;
      handleRemoteSignEvent(response, this.getRemoteSignInstance(), {
        chainImplementation: this.chainImplementation,
        wallet: this.wallet,
        ownerDids: ownerDids as DID[],
      })
        .then((result) => {
          if (!result) {
            this.log.warn('No result from remote sign event');
          }
          this.gatewayCoreStore.setState((draft) => {
            draft.inputs.civicSign.received = null;
            draft.inputs.civicSign.sent = result;
            draft.inputs.civicSign.error = null;
            draft.inputs.civicSign.status = InputStatus.RESPONDED;
          });
        })
        .catch((error) => {
          // If the error does not have an errorCode default to POWO_ERROR,
          this.gatewayCoreStore.setState((draft) => {
            const useError = !!error.errorCode
              ? error
              : new ChainError('handleRemoteSignEvent failed', ErrorCode.POWO_ERROR);
            draft.inputs.civicSign.error = useError;
            draft.inputs.civicSign.status = InputStatus.ERROR;
          });
        });
    });

    this.listenerManager.registerOnChainListeners((gatewayToken: GatewayToken): void => {
      this.gatewayCoreStore.setState((state) => {
        state.inputs.gatewayToken.received = gatewayToken;
      });
    });
  }

  abort() {
    this.log.info('Aborting orchestration');
    this.chainImplementation.onDestroy();
    this._issuance?.abort();
    this._refresh?.abort();
    this._partnerReview?.abort();
    this.abortController.abort();
    this.gatekeeperClient.abort();
    this.listenerManager.unregisterAllListeners();
  }
}

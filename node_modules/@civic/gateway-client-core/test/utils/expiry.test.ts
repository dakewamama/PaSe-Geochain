import chai from 'chai';
import { getTokenRefreshIntervalMilliseconds, hasExpired, isTokenRefreshRequired } from '../../src/utils/expiry';
import { GatewayToken, State } from '../../src/types/chain';

const { expect } = chai;

describe('expiry', () => {
  describe('hasExpired', () => {
    it('should return false if expiryTime is not set', () => {
      expect(hasExpired(0)).to.be.false;
    });

    it('should return true if expiryTime is in the past', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(hasExpired(now - 1)).to.be.true;
    });

    it('should return false if expiryTime is in the future', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(hasExpired(now + 1)).to.be.false;
    });
  });

  describe('isTokenRefreshRequired', () => {
    it('should return false if gatewayToken is not set', () => {
      expect(isTokenRefreshRequired({ tokenExpirationMarginSeconds: 0 })).to.be.false;
    });

    it('should return false if gatewayToken is not active', () => {
      expect(
        isTokenRefreshRequired({
          gatewayToken: { expiryTime: 0, state: State.FROZEN } as GatewayToken,
          tokenExpirationMarginSeconds: 0,
        })
      ).to.be.false;
    });

    it('should return false if expiryTime is not set', () => {
      expect(
        isTokenRefreshRequired({
          gatewayToken: { expiryTime: 0, state: State.ACTIVE } as GatewayToken,
          tokenExpirationMarginSeconds: 0,
        })
      ).to.be.false;
    });

    it('should return true if forceRequireRefresh is set', () => {
      expect(
        isTokenRefreshRequired({
          gatewayToken: { expiryTime: 1, state: State.ACTIVE } as GatewayToken,
          tokenExpirationMarginSeconds: 0,
          forceRequireRefresh: true,
        })
      ).to.be.true;
    });

    it('should return true if expiryTime has expired', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(
        isTokenRefreshRequired({
          gatewayToken: { expiryTime: now - 1, state: State.ACTIVE } as GatewayToken,
          tokenExpirationMarginSeconds: 0,
        })
      ).to.be.true;
    });

    it('should return true if expiryTime is approaching', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(
        isTokenRefreshRequired({
          gatewayToken: { expiryTime: now + 1, state: State.ACTIVE } as GatewayToken,
          tokenExpirationMarginSeconds: 1,
        })
      ).to.be.true;
    });

    it('should return false if expiryTime is not approaching', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(
        isTokenRefreshRequired({
          gatewayToken: { expiryTime: now + 3, state: State.ACTIVE } as GatewayToken,
          tokenExpirationMarginSeconds: 2,
        })
      ).to.be.false;
    });
  });

  describe('getTokenRefreshIntervalMilliseconds', () => {
    it('should return 0 if interval is negative', () => {
      expect(getTokenRefreshIntervalMilliseconds(0, 1)).to.equal(0);
    });

    it('should return the interval in milliseconds', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(getTokenRefreshIntervalMilliseconds(now + 11, 1)).to.equal(10 * 1000);
    });

    it('should return the maximum allowed timeout if interval is too large', () => {
      const now = Math.floor(Date.now() / 1000);
      expect(getTokenRefreshIntervalMilliseconds(now + 100000000, 1)).to.equal(2147483646);
    });
  });
});

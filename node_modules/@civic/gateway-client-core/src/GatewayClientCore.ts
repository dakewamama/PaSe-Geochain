import { v4 as uuid } from 'uuid';
import { ClientCoreInput } from './types/clientCore';
import { prefixLogger } from './logger';
import { Orchestrator } from './orchestrate';
import { createGatewayCoreStore, Store } from './state/state';
import { ClientCoreOutput, GatewayClientCoreInterface, GatewayInput } from './types/gatewayCore';
import { getPayer } from './utils/inputs';
import { UserInteractionStatus } from './types/userInteraction';
import { DynamicGatewayClientParameters, GatewayClientParameters } from './types/parameters';
import { DEFAULT_LOG_LEVEL, LoggingInterface } from './logger/provider.logger';
import { ChainDetails } from './types/chain';
import { UIManager } from './ui';
import { UIInput } from './types/ui';
import * as R from 'ramda';
import { GknData } from './gatekeeperNetworkService';

export const getInstanceInputObject = (input: ClientCoreInput | undefined): InstanceInputObject =>
  input
    ? {
        ...input.parameters,
        ...input.chainImplementation?.chainDetails,
      }
    : ({} as InstanceInputObject);

export const shouldUpdateInstance = (inputs: ClientCoreInput, instance: GatewayClientCore | undefined): boolean =>
  !instance || !R.equals(getInstanceInputObject(instance.inputs), getInstanceInputObject(inputs));

export const hasRequiredInputs = (inputs: ClientCoreInput): boolean =>
  !!(inputs.parameters.wallet?.address && inputs.chainImplementation);

export const getInstanceName = (inputs: ClientCoreInput, instanceId: string) =>
  `gcc_${inputs.parameters.wallet?.address?.substring(0, 4)}_${inputs.parameters?.gatekeeperNetwork?.substring(0, 4)}_${
    inputs.chainImplementation?.chainDetails?.chainType
  }_${inputs.chainImplementation?.chainDetails?.chainNetwork}_${instanceId.substring(0, 4)}`;

export type InstanceInputObject = GatewayClientParameters & ChainDetails;

export class GatewayClientCore implements GatewayClientCoreInterface {
  private orchestratorInst: Orchestrator;

  private uiInst: UIManager;

  static currentInstance: GatewayClientCore | undefined;

  private gatewayCoreStore: Store;

  public instanceId: string;

  private log: LoggingInterface;

  constructor(readonly inputs: ClientCoreInput) {
    this.instanceId = uuid();
    this.log = prefixLogger(`Core instance: ${this.instanceId}`);
    this.log?.setLogLevel?.(inputs.parameters?.options?.logLevel || DEFAULT_LOG_LEVEL);
    this.log.info('GatewayClientCore created', { inputs });
    this.gatewayCoreStore = createGatewayCoreStore({
      name: getInstanceName(inputs, this.instanceId),
      store: 'gateway-client-core',
    });
    this.log.info('GatewayClientCore gatewayCoreStore created', this.gatewayCoreStore);

    this.gatewayCoreStore.subscribe(
      (state) => state.output,
      (output) => {
        this.log.debug('GatewayClientCore output changed', output);
        inputs.onOutputChange(R.clone(output) as ClientCoreOutput);
      }
    );

    this.orchestratorInst = new Orchestrator(
      this.gatewayCoreStore,
      inputs.messageEventInterface,
      this.instanceId,
      inputs.parameters,
      inputs.fetchConfig,
      inputs.postMessageTargetCallback,
      inputs.chainImplementation
    );

    // ensure that the inputs get cloned and not mutated
    this.gatewayCoreStore.setState((state) => {
      state.inputs.parameters = R.clone({ ...inputs.parameters, payer: getPayer(inputs.parameters) });
      state.internal.chainDetails = R.clone(inputs.chainImplementation.chainDetails);
      state.inputs.dynamicParameters = R.clone(inputs.dynamicParameters);
      state.internal.instanceId = this.instanceId;
    });

    this.orchestratorInst.orchestrate();
    this.orchestratorInst.initialise();

    this.uiInst = new UIManager(this.gatewayCoreStore);
  }

  public static getSingleInstance(inputs: ClientCoreInput): GatewayClientCore | undefined {
    const logger = prefixLogger('GatewayClientCore.getSingleInstance');
    if (!hasRequiredInputs(inputs)) {
      logger.debug(
        'Missing wallet address or chain implementation, aborting previous and setting to undefined',
        inputs
      );
      GatewayClientCore.currentInstance?.abort();
      GatewayClientCore.currentInstance = undefined;
      return undefined;
    }

    if (shouldUpdateInstance(inputs, GatewayClientCore.currentInstance)) {
      logger.debug('Inputs have changed, aborting previous and creating a new instance', inputs);
      GatewayClientCore.currentInstance?.abort();
      GatewayClientCore.currentInstance = new GatewayClientCore(inputs);
    }
    return GatewayClientCore.currentInstance;
  }

  updateDynamicParameters(dynamicParameters: DynamicGatewayClientParameters) {
    this.gatewayCoreStore.setState((state) => {
      state.internal.userInteraction.status = null;
      state.inputs.dynamicParameters = R.clone(dynamicParameters);
    });
  }

  updateGatekeeperNetworkServiceData(gknData: GatewayInput<GknData>) {
    this.gatewayCoreStore.setState((state) => {
      state.inputs.gatekeeperNetworkData = R.clone(gknData);
    });
  }

  startOrResumeFlow() {
    this.gatewayCoreStore.setState((state) => {
      state.internal.userInteraction.status = UserInteractionStatus.STARTED;
    });
  }

  abort() {
    this.log.info(`GatewayClientCore aborting`);
    this.orchestratorInst.abort();
  }

  get ui(): UIInput {
    return {
      onShow: () => this.uiInst.onShow(),
      onHide: () => this.uiInst.onHide(),
      onLoad: () => this.uiInst.onLoad(),
    };
  }
}

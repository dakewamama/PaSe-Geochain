{"version":3,"file":"zustand-computed-state.cjs.production.min.js","sources":["../src/index.ts","../src/utils.ts"],"sourcesContent":["import { StateCreator, StoreMutatorIdentifier } from 'zustand';\nimport { getAllGetters } from './utils';\n\nconst prefix = '$$_computed_';\ntype ComputeFunctionType<StoreType, T> = (store: StoreType) => T;\n\nfunction injectComputedMiddleware(f: StateCreator<any>): StateCreator<any> {\n  return (set, get, api) => {\n    function getComputedState(state: any) {\n      const computedFunctions = Object.entries(state)\n        .filter(([key]) => key.startsWith(prefix))\n        .map(s => s[1] as ComputeFunctionType<any, any>);\n\n      const computedSt = computedFunctions.reduce(\n        (acc, cur) => ({\n          ...acc,\n          ...cur(state),\n        }),\n        {}\n      );\n\n      return computedSt;\n    }\n    const setWithComputed = (\n      update: any | ((state: any) => any),\n      replace?: boolean\n    ) => {\n      set((state: any) => {\n        const updated = typeof update === 'object' ? update : update(state);\n        const newState = {\n          ...state,\n          ...updated,\n        };\n\n        return {\n          ...newState,\n          ...getComputedState(newState),\n        };\n      }, replace);\n    };\n\n    api.setState = setWithComputed;\n    const st = f(setWithComputed, get, api);\n\n    return Object.assign({}, st, getComputedState(st));\n  };\n}\n\nfunction withGetters(initialState: any) {\n  const getters = getAllGetters(initialState);\n  return (newState: any) => {\n    const result: any = {};\n\n    Object.keys(getters).forEach(key => {\n      result[key] = getters[key].bind(newState)();\n    });\n\n    return result;\n  };\n}\n\nexport function compute<StoreType>(\n  store: StoreType,\n  get?: never,\n  compute?: never\n): StoreType;\n\nexport function compute<StoreType, T extends Partial<StoreType>>(\n  id: string,\n  get: () => StoreType,\n  compute: ComputeFunctionType<StoreType, T>\n): T;\n\nexport function compute<StoreType, T extends Partial<StoreType>>(\n  get: () => StoreType,\n  compute: ComputeFunctionType<StoreType, T>,\n  id?: never\n): T;\nexport function compute(\n  // @ts-ignore\n  getOrId: any,\n  getOrCompute: any,\n  computeOrUndefined: any\n) {\n  if (typeof getOrId === 'string') {\n    return {\n      [`${prefix}_${getOrId}`]: computeOrUndefined,\n    };\n  }\n\n  if (typeof getOrId === 'object') {\n    return {\n      ...getOrId,\n      [prefix]: withGetters(getOrId),\n    };\n  }\n\n  return {\n    [prefix]: getOrCompute,\n  } as any;\n}\n\ntype ComputedState = <\n  T,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = []\n>(\n  f: StateCreator<T, Mps, Mcs>\n) => StateCreator<T, Mps, Mcs>;\n\nexport const computed = (((f: any) =>\n  injectComputedMiddleware(f as any) as any) as unknown) as ComputedState;\n","export function getAllGetters(obj: any) {\n  const getters: any = {};\n\n  // Iterate over all properties of the object itself (not its prototype chain)\n  Object.getOwnPropertyNames(obj).forEach(prop => {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n\n    // Check if the property has a getter\n    if (descriptor && typeof descriptor.get === 'function') {\n      getters[prop] = descriptor.get;\n    }\n  });\n\n  // Iterate over all properties of the object's prototype chain\n  let proto = Object.getPrototypeOf(obj);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(prop => {\n      const descriptor = Object.getOwnPropertyDescriptor(proto, prop);\n\n      // Check if the property has a getter\n      if (\n        descriptor &&\n        typeof descriptor.get === 'function' &&\n        !getters.hasOwnProperty(prop)\n      ) {\n        getters[prop] = descriptor.get;\n      }\n    });\n\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return getters;\n}\n"],"names":["prefix","getOrId","getOrCompute","computeOrUndefined","_ref2","_extends2","getters","_extends","obj","Object","getOwnPropertyNames","forEach","prop","descriptor","getOwnPropertyDescriptor","get","proto","getPrototypeOf","hasOwnProperty","getAllGetters","newState","result","keys","key","bind","_ref3","f","set","api","getComputedState","state","entries","filter","_ref","startsWith","map","s","reduce","acc","cur","setWithComputed","update","replace","setState","st","assign","injectComputedMiddleware"],"mappings":"uSAGA,IAAMA,EAAS,wCA6EbC,EACAC,EACAC,SAEiCC,EAMAC,EAzC3BC,EAmCN,MAAuB,iBAAZL,IACTG,MACMJ,MAAUC,GAAYE,EAAkBC,GAIzB,iBAAZH,EACTM,KACKN,IAAOI,MACTL,IA5CCM,WCjDsBE,GAC5B,IAAMF,EAAe,GAGrBG,OAAOC,oBAAoBF,GAAKG,SAAQ,SAAAC,GACtC,IAAMC,EAAaJ,OAAOK,yBAAyBN,EAAKI,GAGpDC,GAAwC,mBAAnBA,EAAWE,MAClCT,EAAQM,GAAQC,EAAWE,QAM/B,IADA,IAAIC,EAAQP,OAAOQ,eAAeT,GACjB,OAAVQ,GACLP,OAAOC,oBAAoBM,GAAOL,SAAQ,SAAAC,GACxC,IAAMC,EAAaJ,OAAOK,yBAAyBE,EAAOJ,GAIxDC,GAC0B,mBAAnBA,EAAWE,MACjBT,EAAQY,eAAeN,KAExBN,EAAQM,GAAQC,EAAWE,QAI/BC,EAAQP,OAAOQ,eAAeD,GAGhC,OAAOV,EDiBSa,CA4CUlB,GA3CnB,SAACmB,GACN,IAAMC,EAAc,GAMpB,OAJAZ,OAAOa,KAAKhB,GAASK,SAAQ,SAAAY,GAC3BF,EAAOE,GAAOjB,EAAQiB,GAAKC,KAAKJ,EAAlBd,MAGTe,IAoCyBhB,MAIlCoB,MACGzB,GAASE,EAAYuB,qBAYA,SAACC,GAAM,OAxGjC,SAAkCA,GAChC,OAAO,SAACC,EAAKZ,EAAKa,GAChB,SAASC,EAAiBC,GAaxB,OAZ0BrB,OAAOsB,QAAQD,GACtCE,QAAO,SAAAC,GAAK,OAAAA,KAAUC,WAAWlC,MACjCmC,KAAI,SAAAC,GAAC,OAAIA,EAAE,MAEuBC,QACnC,SAACC,EAAKC,GAAG,OAAAhC,KACJ+B,EACAC,EAAIT,MAET,IAKJ,IAAMU,EAAkB,SACtBC,EACAC,GAEAf,GAAI,SAACG,GACH,IACMV,EAAQb,KACTuB,EAF6B,iBAAXW,EAAsBA,EAASA,EAAOX,IAM7D,OAAAvB,KACKa,EACAS,EAAiBT,MAErBsB,IAGLd,EAAIe,SAAWH,EACf,IAAMI,EAAKlB,EAAEc,EAAiBzB,EAAKa,GAEnC,OAAOnB,OAAOoC,OAAO,GAAID,EAAIf,EAAiBe,KAmEhDE,CAAyBpB"}
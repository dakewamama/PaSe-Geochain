"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaChainImplementation = void 0;
/* eslint-disable max-classes-per-file */
const R = __importStar(require("ramda"));
const solana_gateway_ts_1 = require("@civic/solana-gateway-ts");
const web3_js_1 = require("@solana/web3.js");
const prove_solana_wallet_1 = require("@civic/prove-solana-wallet");
const gateway_client_core_1 = require("@civic/gateway-client-core");
const config_1 = require("./config");
const util_1 = require("./util");
const logDebug = (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation').debug;
const logWarn = (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation').warn;
const isUnsupportedOperationError = (error) => { var _a; return error.code === -32603 || ((_a = error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('unsupportedoperation')); };
// How long we will give confirmTransaction to return before assuming it's been dropped.
// We show a retry screen after 30 seconds (product-level decision) so we can't wait longer than that.
const SOLANA_DROPPED_TX_TIMEOUT_MS = 25000;
const createSignMessageProofIfSupported = async (proveTransactionFn, proveSignMessageFn) => {
    try {
        if (!proveSignMessageFn) {
            logDebug('createSignMessageProofIfSupported no signMessageFn passed, using proveTransactionFn...');
            const proof = await proveTransactionFn();
            logDebug('createSignMessageProofIfSupported proveTransactionFn successful', {
                proof,
                signatureMethod: gateway_client_core_1.SignatureMethod.TRANSACTION,
            });
            return { proof, signatureMethod: gateway_client_core_1.SignatureMethod.TRANSACTION };
        }
        logDebug('createSignMessageProofIfSupported signMessageFn exists, calling proveSignMessageFn...');
        const proof = await proveSignMessageFn();
        logDebug('createSignMessageProofIfSupported proveSignMessageFn successful', {
            proof,
            signatureMethod: gateway_client_core_1.SignatureMethod.MESSAGE,
        });
        return { proof, signatureMethod: gateway_client_core_1.SignatureMethod.MESSAGE };
    }
    catch (error) {
        const useError = error;
        logWarn('createSignMessageProofIfSupported error', { error, useError });
        if (isUnsupportedOperationError(useError)) {
            logDebug('error is an unsupported operation error, trying proveTransaction');
            const proof = await proveTransactionFn();
            logDebug('createSignMessageProofIfSupported proveTransactionFn successful', {
                proof,
                signatureMethod: gateway_client_core_1.SignatureMethod.TRANSACTION,
            });
            return { proof, signatureMethod: gateway_client_core_1.SignatureMethod.TRANSACTION };
        }
        throw error;
    }
};
class SolanaChainImplementation {
    constructor(inputs) {
        this.inputs = inputs;
        // We keep track of the listeners here, because they are registered in global state
        // of solana-gateway-ts and therefore should be removed when this object goes away.
        this.listeners = [];
        this.chainDetails = {
            chainType: gateway_client_core_1.ChainType.SOLANA,
            chainNetwork: inputs.cluster,
        };
    }
    async ownerDids() {
        return [`did:sol:${this.inputs.publicKey.toBase58()}`];
    }
    on(event, listener) {
        var _a;
        if (event === 'TOKEN_CREATED') {
            const newListener = (0, solana_gateway_ts_1.onGatewayToken)(this.inputs.connection, this.inputs.publicKey, this.inputs.gatekeeperNetworkAddress, (token) => {
                if (this.gatewayToken) {
                    // A token already existed before this callback fired.
                    // Don't call the TOKEN_CREATED listener. The TOKEN_CHANGED listener will be called in this case.
                    return;
                }
                this.gatewayToken = token;
                listener({
                    issuingGatekeeper: token.issuingGatekeeper.toBase58(),
                    gatekeeperNetworkAddress: token.gatekeeperNetwork.toBase58(),
                    owner: token.owner.toBase58(),
                    state: gateway_client_core_1.State[token.state],
                    identifier: token.publicKey.toBase58(),
                    expiryTime: token.expiryTime,
                });
            });
            this.listeners.push(newListener);
            return this;
        }
        if (event === 'TOKEN_CHANGED') {
            // If we don't have a gatewayToken yet, derive the token address from the wallet + gatekeeperNetwork combo.
            const gatewayTokenAddress = ((_a = this.gatewayToken) === null || _a === void 0 ? void 0 : _a.publicKey.toBase58()) ||
                (0, solana_gateway_ts_1.getGatewayTokenAddressForOwnerAndGatekeeperNetwork)(this.inputs.publicKey, this.inputs.gatekeeperNetworkAddress);
            const newListener = (0, solana_gateway_ts_1.onGatewayTokenChange)(this.inputs.connection, new web3_js_1.PublicKey(gatewayTokenAddress), (token) => {
                listener({
                    issuingGatekeeper: token.issuingGatekeeper.toBase58(),
                    gatekeeperNetworkAddress: token.gatekeeperNetwork.toBase58(),
                    owner: token.owner.toBase58(),
                    state: gateway_client_core_1.State[token.state],
                    identifier: token.publicKey.toBase58(),
                    expiryTime: token.expiryTime,
                });
            });
            this.listeners.push(newListener);
            return this;
        }
        return this;
    }
    async findGatewayToken() {
        const { connection, publicKey, gatekeeperNetworkAddress } = this.inputs;
        const onChainToken = await (0, solana_gateway_ts_1.findGatewayToken)(connection, publicKey, new web3_js_1.PublicKey(gatekeeperNetworkAddress), true);
        if (!onChainToken)
            return undefined;
        return {
            issuingGatekeeper: onChainToken.issuingGatekeeper.toBase58(),
            gatekeeperNetworkAddress: onChainToken.gatekeeperNetwork.toBase58(),
            owner: onChainToken.owner.toBase58(),
            state: gateway_client_core_1.State[onChainToken.state],
            identifier: onChainToken.publicKey.toBase58(),
            expiryTime: onChainToken.expiryTime,
        };
    }
    async proveWalletOwnership(message) {
        const { publicKey, signMessage, signTransaction, connection, cluster } = this.inputs;
        try {
            logDebug('proveWalletOwnership', { message });
            const proveSignMessageFn = signMessage && message ? () => (0, prove_solana_wallet_1.create)((input) => signMessage(Buffer.from(input)), message) : undefined;
            const proveTransactionFn = () => (0, prove_solana_wallet_1.proveTransaction)(publicKey, signTransaction, (0, config_1.makeConfig)(connection.rpcEndpoint, cluster)).then((proveTxResult) => proveTxResult.toString('base64'));
            const response = await createSignMessageProofIfSupported(proveTransactionFn, proveSignMessageFn);
            logDebug('proveWalletOwnership', response);
            return response;
        }
        catch (error) {
            const parsedError = error;
            logDebug('proveWalletOwnership', {
                error,
                errorMessage: parsedError.message,
                parsedErrorCode: (0, util_1.parseTransactionErrorCode)(parsedError),
                useErrorCode: gateway_client_core_1.ErrorCode.POWO_ERROR,
            });
            throw new gateway_client_core_1.ChainError(parsedError.message, gateway_client_core_1.ErrorCode.POWO_ERROR);
        }
    }
    async signMessage(message) {
        const { signMessage } = this.inputs;
        if (!signMessage) {
            throw new gateway_client_core_1.ChainError('signMessage not implemented');
        }
        return signMessage(message);
    }
    async handleTransaction(partiallySignedTx, frontendPollingTimeoutSeconds) {
        const { handleTransaction, signTransaction } = this.inputs;
        logDebug('handleUserSignedTransaction, user-provided handleTransaction', !!handleTransaction);
        const transaction = (0, util_1.createSolanaTransactionFromBase64)(partiallySignedTx);
        if (handleTransaction) {
            logDebug('custom handleTransaction function present, calling now...');
            return handleTransaction(transaction).catch((error) => {
                throw new gateway_client_core_1.ChainError(error.message, gateway_client_core_1.ErrorCode.CUSTOM_HANDLE_TRANSACTION_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
            });
        }
        let transactionToSend = transaction;
        if (this.requiresSignature(transaction)) {
            transactionToSend = await signTransaction(transaction).catch((error) => {
                throw new gateway_client_core_1.ChainError(error.message, (0, util_1.parseTransactionErrorCode)(error), (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
            });
        }
        const frontendPollingTimeoutMs = frontendPollingTimeoutSeconds
            ? frontendPollingTimeoutSeconds * 1000
            : SOLANA_DROPPED_TX_TIMEOUT_MS;
        return this.submitTransaction(transactionToSend, frontendPollingTimeoutMs).catch((error) => {
            if (error instanceof gateway_client_core_1.ChainError) {
                // submitTransaction threw a granular ChainError. Re-throw it.
                throw error;
            }
            // A different error was thrown from submitTransaction which we could not handle. Throw a generic SEND_TRANSACTION_ERROR
            throw new gateway_client_core_1.ChainError(error.message, gateway_client_core_1.ErrorCode.SEND_TRANSACTION_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
        });
    }
    requiresSignature(transaction) {
        return transaction.signatures.find((sig) => sig.publicKey.equals(this.inputs.publicKey)) !== undefined;
    }
    // eslint-disable-next-line class-methods-use-this
    handleTxSendError(err) {
        // Tx failed to send. Try to parse a specific error like 'insufficient funds'. Otherwise just throw a generic SEND_TRANSACTION_ERROR.
        const parsedErrorCode = (0, util_1.parseTransactionErrorCode)(err);
        if (err instanceof web3_js_1.SendTransactionError || parsedErrorCode !== gateway_client_core_1.ErrorCode.SIGN_TRANSACTION_UNKNOWN_ERROR) {
            throw new gateway_client_core_1.ChainError(err.message, parsedErrorCode, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
        }
        // Tx rejected by the RPC or simulation failed for an unknown reason.
        throw new gateway_client_core_1.ChainError(`sendRawTransaction failed ${err === null || err === void 0 ? void 0 : err.message}`, gateway_client_core_1.ErrorCode.SEND_TRANSACTION_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
    }
    async handleTxConfirmError(txSig, confirmTxErr, frontendPollingTimeoutMs) {
        var _a;
        const { connection } = this.inputs;
        if (confirmTxErr instanceof gateway_client_core_1.ChainError) {
            // We already determined a granular error case for this.
            throw confirmTxErr;
        }
        if (confirmTxErr instanceof util_1.TimeoutError) {
            // confirmTransaction timed out. Check the tx status to see if it's been dropped.
            const sigStatusResponse = await connection.getSignatureStatuses([txSig]);
            const sigStatus = (_a = sigStatusResponse === null || sigStatusResponse === void 0 ? void 0 : sigStatusResponse.value) === null || _a === void 0 ? void 0 : _a[0];
            if (!sigStatus) {
                // The tx has been dropped.
                throw new gateway_client_core_1.ChainError(`confirmTransaction timed out after ${frontendPollingTimeoutMs} ms and tx not found on-chain`, gateway_client_core_1.ErrorCode.TRANSACTION_DROPPED_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
            }
            // For some reason confirmTransaction timed out even though the tx was actually confirmed.
            if (sigStatus.err) {
                // Tx failed on-chain.
                throw new gateway_client_core_1.ChainError(`Transaction failed on-chain ${sigStatus.err.toString()}`, gateway_client_core_1.ErrorCode.TRANSACTION_FAILED_ON_CHAIN_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
            }
            // Tx succeeded.
            return txSig;
        }
        // confirmTransaction threw a different error.
        throw new gateway_client_core_1.ChainError(`confirmTransaction threw an error: ${confirmTxErr === null || confirmTxErr === void 0 ? void 0 : confirmTxErr.message}`, gateway_client_core_1.ErrorCode.TRANSACTION_CONFIRMATION_UNKNOWN_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
    }
    async submitTransaction(transaction, frontendPollingTimeoutMs) {
        const { connection } = this.inputs;
        let txSig = '';
        try {
            const serialized = transaction.serialize();
            txSig = await connection.sendRawTransaction(serialized);
            // Store the tx hash so we can emit it in an analytics event if the user closes the tab at this point.
            this.pendingTransaction = txSig;
        }
        catch (err) {
            this.pendingTransaction = undefined;
            this.handleTxSendError(err);
        }
        // override connection commitment as we will poll/listen for confirmation of the token being created/refreshed
        const blockhash = await connection.getLatestBlockhash('processed');
        try {
            const confirmationResponse = await (0, util_1.raceWithTimeout)(() => connection.confirmTransaction(Object.assign(Object.assign({}, blockhash), { signature: txSig }), 'processed'), frontendPollingTimeoutMs);
            this.pendingTransaction = undefined;
            if (confirmationResponse.value.err) {
                // Tx failed on-chain.
                throw new gateway_client_core_1.ChainError(`Transaction failed on-chain ${confirmationResponse.value.err.toString()}`, gateway_client_core_1.ErrorCode.TRANSACTION_FAILED_ON_CHAIN_ERROR, (0, gateway_client_core_1.prefixLogger)('SolanaChainImplementation'));
            }
            // Tx confirmed (reached 'processed' commitment).
            return txSig;
        }
        catch (confirmTxErr) {
            this.pendingTransaction = undefined;
            return this.handleTxConfirmError(txSig, confirmTxErr, frontendPollingTimeoutMs);
        }
    }
    async onDestroy() {
        const promises = this.listeners
            .filter(R.complement(R.isNil))
            .map((listener) => (0, solana_gateway_ts_1.removeAccountChangeListener)(this.inputs.connection, listener));
        await Promise.all(promises);
        this.listeners = [];
        this.pendingTransaction = undefined;
    }
}
exports.SolanaChainImplementation = SolanaChainImplementation;

import { expect } from 'chai';
import sinon, { SinonStub, SinonStubbedInstance } from 'sinon';
import { ListenerManager } from '../src/listeners';
import LogLocal from '../src/logger/local.logger';
import { MessageEventInterface } from '../src/types/eventInterface';
import { CivicPassMessageAction } from '../src/types/civicPass';
import { ChainClientInterface } from '../src/types/chain';

const sandbox = sinon.createSandbox();
describe('ListenerManager', () => {
  let messageEventInterface: SinonStubbedInstance<MessageEventInterface>;
  let log: SinonStubbedInstance<LogLocal>;
  let listenerManager: ListenerManager;
  let mockResponse: { data: any };
  let chainImplementationStub: SinonStubbedInstance<ChainClientInterface>;

  afterEach(sandbox.restore);

  beforeEach(() => {
    messageEventInterface = {
      addMessageEventListener: sandbox.stub(),
      removeMessageEventListener: sandbox.stub(),
    } as SinonStubbedInstance<MessageEventInterface>;
    log = sandbox.createStubInstance(LogLocal);

    chainImplementationStub = {
      on: sandbox.stub(),
    } as SinonStubbedInstance<ChainClientInterface>;

    listenerManager = new ListenerManager(messageEventInterface, chainImplementationStub, 'testInstance', log);

    mockResponse = {
      data: {
        instanceId: 'testInstance',
        source: '',
        payload: {},
      },
    };
  });

  context('registerCivicPassListener', () => {
    it('should register a handler for the civic pass events', () => {
      const onMessage = sinon.spy();
      listenerManager.registerCivicPassListener(onMessage);
      expect(messageEventInterface.addMessageEventListener.calledOnce).to.be.true;
      const handler = messageEventInterface.addMessageEventListener.getCall(0).args[0];
      expect(handler).to.be.a('function');
    });

    context('with a message with no action', () => {
      beforeEach(() => {
        mockResponse = {
          data: {
            instanceId: 'testInstance',
            source: '',
            payload: {},
          },
        };
      });
      it('should not call onMessage', async () => {
        const onMessage = sinon.spy();
        listenerManager.registerCivicPassListener(onMessage);

        // Retrieve the handler directly from where it was registered
        const handler = messageEventInterface.addMessageEventListener.getCall(0).args[0];

        await handler(mockResponse);
        expect(onMessage.callCount).to.eq(0);
      });
    });

    context('with a message with a civic-pass action', () => {
      beforeEach(() => {
        mockResponse = {
          data: {
            instanceId: 'testInstance',
            source: '',
            action: CivicPassMessageAction.AWAITING_TRANSACTION_CONFIRMATION,
            payload: {},
          },
        };
      });
      it('should process the message correctly when instance ID matches', async () => {
        const onMessage = sinon.spy();
        listenerManager.registerCivicPassListener(onMessage);

        // Retrieve the handler directly from where it was registered
        const handler = messageEventInterface.addMessageEventListener.getCall(0).args[0];

        // Simulate invoking the handler with the correct instance ID
        handler(mockResponse);
        expect(onMessage.calledOnce).to.be.true;
        expect(onMessage.calledWith(mockResponse.data)).to.be.true;
      });
    });

    it('should ignore messages with a different instance ID', async () => {
      const onMessage = sinon.spy();
      listenerManager.registerCivicPassListener(onMessage);

      // Simulate receiving a message with a different instance ID
      mockResponse.data.instanceId = 'wrongInstance';
      const handler = listenerManager.messageListeners.civicPass;
      handler(mockResponse);
      expect(onMessage.notCalled).to.be.true;
    });

    it('should log an error if no data is present in the response', async () => {
      const onMessage = sinon.spy();
      listenerManager.registerCivicPassListener(onMessage);
      const handler = listenerManager.messageListeners.civicPass;
      handler({}); // Pass an empty response object
      expect(log.error.calledWith('No data in response')).to.be.true;
    });
  });

  describe('registerOnChainListeners', () => {
    let callbackStub: SinonStub;

    beforeEach(() => {
      callbackStub = sandbox.stub();
    });

    it('should call "on()" on chain adapter for TOKEN_CREATED and TOKEN_CHANGED', () => {
      chainImplementationStub.on?.returns('test-chain-implementation' as unknown as ChainClientInterface);
      listenerManager.registerOnChainListeners(callbackStub);
      expect(chainImplementationStub.on).to.have.been.calledTwice;
      expect(chainImplementationStub.on).to.have.been.calledWith('TOKEN_CREATED', callbackStub);
      expect(chainImplementationStub.on).to.have.been.calledWith('TOKEN_CHANGED', callbackStub);
    });
  });

  describe('unregisterAllListeners', () => {
    it('should call messageEventInterface remove for all registered listeners', () => {
      listenerManager.registerCivicPassListener(() => {});
      listenerManager.unregisterAllListeners();
      expect(messageEventInterface.removeMessageEventListener.calledOnce).to.be.true;
    });
    it('should remove all registered listeners from listeners object', () => {
      listenerManager.registerCivicPassListener(() => {});
      listenerManager.unregisterAllListeners();
      expect(listenerManager.messageListeners).to.deep.equal({});
    });
  });
});

import { FlowStatus, FlowType } from '../types/flow';
import { v4 as uuid } from 'uuid';
import { ExtendedGatewayStatus, GatewayStatus, InternalGatewayStatus } from '../types/gateway';
import { GatewayCoreState } from '../types/gatewayCore';
import { UserInteractionStatus } from '../types/userInteraction';
import { isTokenRefreshRequired } from './expiry';

export const DEFAULT_FLOW_ID_PREFIX = 'GWC';
/**
 * This derives the current flow type from the existing state and the next, computed state:
 * - if we have a gateway token, we check if a refresh is required and return REFRESH if so
 * - if we have a gateway token and the token is active but the previous flowId includes REFRESH, we return REFRESH
 * so that the 'active' event gets included as part of the flow
 * - if we have a gateway token and the token is active and the previous flowId includes ISSUANCE, we return ISSUANCE
 * so that the 'active' event gets included as part of the flow
 * - if we have a gateway token and the token is active but there was no previous issuance or refresh flow, we return STATUS
 * as the user has not started any flow yet
 * - in the case where no gateway token is present, we assume ISSUANCE, except for the initialisation state where the gatewayStatus
 * is UNKNOWN or CHECKING, in which case we return STATUS
 * @param {GatewayCoreState} state
 * @param {InternalGatewayStatus} computedInternalStatus
 * @returns {FlowType}
 */
export const flowTypeFromState = (state: GatewayCoreState, computedInternalStatus: InternalGatewayStatus): FlowType => {
  if (state.inputs.gatewayToken?.received) {
    const tokenRefreshRequired = isTokenRefreshRequired({
      gatewayToken: state.inputs.gatewayToken?.received,
      tokenExpirationMarginSeconds: 0,
      forceRequireRefresh: state.inputs?.dynamicParameters?.forceRequireRefresh,
    });
    if (
      tokenRefreshRequired ||
      state.internal.status?.toLowerCase().includes('refresh') ||
      computedInternalStatus.toLowerCase().includes('refresh')
    ) {
      return FlowType.REFRESH;
    }

    // handle the case where we find an ACTIVE token following the issuance flow
    if (state.output?.flowParameters?.flowId.toLowerCase().includes(FlowType.REFRESH.toLowerCase())) {
      return FlowType.REFRESH;
    }

    // handle the case where we find an ACTIVE token following the issuance flow
    if (state.output?.flowParameters?.flowId.toLowerCase().includes(FlowType.ISSUANCE.toLowerCase())) {
      return FlowType.ISSUANCE;
    }
    return FlowType.STATUS;
  }

  if ([GatewayStatus.CHECKING, GatewayStatus.UNKNOWN].includes(computedInternalStatus as GatewayStatus)) {
    return FlowType.STATUS;
  }
  // issuance is the default flow type when we don't have a gateway token
  return FlowType.ISSUANCE;
};

/**
 * Creates or returns a flowId based on the action and state: we only want to generate
 * a new flowId if we're changing flow types
 * @param action
 * @param state
 * @returns
 */
export const getFlowId = (state: GatewayCoreState, computedInternalStatus: InternalGatewayStatus): string => {
  const existingFlowId = state.output?.flowParameters?.flowId;
  const flowType = flowTypeFromState(state, computedInternalStatus);
  // we only want to set a default flowId prefix if a flowId hasn't been set
  const prefix = `${flowType}_`;
  return !existingFlowId || existingFlowId === '' || !existingFlowId.includes(prefix)
    ? `${state.inputs.parameters?.flowIdPrefix || DEFAULT_FLOW_ID_PREFIX}_${prefix}${uuid()}`
    : existingFlowId;
};

export const initialFlowResultStatuses: InternalGatewayStatus[] = [
  GatewayStatus.REFRESH_TOKEN_REQUIRED,
  GatewayStatus.FROZEN,
  GatewayStatus.REVOKED,
  GatewayStatus.ERROR,
];

export const flowResultsStatuses: InternalGatewayStatus[] = [
  GatewayStatus.ACTIVE,
  GatewayStatus.REFRESH_TOKEN_REQUIRED,
  GatewayStatus.FROZEN,
  GatewayStatus.REVOKED,
  GatewayStatus.ERROR,
];

export const flowStatusFromState = (
  state: GatewayCoreState,
  computedInternalStatus: InternalGatewayStatus
): FlowStatus | undefined => {
  if (!state.internal?.userInteraction) {
    return undefined;
  }

  // Change to a result status if:
  // - the previous status was CHECKING (no flow has run yet) and the new status is one of the initialFlowResultStatuses
  // - the previous status was not CHECKING (a flow has been run) and the new status is one of the flowResultsStatuses
  // and the previous status was not one of the flowResultsStatuses
  const previousStatus = state.internal.status as InternalGatewayStatus;
  if (
    (previousStatus === GatewayStatus.CHECKING && initialFlowResultStatuses.includes(computedInternalStatus)) ||
    (previousStatus !== GatewayStatus.CHECKING &&
      flowResultsStatuses.includes(computedInternalStatus) &&
      !flowResultsStatuses.includes(previousStatus)) ||
    (previousStatus === GatewayStatus.ACTIVE && state.inputs?.dynamicParameters?.forceRequireRefresh)
  ) {
    if (state.inputs.gatekeeperNetworkData?.received?.client?.tokenActiveDisplay === 'hidden') {
      // If the network is configured to not show the token active screen, we skip the RESULT state and go directly to FINISHED.
      // state.internal.userInteraction will then be updated to null so the below checks return FINISHED instead of IN-PROGRESS
      return FlowStatus.FINISHED;
    }
    return FlowStatus.RESULT;
  }

  if (state.internal?.userInteraction.status === UserInteractionStatus.FINISHED) {
    return FlowStatus.FINISHED;
  }

  if (
    previousStatus === GatewayStatus.ACTIVE &&
    state.inputs.gatekeeperNetworkData?.received?.client?.tokenActiveDisplay === 'hidden' &&
    state.internal?.userInteraction?.status === null
  ) {
    // If the network is configured to not show the token active screen and the flow status was set to FINISHED above
    // there are still subsequent calls to flowStatusFromState so we need to handle them and keep returning FINISHED
    return FlowStatus.FINISHED;
  }

  // If the user validation failed, it should be handled as a finished flow and close the iframe
  if (computedInternalStatus === ExtendedGatewayStatus.USER_VALIDATION_FAILED) {
    return FlowStatus.FINISHED;
  }

  if (state.internal?.userInteraction.status === UserInteractionStatus.STARTED) {
    return FlowStatus.IN_PROGRESS;
  }

  return state.output?.flowState?.status;
};

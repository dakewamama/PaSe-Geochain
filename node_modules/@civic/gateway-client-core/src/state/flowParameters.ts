import { FlowParameters, GatewayCoreState } from '../types/gatewayCore';
import { GatewayStatus, InternalGatewayStatus } from '../types/gateway';
import { gatewayStatusToCivicPassAction } from './stateMapping';
import { flowTypeFromState, getFlowId } from '../utils/flow';
import { ChainError } from '../utils/errors';
import { payerIsWalletOwner } from './common';
import { isEmptyObject } from '../utils/object';
// version.ts is auto-generated from package.json by running 'yarn generate-version',
// currently done on postinstall and prebuild.
import { VERSION as CORE_VERSION } from '../../src/version';

export const computeFlowParameters = (
  state: GatewayCoreState,
  computedInternalStatus: InternalGatewayStatus
): FlowParameters | null => {
  if (
    !(state.inputs.parameters?.wallet && state.internal.chainDetails?.chainType && state.internal?.instanceId) ||
    [GatewayStatus.UNKNOWN, GatewayStatus.CHECKING].includes(computedInternalStatus as GatewayStatus)
  ) {
    return null;
  }

  // errors can be on civicSign or gatekeeperRecord
  const errorCode =
    state.internal.errors?.expectedTokenGatekeeperRecord?.errorCode ||
    (state.internal.chainTransaction?.error as ChainError)?.errorCode ||
    (state.inputs.gatekeeperRecord?.received?.errorCode as string | undefined) ||
    (state.inputs.gatekeeperRecord?.received?.payload?.errorCode as string | undefined) ||
    (state.inputs.civicSign?.error as ChainError)?.errorCode;
  const action = gatewayStatusToCivicPassAction[computedInternalStatus];
  const flowId = getFlowId(state, computedInternalStatus);
  const payload = isEmptyObject(state.inputs.gatekeeperRecord?.received?.payload)
    ? undefined
    : JSON.stringify(state.inputs.gatekeeperRecord?.received?.payload);
  const ownerSigns = !state.inputs.parameters.gatekeeperSendsTransaction && payerIsWalletOwner(state);

  return {
    // computed
    action,
    flowId,
    ownerSigns,
    errorCode,
    flowType: flowTypeFromState(state, computedInternalStatus),

    ...(payload ? { payload } : {}),
    // from parameters
    // TODO consider not returning these and just adding them in the gateway-client-react
    redirectUrl: state.inputs.parameters?.redirectUrl,
    networkAddress: state.inputs.parameters?.gatekeeperNetwork,
    wallet: state.inputs.parameters.wallet.address,
    chain: state.internal.chainDetails?.chainType,
    chainNetwork: state.internal.chainDetails?.chainNetwork,
    did: state.internal.ownerDids?.[0],
    gatekeeperSendsTransaction: state.inputs.parameters.gatekeeperSendsTransaction,
    partnerAppId: state.inputs.parameters.partnerAppId,
    referrer: state.inputs.parameters.referrer,
    domain: state.inputs.parameters.domain,
    instanceId: state.internal.instanceId,
    // Never hide POWO screens in cases where the owner pays. For 3rd party pays, it's configurable by the integrator
    hideWalletPrompts:
      state.inputs.parameters.payer && state.inputs.parameters.payer !== state.inputs.parameters.wallet.address
        ? state.inputs.parameters.options?.hideWalletPrompts
        : undefined,

    // from gatekeeper record response
    signedTx: state.internal?.chainTransaction?.sentTxId,
    // So the iframe can include the client-version in analytics events it sends.
    civicClient: state.inputs?.parameters?.xCivicClientHeader || CORE_VERSION,
    stage: state.inputs?.parameters?.stage,
  };
};

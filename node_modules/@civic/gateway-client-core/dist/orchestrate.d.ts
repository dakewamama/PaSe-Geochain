import { ListenerManager } from './listeners';
import { MessageEventInterface, PostMessageTargetCallback } from './types/eventInterface';
import { FetchConfig } from './types/fetch';
import { GatekeeperClient } from './gatekeeperClient';
import { ChainClientInterface } from './types/chain';
import { WalletAdapter } from './types/parameters';
import { InternalGatewayStatus } from './types/gateway';
import { RemoteSignWindowEventEmitter } from './remoteSign';
import { OrchestratorInputs } from './types/orchestrate';
import { Store } from './state/state';
export declare class Orchestrator {
    readonly gatewayCoreStore: Store;
    readonly messageEventInterface: MessageEventInterface;
    readonly instanceId: string;
    readonly inputs: OrchestratorInputs;
    readonly postMessageTargetCallback: PostMessageTargetCallback;
    readonly chainImplementation: ChainClientInterface;
    readonly listenerManager: ListenerManager;
    readonly gatekeeperClient: GatekeeperClient;
    readonly payer: string | undefined;
    readonly wallet: WalletAdapter;
    remoteSignInstance: RemoteSignWindowEventEmitter | undefined;
    private log;
    private abortController;
    private _issuance;
    private _refresh;
    private _partnerReview;
    constructor(gatewayCoreStore: Store, messageEventInterface: MessageEventInterface, instanceId: string, inputs: OrchestratorInputs, fetchConfig: FetchConfig, postMessageTargetCallback: PostMessageTargetCallback, chainImplementation: ChainClientInterface);
    private get issuance();
    private get refresh();
    private get partnerReview();
    getRemoteSignInstance(): RemoteSignWindowEventEmitter;
    getOwnerDids(): Promise<void>;
    fetchGatekeeperNetworkData(): Promise<void>;
    lookupTokenState(): Promise<void>;
    initialise(): Promise<void>;
    reset(): void;
    onInternalStatusChange(status: InternalGatewayStatus | null, previousStatus?: InternalGatewayStatus | null): void | Promise<void>;
    orchestrate(): void;
    abort(): void;
}

import { Transaction } from '@solana/web3.js';
import { ErrorCode, prefixLogger } from '@civic/gateway-client-core';
const logger = prefixLogger('SolanaChainImplementation');
export const createSolanaTransactionFromBase64 = (partiallySignedTx) => Transaction.from(Buffer.from(partiallySignedTx, 'base64'));
const insufficientFundsMessages = ['insufficient funds', 'custom program error: 0x1'];
const isClientWalletFundsError = (error) => {
    if (insufficientFundsMessages.map((msg) => { var _a; return (_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(msg); }).includes(true)) {
        return true;
    }
    return false;
};
// error: WalletSignMessageError
const isWalletSignMessageError = (error) => {
    var _a, _b;
    return !!(((_a = error === null || error === void 0 ? void 0 : error.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('walletsignmessageerror')) ||
        ((_b = error === null || error === void 0 ? void 0 : error.message) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes('walletsignmessageerror')));
};
// error: WalletSignMessageError: User rejected the request
const isUserRejectedError = (error) => {
    var _a;
    return !!((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('user rejected'));
};
export const parseTransactionErrorCode = (error) => {
    if (isClientWalletFundsError(error)) {
        logger.warn('parseTransactionErrorCode - INSUFFICIENT_FUNDS error detected', error);
        return ErrorCode.INSUFFICIENT_FUNDS;
    }
    if (isUserRejectedError(error)) {
        logger.warn('parseTransactionErrorCode - SIGN_TRANSACTION_USER_REJECTED_ERROR error detected', error);
        return ErrorCode.SIGN_TRANSACTION_USER_REJECTED_ERROR;
    }
    if (isWalletSignMessageError(error)) {
        logger.warn('parseTransactionErrorCode - SIGN_TRANSACTION_ERROR error detected', error);
        return ErrorCode.SIGN_TRANSACTION_ERROR;
    }
    return ErrorCode.SIGN_TRANSACTION_UNKNOWN_ERROR;
};
export class TimeoutError extends Error {
    constructor() {
        super('TimeoutError');
        Object.setPrototypeOf(this, TimeoutError.prototype); // required for instance checking
    }
}
export const errorOnTimeout = (timeoutMs) => new Promise((_resolve, reject) => setTimeout(() => {
    reject(new TimeoutError());
}, timeoutMs));
export const raceWithTimeout = async (fn, timeoutMs) => Promise.race([errorOnTimeout(timeoutMs), fn()]);

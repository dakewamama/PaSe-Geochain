import { UserInteractionStatus } from '../../src/types/userInteraction';
import { ExtendedGatewayStatus, FlowStatus, FlowType, GatewayCoreState, GatewayStatus } from '../../src';
import { nowSeconds } from '../../src/utils/expiry';
import {
  flowResultsStatuses,
  flowStatusFromState,
  flowTypeFromState,
  getFlowId,
  initialFlowResultStatuses,
} from '../../src/utils/flow';
import chai from 'chai';

const { expect } = chai;
describe('flow utils', () => {
  context('flowTypeFromState', () => {
    context('with a gatewayToken', () => {
      context('with a gatewayToken that is not expired', () => {
        context('where internal status includes refresh', () => {
          it('should return REFRESH', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
              internal: {
                status: GatewayStatus.REFRESH_TOKEN_REQUIRED,
              },
              output: {
                flowParameters: {
                  flowId: 'REFRESH_1234',
                },
              },
            } as unknown as GatewayCoreState;
            const computedInternalStatus = GatewayStatus.ACTIVE;
            // Act
            const result = flowTypeFromState(state, computedInternalStatus);
            // Assert
            expect(result).to.equal(FlowType.REFRESH);
          });
        });

        context('where the computedInternalStatus includes refresh', () => {
          it('should return REFRESH', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
              internal: {
                status: ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
              },
              output: {
                flowParameters: {
                  flowId: 'REFRESH_1234',
                },
              },
            } as GatewayCoreState;
            const computedInternalStatus = GatewayStatus.REFRESH_TOKEN_REQUIRED;
            // Act
            const result = flowTypeFromState(state, computedInternalStatus);
            // Assert
            expect(result).to.equal(FlowType.REFRESH);
          });
        });

        context('where the existing flowId contains refresh', () => {
          it('should return REFRESH', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
              internal: {
                status: ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
              },
              output: {
                flowParameters: {
                  flowId: 'REFRESH_1234',
                },
              },
            } as GatewayCoreState;
            const computedInternalStatus = GatewayStatus.ACTIVE;
            // Act
            const result = flowTypeFromState(state, computedInternalStatus);
            // Assert
            expect(result).to.equal(FlowType.REFRESH);
          });
        });

        context('where the existing flowId contains issuance', () => {
          it('should return ISSUANCE', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
              internal: {
                status: GatewayStatus.IN_REVIEW,
              },
              output: {
                flowParameters: {
                  flowId: 'ISSUANCE_1234',
                },
              },
            } as GatewayCoreState;
            const computedInternalStatus = GatewayStatus.ACTIVE;
            // Act
            const result = flowTypeFromState(state, computedInternalStatus);
            // Assert
            expect(result).to.equal(FlowType.ISSUANCE);
          });
        });

        context('with a flowId that does not contain refresh or issuance', () => {
          it('should return STATUS', () => {
            // Arrange
            const state = {
              inputs: {
                gatewayToken: {
                  received: {
                    expiryTime: nowSeconds() + 1000,
                    state: 'ACTIVE',
                  },
                },
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
              internal: {
                status: GatewayStatus.IN_REVIEW,
              },
              output: {
                flowParameters: {
                  flowId: 'STATUS_1234',
                },
              },
            } as GatewayCoreState;
            const computedInternalStatus = GatewayStatus.ACTIVE;
            // Act
            const result = flowTypeFromState(state, computedInternalStatus);
            // Assert
            expect(result).to.equal(FlowType.STATUS);
          });
        });
      });

      context('with a gatewayToken that is expired', () => {
        it('should return REFRESH', () => {
          // Arrange
          const state = {
            inputs: {
              gatewayToken: {
                received: {
                  expiryTime: nowSeconds() - 1000,
                  state: 'ACTIVE',
                },
              },
              dynamicParameters: {
                forceRequireRefresh: false,
              },
            },
            internal: {
              status: GatewayStatus.IN_REVIEW,
            },
            output: {
              flowParameters: {
                flowId: 'REFRESH_1234',
              },
            },
          } as GatewayCoreState;
          const computedInternalStatus = GatewayStatus.ACTIVE;
          // Act
          const result = flowTypeFromState(state, computedInternalStatus);
          // Assert
          expect(result).to.equal(FlowType.REFRESH);
        });
      });
    });

    context('with no gatewayToken', () => {
      context('status flows', () => {
        [GatewayStatus.CHECKING, GatewayStatus.UNKNOWN].forEach((status) => {
          it(`should return STATUS for a gatewayStatus of ${status}`, () => {
            // Arrange
            const state = {
              inputs: {
                dynamicParameters: {
                  forceRequireRefresh: false,
                },
              },
              internal: {
                status: GatewayStatus.ERROR,
              },
            } as GatewayCoreState;
            const computedInternalStatus = status;
            // Act
            const result = flowTypeFromState(state, computedInternalStatus);
            // Assert
            expect(result).to.equal(FlowType.STATUS);
          });
        });
      });

      context('default issuance flow', () => {
        it('should return ISSUANCE', () => {
          // Arrange
          const state = {
            inputs: {
              dynamicParameters: {
                forceRequireRefresh: false,
              },
            },
            internal: {
              status: GatewayStatus.ACTIVE,
            },
          } as GatewayCoreState;
          const computedInternalStatus = GatewayStatus.ACTIVE;
          // Act
          const result = flowTypeFromState(state, computedInternalStatus);
          // Assert
          expect(result).to.equal(FlowType.ISSUANCE);
        });
      });
    });
  });

  context('getFlowId', () => {
    context('with an existing flowId', () => {
      context('if the flowType is still the same', () => {
        it('should return the existing flowId', () => {
          // Arrange
          const state = {
            inputs: {
              gatewayToken: null,
            },
            output: {
              flowParameters: {
                flowId: 'GWC_issuance_1234',
              },
            },
          } as unknown as GatewayCoreState;
          const computedInternalStatus = GatewayStatus.ACTIVE;
          // Act
          const result = getFlowId(state, computedInternalStatus);
          // Assert
          expect(result).to.equal('GWC_issuance_1234');
        });
      });

      context('if the flow type changes', () => {
        it('should return a new flowId with the new flowType', () => {
          // Arrange
          const state = {
            inputs: {
              gatewayToken: {
                received: {
                  expiryTime: nowSeconds() + 1000,
                  state: 'ACTIVE',
                },
              },
            },
            internal: {
              status: GatewayStatus.ACTIVE,
            },
            output: {
              flowParameters: {
                flowId: 'GWC_issuance_1234',
              },
            },
          } as unknown as GatewayCoreState;
          const computedInternalStatus = GatewayStatus.REFRESH_TOKEN_REQUIRED;
          // Act
          const result = getFlowId(state, computedInternalStatus);
          // Assert
          expect(result).to.contain('GWC_refresh_');
        });
      });
    });
  });

  context('flowStatusFromState', () => {
    context('with no userInteraction in internal state', () => {
      it('should return undefined', () => {
        expect(
          flowStatusFromState({ internal: { someOtherValue: 42 } } as unknown as GatewayCoreState, GatewayStatus.ACTIVE)
        ).to.be.undefined;
      });
    });
    context('with userInteraction status STARTED', () => {
      it('should return IN_PROGRESS', () => {
        expect(
          flowStatusFromState(
            { internal: { userInteraction: { status: UserInteractionStatus.STARTED } } } as unknown as GatewayCoreState,
            GatewayStatus.COLLECTING_USER_INFORMATION
          )
        ).to.equal(FlowStatus.IN_PROGRESS);
      });
    });

    context('RESULT status', () => {
      context('with previous status CHECKING', () => {
        initialFlowResultStatuses.forEach((status) => {
          it(`should return RESULT for status ${status}`, () => {
            expect(
              flowStatusFromState(
                {
                  inputs: {
                    gatekeeperNetworkData: {
                      client: {
                        tokenActiveDisplay: 'default',
                      },
                    },
                  },
                  internal: {
                    status: GatewayStatus.CHECKING,
                    userInteraction: { status: UserInteractionStatus.STARTED },
                  },
                } as unknown as GatewayCoreState,
                status
              )
            ).to.equal(FlowStatus.RESULT);
          });
        });
      });

      context('with previous status not CHECKING', () => {
        context('with computedInternalStatus in result statuses', () => {
          flowResultsStatuses.forEach((status) => {
            context('with previous status not in result statuses', () => {
              it('should return RESULT', () => {
                expect(
                  flowStatusFromState(
                    {
                      inputs: {
                        gatekeeperNetworkData: {
                          client: {
                            tokenActiveDisplay: 'default',
                          },
                        },
                      },
                      internal: {
                        status: GatewayStatus.COLLECTING_USER_INFORMATION,
                        userInteraction: { status: UserInteractionStatus.STARTED },
                      },
                      output: {
                        flowState: {
                          status: FlowStatus.IN_PROGRESS,
                        },
                      },
                    } as unknown as GatewayCoreState,
                    status
                  )
                ).to.equal(FlowStatus.RESULT);
              });
            });

            context('with previous state in result statuses', () => {
              context('with no dynamicParameters', () => {
                it('should return the existing state', () => {
                  expect(
                    flowStatusFromState(
                      {
                        inputs: {
                          gatekeeperNetworkData: {
                            client: {
                              tokenActiveDisplay: 'default',
                            },
                          },
                        },
                        internal: {
                          status: status,
                          userInteraction: { status: UserInteractionStatus.STARTED },
                        },
                        output: {
                          flowState: {
                            status: FlowStatus.IN_PROGRESS,
                          },
                        },
                      } as unknown as GatewayCoreState,
                      status
                    )
                  ).to.equal(FlowStatus.IN_PROGRESS);
                });
              });

              context('with dynamicParameters forceRequireRefresh set to true', () => {
                context('with previousStatus ACTIVE', () => {
                  it('should return RESULT', () => {
                    expect(
                      flowStatusFromState(
                        {
                          internal: {
                            status: GatewayStatus.ACTIVE,
                            userInteraction: { status: UserInteractionStatus.STARTED },
                          },
                          inputs: {
                            dynamicParameters: {
                              forceRequireRefresh: true,
                            },
                          },
                          output: {
                            flowState: {
                              status: FlowStatus.IN_PROGRESS,
                            },
                          },
                        } as unknown as GatewayCoreState,
                        GatewayStatus.ACTIVE
                      )
                    ).to.equal(FlowStatus.RESULT);
                  });

                  it('should return FINISHED if GKN is configured to hide token active screen', () => {
                    expect(
                      flowStatusFromState(
                        {
                          internal: {
                            status: GatewayStatus.ACTIVE,
                            userInteraction: { status: UserInteractionStatus.STARTED },
                          },
                          inputs: {
                            dynamicParameters: {
                              forceRequireRefresh: true,
                            },
                            gatekeeperNetworkData: {
                              status: 'COMPLETE',
                              received: {
                                client: {
                                  tokenActiveDisplay: 'hidden',
                                },
                              },
                            },
                          },
                          output: {
                            flowState: {
                              status: FlowStatus.IN_PROGRESS,
                            },
                          },
                        } as unknown as GatewayCoreState,
                        GatewayStatus.ACTIVE
                      )
                    ).to.equal(FlowStatus.FINISHED);
                  });

                  it('should return FINISHED if GKN is configured to hide token active screen, forceRequireRefresh is false and UserInteractionStatus is null', () => {
                    expect(
                      flowStatusFromState(
                        {
                          internal: {
                            status: GatewayStatus.ACTIVE,
                            userInteraction: { status: null },
                          },
                          inputs: {
                            dynamicParameters: {
                              forceRequireRefresh: false,
                            },
                            gatekeeperNetworkData: {
                              status: 'COMPLETE',
                              received: {
                                client: {
                                  tokenActiveDisplay: 'hidden',
                                },
                              },
                            },
                          },
                          output: {
                            flowState: {
                              status: FlowStatus.IN_PROGRESS,
                            },
                          },
                        } as unknown as GatewayCoreState,
                        GatewayStatus.ACTIVE
                      )
                    ).to.equal(FlowStatus.FINISHED);
                  });
                });

                context('with previous status not ACTIVE', () => {
                  it('should return existing state', () => {
                    expect(
                      flowStatusFromState(
                        {
                          internal: {
                            status: GatewayStatus.IN_REVIEW,
                            userInteraction: { status: UserInteractionStatus.STARTED },
                          },
                          inputs: {
                            dynamicParameters: {
                              forceRequireRefresh: true,
                            },
                          },
                          output: {
                            flowState: {
                              status: FlowStatus.IN_PROGRESS,
                            },
                          },
                        } as unknown as GatewayCoreState,
                        GatewayStatus.COLLECTING_USER_INFORMATION
                      )
                    ).to.equal(FlowStatus.IN_PROGRESS);
                  });
                });
              });
            });
          });
        });
      });
    });
    context('with userInteraction status FINISHED', () => {
      it('should return FINISHED', () => {
        expect(
          flowStatusFromState(
            {
              internal: { userInteraction: { status: UserInteractionStatus.FINISHED } },
            } as unknown as GatewayCoreState,
            GatewayStatus.COLLECTING_USER_INFORMATION
          )
        ).to.equal(FlowStatus.FINISHED);
      });
    });
  });
});

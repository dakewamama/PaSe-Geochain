import { prefixLogger } from './logger';
import { ChainClientInterface, DID, ProveWalletOwnershipResponse, SignatureMethod } from './types/chain';
import {
  CivicSignEventTypeRequest,
  CivicSignEventTypeRequestMessage,
  CivicSignEventTypeResponse,
  RemoteSign,
} from './types/civicSign';
import { ErrorWithCode } from './types/errors';
import { PostMessageInterface } from './types/eventInterface';
import { WalletAdapter } from './types/parameters';
import { ChainError, ErrorCode } from './utils/errors';

const logDebug = prefixLogger('remoteSign').debug;
const logError = prefixLogger('remoteSign').error;
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
export interface EventEmitter {
  postMessage: (message: unknown, targetOrigin: string) => void;
}

export const eventEmitter = (postMessageTarget: PostMessageInterface): EventEmitter => {
  return {
    postMessage: (message: unknown, targetOrigin: string) => {
      postMessageTarget.postMessage(message, targetOrigin);
    },
  };
};

export type RemoteError = {
  request: CivicSignEventTypeRequest;
  error: ErrorWithCode;
};
export class RemoteSignWindowEventEmitter implements RemoteSign {
  private postMessageTarget: EventEmitter;

  constructor(postMessageTarget: EventEmitter, readonly instanceId: string) {
    this.postMessageTarget = postMessageTarget;
  }

  public sendPublicKey(requestId: string, publicKey: string) {
    this.emit({
      event: CivicSignEventTypeResponse.RESPONSE_PUBLIC_KEY,
      data: publicKey,
      requestId,
    });
  }

  public sendDid(requestId: string, did: string) {
    this.emit({
      event: CivicSignEventTypeResponse.RESPONSE_DID,
      data: did,
      requestId,
    });
  }

  public sendSignedProof(requestId: string, proof: string, signatureMethod: SignatureMethod) {
    this.emit({
      event: CivicSignEventTypeResponse.RESPONSE_SIGNED_PROOF,
      data: { proof, signatureMethod },
      requestId,
    });
  }

  public sendSignedMessage(requestId: string, message: Uint8Array) {
    this.emit({
      event: CivicSignEventTypeResponse.RESPONSE_SIGNED_MESSAGE,
      data: message,
      requestId,
    });
  }

  public sendError(requestId: string, request: CivicSignEventTypeRequest, error: Error | ChainError) {
    this.emit({
      event: CivicSignEventTypeResponse.RESPONSE_ERROR,
      requestId,
      data: {
        request,
        error: {
          message: error.message,
          code: (error as ChainError)?.errorCode,
        },
      },
    });
  }

  private emit(event: any) {
    this.postMessageTarget.postMessage({ ...event, instanceId: this.instanceId }, '*');
  }
}

export const handleRemoteSignEvent = async (
  message: CivicSignEventTypeRequestMessage,
  remoteSignerInst: RemoteSignWindowEventEmitter,
  inputs: { wallet: WalletAdapter; chainImplementation: ChainClientInterface; ownerDids?: DID[] }
): Promise<string | ProveWalletOwnershipResponse | Uint8Array | undefined | RemoteError> => {
  const { wallet, chainImplementation } = inputs;

  try {
    const ownerDids = inputs.ownerDids || (await chainImplementation.ownerDids());
    logDebug(`handleRemoteSignEvent ${message.request}`, {
      remoteSignerInst,
      wallet,
      chainImplDids: ownerDids,
    });
    if (!Object.values(CivicSignEventTypeRequest).includes(message.request)) {
      logError('No result from remote sign event');
      return;
    }
    if (message.request === CivicSignEventTypeRequest.REQUEST_PUBLIC_KEY) {
      remoteSignerInst?.sendPublicKey(message.requestId, wallet.address);
      return wallet.address;
    }
    if (message.request === CivicSignEventTypeRequest.REQUEST_DID) {
      remoteSignerInst?.sendDid(message.requestId, ownerDids?.[0]);
      return ownerDids?.[0];
    }
    if (message.request === CivicSignEventTypeRequest.REQUEST_SIGNED_PROOF) {
      const powoResponse = await chainImplementation.proveWalletOwnership(message.payload as string);
      remoteSignerInst?.sendSignedProof(message.requestId, powoResponse.proof, powoResponse.signatureMethod);
      return { proof: powoResponse.proof, signatureMethod: powoResponse.signatureMethod };
    }
    if (message.request === CivicSignEventTypeRequest.REQUEST_SIGNED_MESSAGE) {
      if (message.payload) {
        if (!chainImplementation.signMessage) {
          throw new Error('Chain implementation does not support signMessage');
        }
        const signMessageResponse = await chainImplementation.signMessage?.(Buffer.from(message.payload));
        remoteSignerInst?.sendSignedMessage(message.requestId, signMessageResponse);
        return signMessageResponse;
      }
    }
  } catch (error) {
    const code = (error as ChainError).errorCode || (error as ErrorWithCode).code || ErrorCode.POWO_ERROR;
    const useError = new ChainError(error.message, `${code}`);
    logError(`Error handling remote sign event, sending back an error response with code ${code}`, useError);
    remoteSignerInst?.sendError(message.requestId, message.request, useError);
    return {
      request: message.request,
      error: useError,
    };
  }
};

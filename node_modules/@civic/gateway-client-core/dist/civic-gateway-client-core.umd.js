(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@civic/gateway-client-core"] = {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var fetchRetry = function (fetch, defaults) {
      defaults = defaults || {};
      if (typeof fetch !== 'function') {
        throw new ArgumentError('fetch must be a function');
      }

      if (typeof defaults !== 'object') {
        throw new ArgumentError('defaults must be an object');
      }

      if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {
        throw new ArgumentError('retries must be a positive integer');
      }

      if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {
        throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');
      }

      if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {
        throw new ArgumentError('retryOn property expects an array or function');
      }

      var baseDefaults = {
        retries: 3,
        retryDelay: 1000,
        retryOn: [],
      };

      defaults = Object.assign(baseDefaults, defaults);

      return function fetchRetry(input, init) {
        var retries = defaults.retries;
        var retryDelay = defaults.retryDelay;
        var retryOn = defaults.retryOn;

        if (init && init.retries !== undefined) {
          if (isPositiveInteger(init.retries)) {
            retries = init.retries;
          } else {
            throw new ArgumentError('retries must be a positive integer');
          }
        }

        if (init && init.retryDelay !== undefined) {
          if (isPositiveInteger(init.retryDelay) || (typeof init.retryDelay === 'function')) {
            retryDelay = init.retryDelay;
          } else {
            throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');
          }
        }

        if (init && init.retryOn) {
          if (Array.isArray(init.retryOn) || (typeof init.retryOn === 'function')) {
            retryOn = init.retryOn;
          } else {
            throw new ArgumentError('retryOn property expects an array or function');
          }
        }

        // eslint-disable-next-line no-undef
        return new Promise(function (resolve, reject) {
          var wrappedFetch = function (attempt) {
            // As of node 18, this is no longer needed since node comes with native support for fetch:
            /* istanbul ignore next */
            var _input =
              typeof Request !== 'undefined' && input instanceof Request
                ? input.clone()
                : input;
            fetch(_input, init)
              .then(function (response) {
                if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {
                  resolve(response);
                } else if (typeof retryOn === 'function') {
                  try {
                    // eslint-disable-next-line no-undef
                    return Promise.resolve(retryOn(attempt, null, response))
                      .then(function (retryOnResponse) {
                        if(retryOnResponse) {
                          retry(attempt, null, response);
                        } else {
                          resolve(response);
                        }
                      }).catch(reject);
                  } catch (error) {
                    reject(error);
                  }
                } else {
                  if (attempt < retries) {
                    retry(attempt, null, response);
                  } else {
                    resolve(response);
                  }
                }
              })
              .catch(function (error) {
                if (typeof retryOn === 'function') {
                  try {
                    // eslint-disable-next-line no-undef
                    Promise.resolve(retryOn(attempt, error, null))
                      .then(function (retryOnResponse) {
                        if(retryOnResponse) {
                          retry(attempt, error, null);
                        } else {
                          reject(error);
                        }
                      })
                      .catch(function(error) {
                        reject(error);
                      });
                  } catch(error) {
                    reject(error);
                  }
                } else if (attempt < retries) {
                  retry(attempt, error, null);
                } else {
                  reject(error);
                }
              });
          };

          function retry(attempt, error, response) {
            var delay = (typeof retryDelay === 'function') ?
              retryDelay(attempt, error, response) : retryDelay;
            setTimeout(function () {
              wrappedFetch(++attempt);
            }, delay);
          }

          wrappedFetch(0);
        });
      };
    };

    function isPositiveInteger(value) {
      return Number.isInteger(value) && value >= 0;
    }

    function ArgumentError(message) {
      this.name = 'ArgumentError';
      this.message = message;
    }

    var fetchBuilder = /*@__PURE__*/getDefaultExportFromCjs(fetchRetry);

    var objectToURLParams = function (obj) {
        return obj
            ? Object.entries(obj).reduce(function (a, _a) {
                var _b;
                var k = _a[0], v = _a[1];
                if (v === undefined ||
                    v === null ||
                    (v instanceof Array && v.length === 0) ||
                    (v instanceof Object && Object.keys(v).length === 0) ||
                    v === '') {
                    return a;
                }
                return __assign(__assign({}, a), (_b = {}, _b[k] = v.toString(), _b));
            }, {})
            : {};
    };

    var LogLevel;
    (function (LogLevel) {
        LogLevel["DEBUG"] = "debug";
        LogLevel["INFO"] = "info";
        LogLevel["WARN"] = "warn";
        LogLevel["ERROR"] = "error";
    })(LogLevel || (LogLevel = {}));

    var logLevels = [LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR];
    var allowLogging = function (atLeastlogLevel, logLevel) {
        return logLevels.indexOf(logLevel) >= logLevels.indexOf(atLeastlogLevel);
    };
    var DEFAULT_LOG_LEVEL = LogLevel.INFO;
    var LoggingProvider = (function () {
        function LoggingProvider(logger, logLevel) {
            if (logLevel === void 0) { logLevel = DEFAULT_LOG_LEVEL; }
            this.logger = logger;
            this.logLevel = logLevel;
        }
        LoggingProvider.prototype.setLogLevel = function (logLevel) {
            this.logLevel = logLevel;
        };
        LoggingProvider.prototype.debug = function (message, object) {
            if (allowLogging(this.logLevel, LogLevel.DEBUG))
                this.logger.debug(message, object);
        };
        LoggingProvider.prototype.info = function (message, object) {
            if (allowLogging(this.logLevel, LogLevel.INFO))
                this.logger.info(message, object);
        };
        LoggingProvider.prototype.warn = function (message, object) {
            if (allowLogging(this.logLevel, LogLevel.WARN))
                this.logger.warn(message, object);
        };
        LoggingProvider.prototype.error = function (message, exception) {
            if (allowLogging(this.logLevel, LogLevel.ERROR))
                this.logger.error(message, exception);
        };
        return LoggingProvider;
    }());

    var consoleWithOptionalObject = function (method, message, object) {
        if (object) {
            method(message, object);
        }
        else {
            method(message);
        }
    };
    var LogLocal = (function (_super) {
        __extends(LogLocal, _super);
        function LogLocal(logLevel) {
            if (logLevel === void 0) { logLevel = DEFAULT_LOG_LEVEL; }
            return _super.call(this, console, logLevel) || this;
        }
        LogLocal.prototype.setLogLevel = function (logLevel) {
            this.logLevel = logLevel;
        };
        LogLocal.prototype.debug = function (message, object) {
            consoleWithOptionalObject(this.logger.debug, message, object);
        };
        LogLocal.prototype.info = function (message, object) {
            consoleWithOptionalObject(this.logger.info, message, object);
        };
        LogLocal.prototype.warn = function (message, object) {
            consoleWithOptionalObject(this.logger.warn, message, object);
        };
        LogLocal.prototype.error = function (message, exception) {
            consoleWithOptionalObject(this.logger.error, message, exception);
        };
        return LogLocal;
    }(LoggingProvider));

    var localLogger = new LoggingProvider(new LogLocal());
    var prefixDebug = function (prefix, globalPrefix) {
        return function (message, obj) {
            if (obj === void 0) { obj = null; }
            return localLogger.debug("[".concat(globalPrefix, "][").concat(prefix, "] ").concat(message), obj);
        };
    };
    var prefixError = function (prefix, globalPrefix) {
        return function (message, obj) {
            if (obj === void 0) { obj = null; }
            return localLogger.error("[".concat(globalPrefix, "][").concat(prefix, "] ").concat(message), obj);
        };
    };
    var prefixWarn = function (prefix, globalPrefix) {
        return function (message, obj) {
            if (obj === void 0) { obj = null; }
            return localLogger.warn("[".concat(globalPrefix, "][").concat(prefix, "] ").concat(message), obj);
        };
    };
    var prefixInfo = function (prefix, globalPrefix) {
        return function (message, obj) {
            if (obj === void 0) { obj = null; }
            return localLogger.info("[".concat(globalPrefix, "][").concat(prefix, "] ").concat(message), obj);
        };
    };
    var prefixLogger = function (prefix, globalPrefix) {
        if (globalPrefix === void 0) { globalPrefix = 'GatewayClientCore'; }
        return {
            setLogLevel: function (logLevel) { var _a; return (_a = localLogger === null || localLogger === void 0 ? void 0 : localLogger.setLogLevel) === null || _a === void 0 ? void 0 : _a.call(localLogger, logLevel); },
            debug: prefixDebug(prefix, globalPrefix),
            error: prefixError(prefix, globalPrefix),
            warn: prefixWarn(prefix, globalPrefix),
            info: prefixInfo(prefix, globalPrefix),
        };
    };

    var GatekeeperAPIStatus;
    (function (GatekeeperAPIStatus) {
        GatekeeperAPIStatus[GatekeeperAPIStatus["REQUESTING"] = 0] = "REQUESTING";
        GatekeeperAPIStatus[GatekeeperAPIStatus["NOT_REQUESTED"] = 404] = "NOT_REQUESTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["REQUESTED"] = 202] = "REQUESTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["ISSUED"] = 200] = "ISSUED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["ISSUED_EXPIRY_APPROACHING"] = 205] = "ISSUED_EXPIRY_APPROACHING";
        GatekeeperAPIStatus[GatekeeperAPIStatus["ISSUED_EXPIRED"] = 426] = "ISSUED_EXPIRED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["LOCATION_NOT_SUPPORTED"] = 401] = "LOCATION_NOT_SUPPORTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["REJECTED"] = 403] = "REJECTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["VPN_NOT_SUPPORTED"] = 421] = "VPN_NOT_SUPPORTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["ISSUED_LOCATION_NOT_SUPPORTED"] = 412] = "ISSUED_LOCATION_NOT_SUPPORTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["ISSUED_VPN_NOT_SUPPORTED"] = 451] = "ISSUED_VPN_NOT_SUPPORTED";
        GatekeeperAPIStatus[GatekeeperAPIStatus["SERVER_FAILURE"] = 500] = "SERVER_FAILURE";
        GatekeeperAPIStatus[GatekeeperAPIStatus["REQUESTED_RETRIES_EXHAUSTED"] = 408] = "REQUESTED_RETRIES_EXHAUSTED";
    })(GatekeeperAPIStatus || (GatekeeperAPIStatus = {}));

    var GATEKEEPER_BASE_ENDPOINTS = {
        local: "http://localhost:3001/local",
        test: "https://dev-gatekeeper-api.civic.com",
        dev: "https://dev-gatekeeper-api.civic.com",
        preprod: "https://preprod-gatekeeper-api.civic.com",
        prod: "https://gatekeeper-api.civic.com",
    };
    var logDebug$2 = prefixLogger('GatekeeperClient').debug;
    var logWarn = prefixLogger('GatekeeperClient').warn;
    var logError$3 = prefixLogger('GatekeeperClient').error;
    var getGatekeeperEndpoint = function (stage, chainType) {
        var baseUrl = GATEKEEPER_BASE_ENDPOINTS[stage];
        if (!baseUrl) {
            logWarn("No Gatekeeper endpoint for stage ".concat(stage, " . Using dev endpoint."));
            baseUrl = GATEKEEPER_BASE_ENDPOINTS.dev;
        }
        return "".concat(baseUrl, "/v1/token/").concat(chainType);
    };
    var withoutUndefined = function (obj) {
        return Object.fromEntries(Object.entries(obj).filter(function (_a) {
            var v = _a[1];
            return v !== undefined;
        }));
    };
    var GatekeeperClient = (function () {
        function GatekeeperClient(initConfig, flowId) {
            var _this = this;
            this.initConfig = initConfig;
            this.abortController = initConfig.abortController;
            this.baseUrl = initConfig.baseUrl || getGatekeeperEndpoint(initConfig.stage, initConfig.chainType);
            this.queryParams = initConfig.queryParams;
            this.headers = objectToURLParams(__assign(__assign({}, initConfig.headers), { 'x-civic-flowid': flowId }));
            this.fetchImplementation = initConfig.fetchImplementation;
            var retries = initConfig.numRetries;
            this.defaultRetryParams = {
                retries: retries,
                retryOn: function (attempt, error, response) { return __awaiter(_this, void 0, void 0, function () {
                    var body, _a;
                    var _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                if (!response) return [3, 2];
                                return [4, response.clone().json()];
                            case 1:
                                _a = _c.sent();
                                return [3, 3];
                            case 2:
                                _a = {};
                                _c.label = 3;
                            case 3:
                                body = _a;
                                if (response && response.status >= 500) {
                                    if ((_b = body === null || body === void 0 ? void 0 : body.message) === null || _b === void 0 ? void 0 : _b.includes('NO_AUTO_RETRY')) {
                                        return [2, false];
                                    }
                                    if (attempt >= retries) {
                                        logError$3('retryOn error run out of retries', { error: error, attempt: attempt, retries: retries, response: response, body: body });
                                        throw error;
                                    }
                                    logDebug$2('retrying on 5xx error', { error: error, attempt: attempt, retries: retries, response: response, body: body });
                                    return [2, true];
                                }
                                logDebug$2('retryOn returning false as error was not a 5xx error');
                                return [2, false];
                        }
                    });
                }); },
                retryDelay: function (attempt) {
                    var retryDelay = 10 + Math.pow(2, attempt) * 1000;
                    logDebug$2('retryDelay', { attempt: attempt + 1, retryDelay: retryDelay });
                    return retryDelay;
                },
            };
            this.fetchWithRetry = fetchBuilder(this.fetchImplementation, this.defaultRetryParams);
        }
        GatekeeperClient.prototype.setFlowId = function (flowId) {
            this.headers = objectToURLParams(__assign(__assign({}, (this.headers || {})), { 'x-civic-flowid': flowId }));
        };
        GatekeeperClient.prototype.instanceName = function () {
            var _a, _b;
            return (_b = (_a = this.queryParams) === null || _a === void 0 ? void 0 : _a.gatekeeperNetworkAddress) === null || _b === void 0 ? void 0 : _b.substring(0, 6);
        };
        GatekeeperClient.prototype.abort = function () {
            var _a, _b;
            logDebug$2("abort ".concat((_b = (_a = this.queryParams) === null || _a === void 0 ? void 0 : _a.gatekeeperNetworkAddress) === null || _b === void 0 ? void 0 : _b.substring(0, 6)));
            this.abortController.abort();
        };
        GatekeeperClient.prototype.addQueryParams = function (url) {
            if (!this.queryParams)
                return;
            Object.entries(this.queryParams).forEach(function (_a) {
                var key = _a[0], value = _a[1];
                url.searchParams.append(key, value);
            });
        };
        GatekeeperClient.prototype.continueIfNotAborted = function (fn) {
            logDebug$2("continueIfNotAborted ".concat(this.instanceName(), " this.abortController.signal.aborted: ").concat(this.abortController.signal.aborted), this.queryParams);
            if (!this.abortController.signal.aborted) {
                return fn();
            }
            return null;
        };
        GatekeeperClient.prototype.urlForWallet = function (walletAddress) {
            if (walletAddress === void 0) { walletAddress = this.initConfig.walletAddress; }
            var url = new URL("".concat(this.baseUrl, "/").concat(walletAddress));
            this.addQueryParams(url);
            return url.toString();
        };
        GatekeeperClient.prototype.getGatekeeperRecordWithPayload = function () {
            return __awaiter(this, arguments, void 0, function (walletAddress) {
                var _this = this;
                if (walletAddress === void 0) { walletAddress = this.initConfig.walletAddress; }
                return __generator(this, function (_a) {
                    logDebug$2("url: ".concat(this.urlForWallet(walletAddress), " getGatekeeperRecordWithPayload: ").concat(this.instanceName(), "  this.abortController.signal.aborted: ").concat(this.abortController.signal.aborted));
                    return [2, this.fetchWithRetry(this.urlForWallet(walletAddress), {
                            method: 'GET',
                            headers: this.headers,
                            signal: this.abortController.signal,
                        })
                            .then(this.continueIfNotAborted(function () { return function (response) { return __awaiter(_this, void 0, void 0, function () {
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = {
                                            state: GatekeeperAPIStatus[GatekeeperAPIStatus[response.status]]
                                        };
                                        return [4, response.json()];
                                    case 1: return [2, (_a.payload = _b.sent(),
                                            _a)];
                                }
                            });
                        }); }; }))
                            .catch(function (error) {
                            if (error.name === 'AbortError') {
                                logDebug$2('error due to abort controller signal aborted');
                                return null;
                            }
                            throw error;
                        })];
                });
            });
        };
        GatekeeperClient.prototype.getGatekeeperStatus = function () {
            return __awaiter(this, arguments, void 0, function (walletAddress) {
                if (walletAddress === void 0) { walletAddress = this.initConfig.walletAddress; }
                return __generator(this, function (_a) {
                    logDebug$2("getGatekeeperStatus: ".concat(this.instanceName(), "  this.abortController.signal.aborted: ").concat(this.abortController.signal.aborted));
                    return [2, this.fetchWithRetry(this.urlForWallet(walletAddress), {
                            method: 'HEAD',
                            headers: this.headers,
                            signal: this.abortController.signal,
                        })
                            .then(this.continueIfNotAborted(function () {
                            return function (_a) {
                                var status = _a.status;
                                return status;
                            };
                        }))
                            .catch(function (error) {
                            logError$3('getGatekeeperStatus', error);
                            if (error.name === 'AbortError') {
                                logDebug$2('error due to abort controller signal aborted');
                                return GatekeeperAPIStatus.SERVER_FAILURE;
                            }
                            throw error;
                        })];
                });
            });
        };
        GatekeeperClient.prototype.requestGatewayTokenFromGatekeeper = function (_a) {
            return __awaiter(this, arguments, void 0, function (_b) {
                var body, url;
                var _this = this;
                var payload = _b.payload, proof = _b.proof, payer = _b.payer;
                return __generator(this, function (_c) {
                    logDebug$2("requestGatewayTokenFromGatekeeper: ".concat(this.instanceName(), "  this.abortController.signal.aborted: ").concat(this.abortController.signal.aborted), __assign(__assign({}, payload), { proof: proof }));
                    body = withoutUndefined(__assign(__assign({}, payload), { proof: proof, address: this.initConfig.walletAddress, payer: payer }));
                    logDebug$2('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', body);
                    url = new URL(this.baseUrl);
                    this.addQueryParams(url);
                    return [2, this.fetchWithRetry(url.toString(), {
                            method: 'POST',
                            headers: __assign(__assign({}, this.headers), { 'Content-Type': 'application/json' }),
                            body: JSON.stringify(body),
                            signal: this.abortController.signal,
                        })
                            .then(this.continueIfNotAborted(function () { return function (resp) { return __awaiter(_this, void 0, void 0, function () {
                            var status, result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        status = resp.status;
                                        return [4, resp.json()];
                                    case 1:
                                        result = (_a.sent());
                                        return [2, __assign(__assign({}, result), { state: GatekeeperAPIStatus[GatekeeperAPIStatus[status]], status: status })];
                                }
                            });
                        }); }; }))
                            .catch(function (error) {
                            logError$3('requestGatewayTokenFromGatekeeper', error);
                            if (error.name === 'AbortError') {
                                logDebug$2('error due to abort controller signal aborted');
                                return null;
                            }
                            throw error;
                        })];
                });
            });
        };
        GatekeeperClient.prototype.refreshToken = function (_a) {
            return __awaiter(this, arguments, void 0, function (_b) {
                var body;
                var _this = this;
                var _c, _d;
                var payload = _b.payload, proof = _b.proof, payer = _b.payer;
                return __generator(this, function (_e) {
                    logDebug$2("refreshToken: ".concat(this.urlForWallet(this.initConfig.walletAddress)).concat((_d = (_c = this.queryParams) === null || _c === void 0 ? void 0 : _c.gatekeeperNetworkAddress) === null || _d === void 0 ? void 0 : _d.substring(0, 6), "  this.abortController.signal.aborted: ").concat(this.abortController.signal.aborted), { payload: payload });
                    body = withoutUndefined(__assign(__assign({}, payload), { proof: proof, request: 'refresh', payer: payer }));
                    return [2, this.fetchWithRetry(this.urlForWallet(this.initConfig.walletAddress), {
                            method: 'PATCH',
                            headers: __assign(__assign({}, this.headers), { 'Content-Type': 'application/json' }),
                            body: JSON.stringify(body),
                            signal: this.abortController.signal,
                        })
                            .then(function (resp) { return __awaiter(_this, void 0, void 0, function () {
                            var status, result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        status = resp.status;
                                        return [4, resp.json()];
                                    case 1:
                                        result = (_a.sent());
                                        return [2, __assign(__assign({}, result), { state: GatekeeperAPIStatus[GatekeeperAPIStatus[status]], status: status })];
                                }
                            });
                        }); })
                            .catch(function (error) {
                            logError$3('refreshToken', error);
                            if (error.name === 'AbortError') {
                                logDebug$2('error due to abort controller signal aborted');
                                return null;
                            }
                            throw error;
                        })];
                });
            });
        };
        GatekeeperClient.prototype.fetchFreshTransaction = function (_a) {
            return __awaiter(this, arguments, void 0, function (_b) {
                var url, body;
                var _this = this;
                var _c, _d;
                var payer = _b.payer;
                return __generator(this, function (_e) {
                    url = new URL("".concat(this.baseUrl, "/").concat(this.initConfig.walletAddress, "/transaction"));
                    this.addQueryParams(url);
                    logDebug$2("fetchFreshTransaction: ".concat(url.toString()).concat((_d = (_c = this.queryParams) === null || _c === void 0 ? void 0 : _c.gatekeeperNetworkAddress) === null || _d === void 0 ? void 0 : _d.substring(0, 6), "  this.abortController.signal.aborted: ").concat(this.abortController.signal.aborted));
                    body = withoutUndefined({
                        payer: payer,
                    });
                    return [2, this.fetchWithRetry("".concat(url.toString()), {
                            method: 'POST',
                            headers: __assign(__assign({}, this.headers), { 'Content-Type': 'application/json' }),
                            body: JSON.stringify(body),
                            signal: this.abortController.signal,
                        })
                            .then(function (resp) { return __awaiter(_this, void 0, void 0, function () {
                            var status, result;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        status = resp.status;
                                        return [4, resp.json()];
                                    case 1:
                                        result = (_a.sent());
                                        return [2, __assign(__assign({}, result), { state: GatekeeperAPIStatus[GatekeeperAPIStatus[status]], status: status })];
                                }
                            });
                        }); })
                            .catch(function (error) {
                            logError$3('fetchFreshTransaction', error);
                            if (error.name === 'AbortError') {
                                logDebug$2('error due to abort controller signal aborted');
                                return null;
                            }
                            throw error;
                        })];
                });
            });
        };
        GatekeeperClient.prototype.updateTransactionStatus = function (txId_1) {
            return __awaiter(this, arguments, void 0, function (txId, status) {
                var url, body;
                var _this = this;
                if (status === void 0) { status = 'sent'; }
                return __generator(this, function (_a) {
                    url = new URL("".concat(this.baseUrl, "/").concat(this.initConfig.walletAddress, "/transaction/").concat(txId));
                    this.addQueryParams(url);
                    body = { status: status };
                    return [2, this.fetchWithRetry(url.toString(), {
                            method: 'PATCH',
                            headers: __assign(__assign({}, this.headers), { 'Content-Type': 'application/json' }),
                            body: JSON.stringify(body),
                            signal: this.abortController.signal,
                        })
                            .then(this.continueIfNotAborted(function () { return function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                logDebug$2('updateTransactionStatus successful', {
                                    txId: txId,
                                    url: url,
                                    wallet: this.initConfig.walletAddress,
                                });
                                return [2];
                            });
                        }); }; }))
                            .catch(function (error) {
                            if (error.name === 'AbortError') {
                                logDebug$2('error due to abort controller signal aborted');
                                return null;
                            }
                            logError$3('updateTransactionStatus', error);
                            throw error;
                        })];
                });
            });
        };
        return GatekeeperClient;
    }());

    exports.State = void 0;
    (function (State) {
        State["ACTIVE"] = "ACTIVE";
        State["REVOKED"] = "REVOKED";
        State["FROZEN"] = "FROZEN";
    })(exports.State || (exports.State = {}));
    exports.TokenState = void 0;
    (function (TokenState) {
        TokenState["REQUESTED"] = "REQUESTED";
        TokenState["ACTIVE"] = "ACTIVE";
        TokenState["REVOKED"] = "REVOKED";
        TokenState["FROZEN"] = "FROZEN";
        TokenState["REJECTED"] = "REJECTED";
    })(exports.TokenState || (exports.TokenState = {}));
    exports.ChainType = void 0;
    (function (ChainType) {
        ChainType["SOLANA"] = "solana";
        ChainType["ETHEREUM"] = "ethereum";
        ChainType["CASPER"] = "casper";
        ChainType["ICP"] = "icp";
    })(exports.ChainType || (exports.ChainType = {}));
    exports.SignatureMethod = void 0;
    (function (SignatureMethod) {
        SignatureMethod[SignatureMethod["TRANSACTION"] = 0] = "TRANSACTION";
        SignatureMethod[SignatureMethod["MESSAGE"] = 1] = "MESSAGE";
    })(exports.SignatureMethod || (exports.SignatureMethod = {}));

    var ErrorCode = {
        INSUFFICIENT_FUNDS: '0x1',
        SIGN_TRANSACTION_ERROR: '0x2',
        SIGN_TRANSACTION_USER_REJECTED_ERROR: '0x21',
        SIGN_TRANSACTION_UNKNOWN_ERROR: '0x22',
        SEND_TRANSACTION_ERROR: '0x3',
        CUSTOM_HANDLE_TRANSACTION_ERROR: '0x4',
        POWO_ERROR: '0x5',
        CHAIN_CONFIRMATION_TIMEOUT_ERROR: '0x6',
        TRANSACTION_FAILED_ON_CHAIN_ERROR: '0x61',
        TRANSACTION_DROPPED_ERROR: '0x62',
        TRANSACTION_CONFIRMATION_UNKNOWN_ERROR: '0x63',
        BROWSER_CLOSED_WHILE_TRANSACTION_PENDING: '0x64',
        EXPECTED_GATEKEEPER_RECORD: '0x7',
    };
    var ChainError = (function (_super) {
        __extends(ChainError, _super);
        function ChainError(message, errorCode, useLogger) {
            if (useLogger === void 0) { useLogger = localLogger; }
            var _this = _super.call(this, message) || this;
            _this.errorCode = errorCode;
            useLogger === null || useLogger === void 0 ? void 0 : useLogger.error("ChainError: ".concat(message, " throwing code ").concat(errorCode));
            Object.setPrototypeOf(_this, ChainError.prototype);
            return _this;
        }
        return ChainError;
    }(Error));
    var ChainConfirmationTimeout = (function (_super) {
        __extends(ChainConfirmationTimeout, _super);
        function ChainConfirmationTimeout(message, errorCode) {
            if (errorCode === void 0) { errorCode = ErrorCode.CHAIN_CONFIRMATION_TIMEOUT_ERROR; }
            var _this = _super.call(this, message) || this;
            _this.errorCode = errorCode;
            localLogger.error("ChainConfirmationTimeout: ".concat(message, " throwing code ").concat(errorCode));
            Object.setPrototypeOf(_this, ChainConfirmationTimeout.prototype);
            return _this;
        }
        return ChainConfirmationTimeout;
    }(Error));

    exports.GatewayStatus = void 0;
    (function (GatewayStatus) {
        GatewayStatus["UNKNOWN"] = "UNKNOWN";
        GatewayStatus["CHECKING"] = "CHECKING";
        GatewayStatus["NOT_REQUESTED"] = "NOT_REQUESTED";
        GatewayStatus["COLLECTING_USER_INFORMATION"] = "COLLECTING_USER_INFORMATION";
        GatewayStatus["IN_REVIEW"] = "IN_REVIEW";
        GatewayStatus["REJECTED"] = "REJECTED";
        GatewayStatus["REVOKED"] = "REVOKED";
        GatewayStatus["FROZEN"] = "FROZEN";
        GatewayStatus["ACTIVE"] = "ACTIVE";
        GatewayStatus["ERROR"] = "ERROR";
        GatewayStatus["LOCATION_NOT_SUPPORTED"] = "LOCATION_NOT_SUPPORTED";
        GatewayStatus["VPN_NOT_SUPPORTED"] = "VPN_NOT_SUPPORTED";
        GatewayStatus["REFRESH_TOKEN_REQUIRED"] = "REFRESH_TOKEN_REQUIRED";
        GatewayStatus["VALIDATING_USER_INFORMATION"] = "VALIDATING_USER_INFORMATION";
        GatewayStatus["USER_INFORMATION_VALIDATED"] = "USER_INFORMATION_VALIDATED";
        GatewayStatus["USER_INFORMATION_REJECTED"] = "USER_INFORMATION_REJECTED";
    })(exports.GatewayStatus || (exports.GatewayStatus = {}));
    exports.ExtendedGatewayStatus = void 0;
    (function (ExtendedGatewayStatus) {
        ExtendedGatewayStatus["AWAITING_OWNER_TRANSACTION"] = "AWAITING_OWNER_TRANSACTION";
        ExtendedGatewayStatus["CHAIN_TIMEOUT_ERROR"] = "CHAIN_TIMEOUT_ERROR";
        ExtendedGatewayStatus["CONFIRM_OWNER_TRANSACTION"] = "CONFIRM_OWNER_TRANSACTION";
        ExtendedGatewayStatus["CHAIN_TRANSACTION_ERROR"] = "CHAIN_TRANSACTION_ERROR";
        ExtendedGatewayStatus["TOKEN_IN_PARTNER_REVIEW"] = "TOKEN_IN_PARTNER_REVIEW";
        ExtendedGatewayStatus["TOKEN_REFRESH_IN_REVIEW"] = "TOKEN_REFRESH_IN_REVIEW";
        ExtendedGatewayStatus["USER_VALIDATION_FAILED"] = "USER_VALIDATION_FAILED";
        ExtendedGatewayStatus["RESTART"] = "RESTART";
        ExtendedGatewayStatus["CHAIN_SIGN_MESSAGE_ERROR"] = "CHAIN_SIGN_MESSAGE_ERROR";
        ExtendedGatewayStatus["ISSUANCE_CLIENT_PAYER_REQUESTED"] = "ISSUANCE_CLIENT_PAYER_REQUESTED";
        ExtendedGatewayStatus["ISSUANCE_AWAITING_TRANSACTION_SEND"] = "ISSUANCE_AWAITING_TRANSACTION_SEND";
        ExtendedGatewayStatus["ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND"] = "ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND";
        ExtendedGatewayStatus["ISSUANCE_AWAITING_ON_CHAIN_TOKEN"] = "ISSUANCE_AWAITING_ON_CHAIN_TOKEN";
        ExtendedGatewayStatus["ISSUANCE_RESTART_DATA_COLLECTION"] = "ISSUANCE_RESTART_DATA_COLLECTION";
        ExtendedGatewayStatus["ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX"] = "ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX";
        ExtendedGatewayStatus["ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX"] = "ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX";
        ExtendedGatewayStatus["ISSUANCE_CLIENT_SENDS_START_NEW_TX"] = "ISSUANCE_CLIENT_SENDS_START_NEW_TX";
        ExtendedGatewayStatus["REFRESH_USER_INFORMATION_VALIDATED"] = "REFRESH_USER_INFORMATION_VALIDATED";
        ExtendedGatewayStatus["REFRESH_CLIENT_PAYER_REQUESTED"] = "REFRESH_CLIENT_PAYER_REQUESTED";
        ExtendedGatewayStatus["REFRESH_IN_REVIEW"] = "REFRESH_IN_REVIEW";
        ExtendedGatewayStatus["REFRESH_AWAITING_TRANSACTION_SEND"] = "REFRESH_AWAITING_TRANSACTION_SEND";
        ExtendedGatewayStatus["REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND"] = "REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND";
        ExtendedGatewayStatus["REFRESH_AWAITING_ON_CHAIN_TOKEN"] = "REFRESH_AWAITING_ON_CHAIN_TOKEN";
        ExtendedGatewayStatus["RESTART_REFRESH"] = "RESTART_REFRESH";
        ExtendedGatewayStatus["REFRESH_CLIENT_SENDS_REQUEST_NEW_TX"] = "REFRESH_CLIENT_SENDS_REQUEST_NEW_TX";
        ExtendedGatewayStatus["REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX"] = "REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX";
        ExtendedGatewayStatus["REFRESH_CLIENT_SENDS_START_NEW_TX"] = "REFRESH_CLIENT_SENDS_START_NEW_TX";
    })(exports.ExtendedGatewayStatus || (exports.ExtendedGatewayStatus = {}));

    var GKN_SERVICE_ENDPOINTS = {
        local: 'https://dev.api.civic.com/gkn-dev',
        test: 'https://dev.api.civic.com/gkn-dev',
        dev: 'https://dev.api.civic.com/gkn-dev',
        preprod: "https://dev.api.civic.com/gkn-preprod",
        prod: 'https://api.civic.com/gkn',
    };
    var getGatekeeperNetworkData = function (stage, gknId) { return __awaiter(void 0, void 0, void 0, function () {
        var results, gknData;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!GKN_SERVICE_ENDPOINTS[stage]) {
                        throw new Error("No Gatekeeper Network Service endpoint found for stage ".concat(stage));
                    }
                    return [4, fetch("".concat(GKN_SERVICE_ENDPOINTS[stage], "/public/gatekeeperNetwork/").concat(gknId))];
                case 1:
                    results = _a.sent();
                    return [4, results.json()];
                case 2:
                    gknData = _a.sent();
                    if ((gknData === null || gknData === void 0 ? void 0 : gknData.id) !== gknId) {
                        throw new Error("Could not fetch data from Gatekeeper Network Service for ".concat(gknId));
                    }
                    return [2, gknData];
            }
        });
    }); };

    exports.FlowType = void 0;
    (function (FlowType) {
        FlowType["ISSUANCE"] = "issuance";
        FlowType["REFRESH"] = "refresh";
        FlowType["STATUS"] = "status";
        FlowType["REVOCATION"] = "revocation";
        FlowType["UNFREEZE"] = "unfreeze";
    })(exports.FlowType || (exports.FlowType = {}));
    exports.FlowStatus = void 0;
    (function (FlowStatus) {
        FlowStatus["IN_PROGRESS"] = "in-progress";
        FlowStatus["RESULT"] = "result";
        FlowStatus["FINISHED"] = "finished";
    })(exports.FlowStatus || (exports.FlowStatus = {}));

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }

    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }

    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var native = {
      randomUUID
    };

    function v4(options, buf, offset) {
      if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
      }

      options = options || {};
      const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return unsafeStringify(rnds);
    }

    var CivicPassMessageEventResult;
    (function (CivicPassMessageEventResult) {
        CivicPassMessageEventResult["SUCCESS"] = "success";
        CivicPassMessageEventResult["FAILURE"] = "failure";
        CivicPassMessageEventResult["CANCELLED"] = "cancelled";
        CivicPassMessageEventResult["IN_PROGRESS"] = "inProgress";
        CivicPassMessageEventResult["ERROR"] = "error";
    })(CivicPassMessageEventResult || (CivicPassMessageEventResult = {}));
    var CivicPassMessageAction;
    (function (CivicPassMessageAction) {
        CivicPassMessageAction["ISSUANCE"] = "issuance";
        CivicPassMessageAction["CONFIRM_TRANSACTION"] = "confirmTransaction";
        CivicPassMessageAction["TOKEN_FROZEN"] = "tokenFrozen";
        CivicPassMessageAction["TOKEN_ACTIVE"] = "tokenActive";
        CivicPassMessageAction["TOKEN_REVOKED"] = "tokenRevoked";
        CivicPassMessageAction["TOKEN_REJECTED"] = "tokenRejected";
        CivicPassMessageAction["TOKEN_IN_REVIEW"] = "tokenInReview";
        CivicPassMessageAction["TOKEN_REFRESH_IN_REVIEW"] = "tokenRefreshInReview";
        CivicPassMessageAction["TOKEN_IN_PARTNER_REVIEW"] = "tokenInPartnerReview";
        CivicPassMessageAction["FAILED_IP_CHECK"] = "failedIpCheck";
        CivicPassMessageAction["FAILED_VPN_CHECK"] = "failedVpnCheck";
        CivicPassMessageAction["REFRESH"] = "refresh";
        CivicPassMessageAction["STATUS"] = "status";
        CivicPassMessageAction["ERROR"] = "error";
        CivicPassMessageAction["CHAIN_ERROR"] = "chainError";
        CivicPassMessageAction["SIGN_TRANSACTION"] = "signTransaction";
        CivicPassMessageAction["AWAITING_TRANSACTION_CONFIRMATION"] = "awaitingTransactionConfirmation";
        CivicPassMessageAction["START_PRE_APPROVED_TRANSACTION"] = "startPreApprovedTransaction";
    })(CivicPassMessageAction || (CivicPassMessageAction = {}));
    var ValidationStatus;
    (function (ValidationStatus) {
        ValidationStatus["COLLECTING"] = "COLLECTING";
        ValidationStatus["PROCESSING"] = "PROCESSING";
        ValidationStatus["IN_REVIEW"] = "IN_REVIEW";
        ValidationStatus["COMPLETED"] = "COMPLETED";
        ValidationStatus["FAILED"] = "FAILED";
        ValidationStatus["NOT_FOUND"] = "NOT_FOUND";
    })(ValidationStatus || (ValidationStatus = {}));

    var CivicSignEventTypeResponse;
    (function (CivicSignEventTypeResponse) {
        CivicSignEventTypeResponse["RESPONSE_PUBLIC_KEY"] = "RESPONSE_PUBLIC_KEY";
        CivicSignEventTypeResponse["RESPONSE_DID"] = "RESPONSE_DID";
        CivicSignEventTypeResponse["RESPONSE_SIGNED_PROOF"] = "RESPONSE_SIGNED_PROOF";
        CivicSignEventTypeResponse["RESPONSE_SIGNED_MESSAGE"] = "RESPONSE_SIGNED_MESSAGE";
        CivicSignEventTypeResponse["RESPONSE_ERROR"] = "RESPONSE_ERROR";
    })(CivicSignEventTypeResponse || (CivicSignEventTypeResponse = {}));
    var CivicSignEventTypeRequest;
    (function (CivicSignEventTypeRequest) {
        CivicSignEventTypeRequest["REQUEST_PUBLIC_KEY"] = "REQUEST_PUBLIC_KEY";
        CivicSignEventTypeRequest["REQUEST_DID"] = "REQUEST_DID";
        CivicSignEventTypeRequest["REQUEST_SIGNED_PROOF"] = "REQUEST_SIGNED_PROOF";
        CivicSignEventTypeRequest["REQUEST_SIGNED_MESSAGE"] = "REQUEST_SIGNED_MESSAGE";
    })(CivicSignEventTypeRequest || (CivicSignEventTypeRequest = {}));

    var ListenerManager = (function () {
        function ListenerManager(messageEventInterface, chainImplementation, instanceId, log) {
            if (log === void 0) { log = prefixLogger('ListenerManager'); }
            this.messageEventInterface = messageEventInterface;
            this.chainImplementation = chainImplementation;
            this.instanceId = instanceId;
            this.log = log;
            this.messageListeners = {};
        }
        ListenerManager.prototype.registerCivicPassListener = function (onMessage) {
            var _this = this;
            var handler = function (response) {
                var _a, _b;
                if (!response.data) {
                    _this.log.error('No data in response');
                    return;
                }
                if (((_a = response.data) === null || _a === void 0 ? void 0 : _a.instanceId) !== _this.instanceId) {
                    if (((_b = response.data) === null || _b === void 0 ? void 0 : _b.instanceId) && response.data.source !== '@devtools-page') {
                        _this.log.debug('instanceId for different instance', { event: response.data, instanceId: _this.instanceId });
                    }
                    return;
                }
                if (!Object.values(CivicPassMessageAction).includes(response.data.action)) {
                    return;
                }
                _this.log.debug('received CivicPassListener postMessage', response.data);
                onMessage(response.data);
            };
            this.log.debug('Adding event listener for civic-pass events');
            this.messageEventInterface.addMessageEventListener(handler);
            this.messageListeners.civicPass = handler;
        };
        ListenerManager.prototype.registerCivicSignListener = function (onMessage) {
            var _this = this;
            var handler = function (response) {
                var _a, _b;
                if (!response.data) {
                    _this.log.error('No data in response');
                    return;
                }
                if (((_a = response.data) === null || _a === void 0 ? void 0 : _a.instanceId) !== _this.instanceId) {
                    if (((_b = response.data) === null || _b === void 0 ? void 0 : _b.instanceId) && response.data.source !== '@devtools-page') {
                        _this.log.debug('instanceId for different instance', { event: response.data, instanceId: _this.instanceId });
                    }
                    return;
                }
                if (!Object.values(CivicSignEventTypeRequest).includes(response.data.request)) {
                    return;
                }
                _this.log.debug('received CivicSignListener postMessage', response.data);
                onMessage(response.data);
            };
            this.log.debug('Adding event listener for civic-sign events');
            this.messageEventInterface.addMessageEventListener(handler);
            this.messageListeners.civicSign = handler;
        };
        ListenerManager.prototype.registerOnChainListeners = function (onTokenChange) {
            this.chainImplementation.on('TOKEN_CREATED', onTokenChange);
            this.chainImplementation.on('TOKEN_CHANGED', onTokenChange);
        };
        ListenerManager.prototype.unregisterAllListeners = function () {
            var _this = this;
            Object.entries(this.messageListeners).forEach(function (_a) {
                var key = _a[0], handler = _a[1];
                _this.log.debug('Removing message event listener', key);
                _this.messageEventInterface.removeMessageEventListener(handler);
                delete _this.messageListeners[key];
            });
        };
        return ListenerManager;
    }());

    var InputStatus;
    (function (InputStatus) {
        InputStatus["IN_PROGRESS"] = "IN_PROGRESS";
        InputStatus["COMPLETE"] = "COMPLETE";
        InputStatus["ERROR"] = "ERROR";
        InputStatus["RECEIVED"] = "RECEIVED";
        InputStatus["RESPONDED"] = "RESPONDED";
    })(InputStatus || (InputStatus = {}));

    var getPayer = function (_a) {
        var gatekeeperSendsTransaction = _a.gatekeeperSendsTransaction, payer = _a.payer, wallet = _a.wallet;
        if (gatekeeperSendsTransaction)
            return undefined;
        return payer || (wallet === null || wallet === void 0 ? void 0 : wallet.address);
    };

    var logDebug$1 = prefixLogger('remoteSign').debug;
    var logError$2 = prefixLogger('remoteSign').error;
    var eventEmitter = function (postMessageTarget) {
        return {
            postMessage: function (message, targetOrigin) {
                postMessageTarget.postMessage(message, targetOrigin);
            },
        };
    };
    var RemoteSignWindowEventEmitter = (function () {
        function RemoteSignWindowEventEmitter(postMessageTarget, instanceId) {
            this.instanceId = instanceId;
            this.postMessageTarget = postMessageTarget;
        }
        RemoteSignWindowEventEmitter.prototype.sendPublicKey = function (requestId, publicKey) {
            this.emit({
                event: CivicSignEventTypeResponse.RESPONSE_PUBLIC_KEY,
                data: publicKey,
                requestId: requestId,
            });
        };
        RemoteSignWindowEventEmitter.prototype.sendDid = function (requestId, did) {
            this.emit({
                event: CivicSignEventTypeResponse.RESPONSE_DID,
                data: did,
                requestId: requestId,
            });
        };
        RemoteSignWindowEventEmitter.prototype.sendSignedProof = function (requestId, proof, signatureMethod) {
            this.emit({
                event: CivicSignEventTypeResponse.RESPONSE_SIGNED_PROOF,
                data: { proof: proof, signatureMethod: signatureMethod },
                requestId: requestId,
            });
        };
        RemoteSignWindowEventEmitter.prototype.sendSignedMessage = function (requestId, message) {
            this.emit({
                event: CivicSignEventTypeResponse.RESPONSE_SIGNED_MESSAGE,
                data: message,
                requestId: requestId,
            });
        };
        RemoteSignWindowEventEmitter.prototype.sendError = function (requestId, request, error) {
            this.emit({
                event: CivicSignEventTypeResponse.RESPONSE_ERROR,
                requestId: requestId,
                data: {
                    request: request,
                    error: {
                        message: error.message,
                        code: error === null || error === void 0 ? void 0 : error.errorCode,
                    },
                },
            });
        };
        RemoteSignWindowEventEmitter.prototype.emit = function (event) {
            this.postMessageTarget.postMessage(__assign(__assign({}, event), { instanceId: this.instanceId }), '*');
        };
        return RemoteSignWindowEventEmitter;
    }());
    var handleRemoteSignEvent = function (message, remoteSignerInst, inputs) { return __awaiter(void 0, void 0, void 0, function () {
        var wallet, chainImplementation, ownerDids, _a, powoResponse, signMessageResponse, error_1, code, useError;
        var _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    wallet = inputs.wallet, chainImplementation = inputs.chainImplementation;
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, 8, , 9]);
                    _a = inputs.ownerDids;
                    if (_a) return [3, 3];
                    return [4, chainImplementation.ownerDids()];
                case 2:
                    _a = (_c.sent());
                    _c.label = 3;
                case 3:
                    ownerDids = _a;
                    logDebug$1("handleRemoteSignEvent ".concat(message.request), {
                        remoteSignerInst: remoteSignerInst,
                        wallet: wallet,
                        chainImplDids: ownerDids,
                    });
                    if (!Object.values(CivicSignEventTypeRequest).includes(message.request)) {
                        logError$2('No result from remote sign event');
                        return [2];
                    }
                    if (message.request === CivicSignEventTypeRequest.REQUEST_PUBLIC_KEY) {
                        remoteSignerInst === null || remoteSignerInst === void 0 ? void 0 : remoteSignerInst.sendPublicKey(message.requestId, wallet.address);
                        return [2, wallet.address];
                    }
                    if (message.request === CivicSignEventTypeRequest.REQUEST_DID) {
                        remoteSignerInst === null || remoteSignerInst === void 0 ? void 0 : remoteSignerInst.sendDid(message.requestId, ownerDids === null || ownerDids === void 0 ? void 0 : ownerDids[0]);
                        return [2, ownerDids === null || ownerDids === void 0 ? void 0 : ownerDids[0]];
                    }
                    if (!(message.request === CivicSignEventTypeRequest.REQUEST_SIGNED_PROOF)) return [3, 5];
                    return [4, chainImplementation.proveWalletOwnership(message.payload)];
                case 4:
                    powoResponse = _c.sent();
                    remoteSignerInst === null || remoteSignerInst === void 0 ? void 0 : remoteSignerInst.sendSignedProof(message.requestId, powoResponse.proof, powoResponse.signatureMethod);
                    return [2, { proof: powoResponse.proof, signatureMethod: powoResponse.signatureMethod }];
                case 5:
                    if (!(message.request === CivicSignEventTypeRequest.REQUEST_SIGNED_MESSAGE)) return [3, 7];
                    if (!message.payload) return [3, 7];
                    if (!chainImplementation.signMessage) {
                        throw new Error('Chain implementation does not support signMessage');
                    }
                    return [4, ((_b = chainImplementation.signMessage) === null || _b === void 0 ? void 0 : _b.call(chainImplementation, Buffer.from(message.payload)))];
                case 6:
                    signMessageResponse = _c.sent();
                    remoteSignerInst === null || remoteSignerInst === void 0 ? void 0 : remoteSignerInst.sendSignedMessage(message.requestId, signMessageResponse);
                    return [2, signMessageResponse];
                case 7: return [3, 9];
                case 8:
                    error_1 = _c.sent();
                    code = error_1.errorCode || error_1.code || ErrorCode.POWO_ERROR;
                    useError = new ChainError(error_1.message, "".concat(code));
                    logError$2("Error handling remote sign event, sending back an error response with code ".concat(code), useError);
                    remoteSignerInst === null || remoteSignerInst === void 0 ? void 0 : remoteSignerInst.sendError(message.requestId, message.request, useError);
                    return [2, {
                            request: message.request,
                            error: useError,
                        }];
                case 9: return [2];
            }
        });
    }); };

    var OrchestratorFlow = (function () {
        function OrchestratorFlow(gatewayCoreStore, gatekeeperClient, abortController) {
            this.gatewayCoreStore = gatewayCoreStore;
            this.gatekeeperClient = gatekeeperClient;
            this.abortController = abortController;
            this.log = prefixLogger('OrchestratorFlow');
        }
        OrchestratorFlow.prototype.setGatekeeperClientFlowId = function () {
            var _a, _b, _c, _d;
            var fullState = this.gatewayCoreStore.getState();
            if (!((_b = (_a = fullState.output) === null || _a === void 0 ? void 0 : _a.flowParameters) === null || _b === void 0 ? void 0 : _b.flowId)) {
                this.log.error('Missing flowId', fullState);
                throw new Error('Missing flowId');
            }
            this.gatekeeperClient.setFlowId((_d = (_c = fullState.output) === null || _c === void 0 ? void 0 : _c.flowParameters) === null || _d === void 0 ? void 0 : _d.flowId);
        };
        return OrchestratorFlow;
    }());

    var DEFAULT_EXPECT_TOKEN_TIMEOUT_SECONDS = 120;
    var DEFAULT_MAX_CLIENT_SENDS_RETRIES = 3;

    var isApproachingExpiry = function (currentExpiry, tokenExpirationMarginSeconds) {
        var now = Math.floor(Date.now() / 1000);
        return currentExpiry - now <= tokenExpirationMarginSeconds;
    };
    var hasExpired = function (expiryTime) {
        if (!expiryTime)
            return false;
        var now = Math.floor(Date.now() / 1000);
        return now >= expiryTime;
    };
    var isTokenRefreshRequired = function (_a) {
        var gatewayToken = _a.gatewayToken, tokenExpirationMarginSeconds = _a.tokenExpirationMarginSeconds, forceRequireRefresh = _a.forceRequireRefresh;
        var _b = gatewayToken || {}, expiryTime = _b.expiryTime, state = _b.state;
        var isActive = state === exports.State.ACTIVE;
        if (!expiryTime || !isActive)
            return false;
        return (!!forceRequireRefresh || hasExpired(expiryTime) || isApproachingExpiry(expiryTime, tokenExpirationMarginSeconds));
    };
    var MAX_ALLOWED_TIMEOUT = 2147483647;
    var nowSeconds = function () { return Math.floor(Date.now() / 1000); };
    var getTokenRefreshIntervalMilliseconds = function (expiryTimeSeconds, tokenExpirationMarginSeconds) {
        var interval = expiryTimeSeconds - nowSeconds() - tokenExpirationMarginSeconds;
        var retVal = interval > 0 ? interval * 1000 : 0;
        return retVal >= MAX_ALLOWED_TIMEOUT ? MAX_ALLOWED_TIMEOUT - 1 : retVal;
    };

    var Issuance = (function (_super) {
        __extends(Issuance, _super);
        function Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController, expectTokenTimeoutSeconds) {
            if (expectTokenTimeoutSeconds === void 0) { expectTokenTimeoutSeconds = DEFAULT_EXPECT_TOKEN_TIMEOUT_SECONDS; }
            var _this = _super.call(this, gatewayCoreStore, gatekeeperClient, abortController) || this;
            _this.gatewayCoreStore = gatewayCoreStore;
            _this.chainImplementation = chainImplementation;
            _this.gatekeeperClient = gatekeeperClient;
            _this.abortController = abortController;
            _this.expectTokenTimeoutSeconds = expectTokenTimeoutSeconds;
            _this.timers = {};
            _this.log = prefixLogger("Issuance instance with expectTokenTimeoutSeconds ".concat(expectTokenTimeoutSeconds));
            return _this;
        }
        Issuance.prototype.sendTransaction = function () {
            return __awaiter(this, void 0, void 0, function () {
                var fullState, chainType, frontendPollingTimeoutSeconds;
                var _this = this;
                var _a, _b, _c, _d;
                return __generator(this, function (_e) {
                    fullState = this.gatewayCoreStore.getState();
                    if (!((_a = fullState.inputs.gatekeeperRecord.received) === null || _a === void 0 ? void 0 : _a.transaction)) {
                        this.log.error('Missing gatekeeperRecord payload');
                        throw new Error('Missing gatekeeperRecord payload');
                    }
                    this.gatewayCoreStore.setState(function (draft) {
                        if (!draft.internal.chainTransaction) {
                            draft.internal.chainTransaction = {
                                attempts: 0,
                            };
                        }
                        if (draft.internal.chainTransaction.attempts !== undefined) {
                            draft.internal.chainTransaction.attempts += 1;
                        }
                        draft.internal.chainTransaction.sentTxId = undefined;
                        draft.internal.errors.expectedOnChainToken = null;
                        draft.inputs.gatewayToken.status = InputStatus.COMPLETE;
                        draft.internal.chainTransaction.error = undefined;
                        draft.inputs.civicPass.received = null;
                    });
                    this.abortExpectedTokenTimer();
                    if (!this.chainImplementation.handleTransaction) {
                        this.log.error('No handleTransaction defined on chainImplementation.');
                        throw new Error('No handleTransaction defined on chainImplementation');
                    }
                    chainType = (_b = fullState.internal.chainDetails) === null || _b === void 0 ? void 0 : _b.chainType;
                    frontendPollingTimeoutSeconds = chainType
                        ? (_d = (_c = fullState.inputs.gatekeeperNetworkData.received) === null || _c === void 0 ? void 0 : _c.chains[chainType]) === null || _d === void 0 ? void 0 : _d.frontendPollingTimeoutSeconds
                        : undefined;
                    this.chainImplementation
                        .handleTransaction(fullState.inputs.gatekeeperRecord.received.transaction, frontendPollingTimeoutSeconds)
                        .then(function (txId) {
                        if (_this.abortController.signal.aborted)
                            return;
                        _this.gatewayCoreStore.setState(function (state) {
                            if (!state.internal.chainTransaction) {
                                state.internal.chainTransaction = {};
                            }
                            _this.gatekeeperClient.updateTransactionStatus(txId);
                            state.internal.chainTransaction.sentTxId = txId;
                        });
                    })
                        .catch(function (error) {
                        _this.gatewayCoreStore.setState(function (draft) {
                            if (!draft.internal.chainTransaction) {
                                draft.internal.chainTransaction = {};
                            }
                            draft.internal.chainTransaction.error = error;
                        });
                    });
                    return [2];
                });
            });
        };
        Issuance.prototype.gatekeeperRequest = function (payer, fullState) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, _b, _c;
                return __generator(this, function (_d) {
                    if (!((_a = fullState.inputs.civicPass.received) === null || _a === void 0 ? void 0 : _a.payload)) {
                        this.log.error('Missing civicPass payload', fullState);
                        throw new Error('Missing civicPass payload');
                    }
                    this.currentPayload = (_b = fullState.inputs.civicPass.received) === null || _b === void 0 ? void 0 : _b.payload;
                    return [2, this.gatekeeperClient.requestGatewayTokenFromGatekeeper({
                            payload: (_c = fullState.inputs.civicPass.received) === null || _c === void 0 ? void 0 : _c.payload,
                            payer: payer,
                        })];
                });
            });
        };
        Issuance.prototype.freshTransactionGatekeeperRequest = function (payer) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, this.gatekeeperClient.fetchFreshTransaction({
                            payer: payer,
                        })];
                });
            });
        };
        Issuance.prototype.clearStateBeforeGatekeeperRequest = function (isFreshTransactionRequest) {
            if (isFreshTransactionRequest === void 0) { isFreshTransactionRequest = false; }
            this.gatewayCoreStore.setState(function (state) {
                state.internal.errors.expectedOnChainToken = null;
                state.inputs.gatewayToken.status = InputStatus.COMPLETE;
                state.inputs.gatekeeperRecord.received = null;
                state.inputs.gatekeeperRecord.status = InputStatus.IN_PROGRESS;
                if (isFreshTransactionRequest) {
                    state.internal.chainTransaction = undefined;
                }
            });
        };
        Issuance.prototype.makeGatekeeperRequest = function (_a) {
            return __awaiter(this, arguments, void 0, function (_b) {
                var fullState, requestPromise;
                var _this = this;
                var payer = _b.payer, isFreshTransactionRequest = _b.isFreshTransactionRequest;
                return __generator(this, function (_c) {
                    fullState = this.gatewayCoreStore.getState();
                    this.setGatekeeperClientFlowId();
                    this.log.debug('makeGatekeeperRequest', fullState);
                    this.abortExpectedTokenTimer();
                    this.clearStateBeforeGatekeeperRequest(isFreshTransactionRequest);
                    requestPromise = isFreshTransactionRequest
                        ? this.freshTransactionGatekeeperRequest(payer)
                        : this.gatekeeperRequest(payer, fullState);
                    requestPromise
                        .then(function (response) {
                        if (_this.abortController.signal.aborted)
                            return;
                        _this.gatewayCoreStore.setState(function (state) {
                            state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
                            state.inputs.gatekeeperRecord.received = response;
                        });
                    })
                        .catch(function (error) {
                        _this.gatewayCoreStore.setState(function (state) {
                            state.inputs.gatekeeperRecord.status = InputStatus.ERROR;
                            state.inputs.gatekeeperRecord.error = error;
                        });
                    });
                    return [2];
                });
            });
        };
        Issuance.prototype.retrieveFreshTransaction = function (payer) {
            return __awaiter(this, void 0, void 0, function () {
                var fullState;
                var _this = this;
                var _a;
                return __generator(this, function (_b) {
                    fullState = this.gatewayCoreStore.getState();
                    if (!((_a = fullState.inputs.civicPass.received) === null || _a === void 0 ? void 0 : _a.payload)) {
                        this.log.error('Missing civicPass payload', fullState);
                        throw new Error('Missing civicPass payload');
                    }
                    this.setGatekeeperClientFlowId();
                    this.log.debug('retrieveFreshTransaction', fullState);
                    this.abortExpectedTokenTimer();
                    this.clearStateBeforeGatekeeperRequest();
                    this.gatekeeperRequest(payer, fullState)
                        .then(function (response) {
                        if (_this.abortController.signal.aborted)
                            return;
                        _this.gatewayCoreStore.setState(function (state) {
                            state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
                            state.inputs.gatekeeperRecord.received = response;
                        });
                    })
                        .catch(function (error) {
                        _this.gatewayCoreStore.setState(function (state) {
                            state.inputs.gatekeeperRecord.status = InputStatus.ERROR;
                            state.inputs.gatekeeperRecord.error = error;
                        });
                    });
                    return [2];
                });
            });
        };
        Issuance.prototype.statusHasValidToken = function () {
            var updatedState = this.gatewayCoreStore.getState();
            return !!updatedState.inputs.gatewayToken.received;
        };
        Issuance.prototype.expectOnChainToken = function () {
            var _this = this;
            var fullState = this.gatewayCoreStore.getState();
            if (fullState.inputs.gatewayToken.received || this.timers.expectOnChainToken) {
                return;
            }
            this.timers.expectOnChainToken = setTimeout(function () {
                _this.gatewayCoreStore.setState(function (state) {
                    if (!_this.statusHasValidToken()) {
                        state.internal.errors.expectedOnChainToken = new ChainConfirmationTimeout('No on-chain token found within interval');
                    }
                });
            }, this.expectTokenTimeoutSeconds * 1000);
            this.log.debug('Started expected token timer', this.timers.expectOnChainToken);
        };
        Issuance.prototype.abort = function () {
            this.abortExpectedTokenTimer();
            this.abortRefreshCountdownTimer();
        };
        Issuance.prototype.abortExpectedTokenTimer = function () {
            if (this.timers.expectOnChainToken) {
                this.log.debug('Aborting expected token timer', this.timers.expectOnChainToken);
                clearTimeout(this.timers.expectOnChainToken);
            }
        };
        Issuance.prototype.onActiveTokenFound = function () {
            this.abortExpectedTokenTimer();
            this.gatewayCoreStore.setState(function (state) {
                var _a;
                if (((_a = state.inputs.dynamicParameters) === null || _a === void 0 ? void 0 : _a.forceRequireRefresh) !== undefined) {
                    state.inputs.gatekeeperRecord.received = null;
                    state.internal.chainTransaction = undefined;
                    state.inputs.dynamicParameters.forceRequireRefresh = false;
                }
            });
            this.startRefreshCountdownTimer();
        };
        Issuance.prototype.startRefreshCountdownTimer = function () {
            var _this = this;
            var fullState = this.gatewayCoreStore.getState();
            var gatewayToken = fullState.inputs.gatewayToken.received;
            if (!(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {
                return;
            }
            this.abortRefreshCountdownTimer();
            var refreshIntervalDuration = getTokenRefreshIntervalMilliseconds(gatewayToken.expiryTime, 0);
            this.timers.refreshCountdownTimer = setTimeout(function () {
                _this.abortRefreshCountdownTimer();
            }, refreshIntervalDuration);
            this.log.debug('Started refresh countdown timer', {
                gatewayToken: gatewayToken,
                refreshCountdownTimer: this.timers.refreshCountdownTimer,
            });
        };
        Issuance.prototype.abortRefreshCountdownTimer = function () {
            this.log.debug('abortRefreshCountdownTimer', {
                refreshCountdownTimer: this.timers.refreshCountdownTimer,
            });
            if (this.timers.refreshCountdownTimer) {
                clearTimeout(this.timers.refreshCountdownTimer);
                this.timers.refreshCountdownTimer = undefined;
            }
        };
        Issuance.prototype.restartDataCollection = function () {
            this.gatewayCoreStore.setState(function (state) {
                state.inputs.civicPass.received = null;
            });
        };
        return Issuance;
    }(OrchestratorFlow));

    var Refresh = (function (_super) {
        __extends(Refresh, _super);
        function Refresh(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController, expectTokenTimeoutSeconds) {
            if (expectTokenTimeoutSeconds === void 0) { expectTokenTimeoutSeconds = DEFAULT_EXPECT_TOKEN_TIMEOUT_SECONDS; }
            var _this = _super.call(this, gatewayCoreStore, chainImplementation, gatekeeperClient, abortController, expectTokenTimeoutSeconds) || this;
            _this.gatewayCoreStore = gatewayCoreStore;
            _this.chainImplementation = chainImplementation;
            _this.gatekeeperClient = gatekeeperClient;
            _this.abortController = abortController;
            _this.expectTokenTimeoutSeconds = expectTokenTimeoutSeconds;
            return _this;
        }
        Refresh.prototype.clearStateBeforeGatekeeperRequest = function () {
            this.gatewayCoreStore.setState(function (state) {
                state.inputs.gatekeeperRecord.received = null;
                state.internal.chainTransaction = undefined;
                state.inputs.gatekeeperRecord.status = InputStatus.IN_PROGRESS;
            });
        };
        Refresh.prototype.gatekeeperRequest = function (payer, fullState) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, _b, _c;
                return __generator(this, function (_d) {
                    if (!((_a = fullState.inputs.civicPass.received) === null || _a === void 0 ? void 0 : _a.payload)) {
                        this.log.error('Missing civicPass payload', fullState);
                        throw new Error('Missing civicPass payload');
                    }
                    this.currentPayload = (_b = fullState.inputs.civicPass.received) === null || _b === void 0 ? void 0 : _b.payload;
                    return [2, this.gatekeeperClient.refreshToken({
                            payload: (_c = fullState.inputs.civicPass.received) === null || _c === void 0 ? void 0 : _c.payload,
                            payer: payer,
                        })];
                });
            });
        };
        Refresh.prototype.statusHasValidToken = function () {
            var updatedState = this.gatewayCoreStore.getState();
            var gatewayToken = updatedState.inputs.gatewayToken.received;
            if (!(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {
                return false;
            }
            return !!(gatewayToken &&
                !isTokenRefreshRequired({
                    gatewayToken: gatewayToken,
                    tokenExpirationMarginSeconds: 0,
                }));
        };
        return Refresh;
    }(Issuance));

    var UserInteractionStatus;
    (function (UserInteractionStatus) {
        UserInteractionStatus["STARTED"] = "started";
        UserInteractionStatus["FINISHED"] = "finished";
    })(UserInteractionStatus || (UserInteractionStatus = {}));

    var getUserInteractionStatusFromAction = function (state, action) {
        var _a, _b;
        if ([
            CivicPassMessageAction.TOKEN_ACTIVE,
            CivicPassMessageAction.TOKEN_REVOKED,
            CivicPassMessageAction.TOKEN_FROZEN,
            CivicPassMessageAction.TOKEN_REJECTED,
            CivicPassMessageAction.FAILED_IP_CHECK,
            CivicPassMessageAction.FAILED_VPN_CHECK,
            CivicPassMessageAction.ERROR,
        ].includes(action)) {
            return UserInteractionStatus.FINISHED;
        }
        return (_b = (_a = state.internal) === null || _a === void 0 ? void 0 : _a.userInteraction) === null || _b === void 0 ? void 0 : _b.status;
    };

    var PartnerReview = (function (_super) {
        __extends(PartnerReview, _super);
        function PartnerReview(gatewayCoreStore, gatekeeperClient, abortController, pollingIntervalSeconds) {
            if (pollingIntervalSeconds === void 0) { pollingIntervalSeconds = 2; }
            var _this = _super.call(this, gatewayCoreStore, gatekeeperClient, abortController) || this;
            _this.gatewayCoreStore = gatewayCoreStore;
            _this.gatekeeperClient = gatekeeperClient;
            _this.abortController = abortController;
            _this.pollingIntervalSeconds = pollingIntervalSeconds;
            _this.timers = {};
            _this.log = prefixLogger('PartnerReview instance');
            return _this;
        }
        PartnerReview.prototype.pollForReviewFinished = function () {
            return __awaiter(this, void 0, void 0, function () {
                var callGatekeeperForReviewFinished;
                var _this = this;
                return __generator(this, function (_a) {
                    this.setGatekeeperClientFlowId();
                    callGatekeeperForReviewFinished = function () { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var _a;
                        return __generator(this, function (_b) {
                            if ((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal.aborted) {
                                clearInterval(this.timers.pollForReviewFinishedTimer);
                                return [2];
                            }
                            this.gatekeeperClient.getGatekeeperRecordWithPayload().then(function (record) {
                                if (!record || (record === null || record === void 0 ? void 0 : record.state) === undefined || (record === null || record === void 0 ? void 0 : record.state) === GatekeeperAPIStatus.SERVER_FAILURE) {
                                    _this.log.error('Error polling gatekeeper, no state returned', record);
                                    clearInterval(_this.timers.pollForReviewFinishedTimer);
                                    throw new Error('Error polling gatekeeper, no state returned');
                                }
                                _this.log.debug('pollUntilNotRequested record.state', record.state);
                                if (record.state !== GatekeeperAPIStatus.REQUESTED) {
                                    _this.gatewayCoreStore.setState(function (state) {
                                        state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
                                        state.inputs.gatekeeperRecord.received = record;
                                    });
                                    clearInterval(_this.timers.pollForReviewFinishedTimer);
                                }
                            });
                            return [2];
                        });
                    }); };
                    callGatekeeperForReviewFinished();
                    this.timers.pollForReviewFinishedTimer = setInterval(callGatekeeperForReviewFinished, this.pollingIntervalSeconds * 1000);
                    return [2];
                });
            });
        };
        PartnerReview.prototype.abort = function () {
            clearInterval(this.timers.pollForReviewFinishedTimer);
        };
        return PartnerReview;
    }(OrchestratorFlow));

    var _a$2;
    var logError$1 = prefixLogger('common').error;
    var validationProcessToGatewayStatus = (_a$2 = {},
        _a$2[ValidationStatus.COLLECTING] = exports.GatewayStatus.COLLECTING_USER_INFORMATION,
        _a$2[ValidationStatus.PROCESSING] = exports.GatewayStatus.VALIDATING_USER_INFORMATION,
        _a$2[ValidationStatus.IN_REVIEW] = exports.GatewayStatus.VALIDATING_USER_INFORMATION,
        _a$2[ValidationStatus.FAILED] = exports.GatewayStatus.USER_INFORMATION_REJECTED,
        _a$2[ValidationStatus.COMPLETED] = exports.GatewayStatus.USER_INFORMATION_VALIDATED,
        _a$2);
    var payerIsWalletOwner = function (state) { var _a, _b, _c; return !!(((_a = state.inputs.parameters) === null || _a === void 0 ? void 0 : _a.payer) === ((_c = (_b = state.inputs.parameters) === null || _b === void 0 ? void 0 : _b.wallet) === null || _c === void 0 ? void 0 : _c.address)); };
    var tokenNoGatekeeperRecordError = function (state) {
        var _a, _b, _c;
        return !!(((_a = state.inputs.gatewayToken) === null || _a === void 0 ? void 0 : _a.received) &&
            ((_c = (_b = state.inputs.gatekeeperRecord) === null || _b === void 0 ? void 0 : _b.received) === null || _c === void 0 ? void 0 : _c.state) === GatekeeperAPIStatus.NOT_REQUESTED);
    };
    var statusFromGatewayTokenIfExists = function (state) {
        var _a, _b;
        var gatewayToken = (_a = state.inputs.gatewayToken) === null || _a === void 0 ? void 0 : _a.received;
        if (tokenNoGatekeeperRecordError(state)) {
            return exports.GatewayStatus.ERROR;
        }
        if (gatewayToken) {
            var tokenRefreshRequired = isTokenRefreshRequired({
                gatewayToken: gatewayToken,
                tokenExpirationMarginSeconds: 0,
                forceRequireRefresh: (_b = state.inputs.dynamicParameters) === null || _b === void 0 ? void 0 : _b.forceRequireRefresh,
            });
            switch (gatewayToken.state) {
                case 'ACTIVE':
                    return tokenRefreshRequired ? exports.GatewayStatus.REFRESH_TOKEN_REQUIRED : exports.GatewayStatus.ACTIVE;
                case 'FROZEN':
                    return exports.GatewayStatus.FROZEN;
                case 'REVOKED':
                    return exports.GatewayStatus.REVOKED;
                default:
                    logError$1("Unexpected token state: ".concat(gatewayToken.state));
                    return exports.GatewayStatus.ERROR;
            }
        }
        return undefined;
    };
    var handleGatewayTokenExistsStatus = function (state) {
        var status = statusFromGatewayTokenIfExists(state);
        if (!status) {
            logError$1('The gateway status indicated an existing token but no status could be derived');
            return exports.GatewayStatus.ERROR;
        }
        return status;
    };
    var statusIfGatekeeperRecordRejected = function (state) {
        var _a;
        var gatekeeperRecord = state.inputs.gatekeeperRecord;
        var gatewayToken = state.inputs.gatewayToken;
        var recordState = (_a = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _a === void 0 ? void 0 : _a.state;
        switch (recordState) {
            case GatekeeperAPIStatus.ISSUED_EXPIRED:
                return (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.received) ? undefined : exports.GatewayStatus.ERROR;
            case GatekeeperAPIStatus.REJECTED:
                return exports.GatewayStatus.REJECTED;
            case GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED:
            case GatekeeperAPIStatus.LOCATION_NOT_SUPPORTED:
                return exports.GatewayStatus.LOCATION_NOT_SUPPORTED;
            case GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED:
            case GatekeeperAPIStatus.VPN_NOT_SUPPORTED:
                return exports.GatewayStatus.VPN_NOT_SUPPORTED;
            case GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED:
                return exports.GatewayStatus.ERROR;
            default:
                return undefined;
        }
    };

    var Orchestrator = (function () {
        function Orchestrator(gatewayCoreStore, messageEventInterface, instanceId, inputs, fetchConfig, postMessageTargetCallback, chainImplementation) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            this.gatewayCoreStore = gatewayCoreStore;
            this.messageEventInterface = messageEventInterface;
            this.instanceId = instanceId;
            this.inputs = inputs;
            this.postMessageTargetCallback = postMessageTargetCallback;
            this.chainImplementation = chainImplementation;
            this.abortController = new AbortController();
            if (!this.chainImplementation || !((_a = inputs.wallet) === null || _a === void 0 ? void 0 : _a.address) || !inputs.stage) {
                throw new Error('chainImplementation wallet and stage are required');
            }
            this.wallet = inputs.wallet;
            this.payer = getPayer(inputs);
            this.log = prefixLogger("Orchestrator[".concat(this.instanceId, "]"));
            this.listenerManager = new ListenerManager(this.messageEventInterface, this.chainImplementation, this.instanceId);
            var chainNetwork = (_c = (_b = this.chainImplementation) === null || _b === void 0 ? void 0 : _b.chainDetails) === null || _c === void 0 ? void 0 : _c.chainNetwork;
            this.gatekeeperClient = new GatekeeperClient({
                abortController: this.abortController,
                baseUrl: (_d = inputs.gatekeeperConfig) === null || _d === void 0 ? void 0 : _d.baseUrl,
                queryParams: inputs.gatekeeperNetwork
                    ? { network: chainNetwork, gatekeeperNetworkAddress: inputs.gatekeeperNetwork }
                    : undefined,
                headers: __assign(__assign({}, (((_e = inputs.gatekeeperConfig) === null || _e === void 0 ? void 0 : _e.headers) || {})), (inputs.xCivicClientHeader ? { 'x-civic-client': inputs.xCivicClientHeader } : {})),
                stage: inputs.stage,
                fetchImplementation: fetchConfig.fetchImplementation,
                numRetries: fetchConfig.numRetries,
                walletAddress: (_f = inputs.wallet) === null || _f === void 0 ? void 0 : _f.address,
                chainType: (_h = (_g = this.chainImplementation) === null || _g === void 0 ? void 0 : _g.chainDetails) === null || _h === void 0 ? void 0 : _h.chainType,
            });
            this.log.debug('Orchestrator created');
        }
        Object.defineProperty(Orchestrator.prototype, "issuance", {
            get: function () {
                if (!this._issuance) {
                    this._issuance = new Issuance(this.gatewayCoreStore, this.chainImplementation, this.gatekeeperClient, this.abortController, this.inputs.expectTokenTimeoutSeconds);
                }
                return this._issuance;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Orchestrator.prototype, "refresh", {
            get: function () {
                if (!this._refresh) {
                    this._refresh = new Refresh(this.gatewayCoreStore, this.chainImplementation, this.gatekeeperClient, this.abortController, this.inputs.expectTokenTimeoutSeconds);
                }
                return this._refresh;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Orchestrator.prototype, "partnerReview", {
            get: function () {
                if (!this._partnerReview) {
                    this._partnerReview = new PartnerReview(this.gatewayCoreStore, this.gatekeeperClient, this.abortController, this.inputs.gatekeeperPollingIntervalSeconds);
                }
                return this._partnerReview;
            },
            enumerable: false,
            configurable: true
        });
        Orchestrator.prototype.getRemoteSignInstance = function () {
            if (!this.remoteSignInstance) {
                this.remoteSignInstance = new RemoteSignWindowEventEmitter(eventEmitter(this.postMessageTargetCallback(this.instanceId)), this.instanceId);
            }
            return this.remoteSignInstance;
        };
        Orchestrator.prototype.getOwnerDids = function () {
            return __awaiter(this, void 0, void 0, function () {
                var dids;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.chainImplementation.ownerDids()];
                        case 1:
                            dids = _a.sent();
                            this.gatewayCoreStore.setState(function (state) {
                                state.internal.ownerDids = dids;
                            });
                            return [2];
                    }
                });
            });
        };
        Orchestrator.prototype.fetchGatekeeperNetworkData = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this.gatewayCoreStore.setState(function (state) {
                        state.inputs.gatekeeperNetworkData.status = InputStatus.IN_PROGRESS;
                    });
                    return [2, getGatekeeperNetworkData(this.inputs.stage || 'prod', this.inputs.gatekeeperNetwork || '')
                            .then(function (response) {
                            _this.log.debug('getGatekeeperNetworkData', response);
                            if (_this.abortController.signal.aborted)
                                return;
                            _this.gatewayCoreStore.setState(function (state) {
                                state.inputs.gatekeeperNetworkData.status = InputStatus.COMPLETE;
                                state.inputs.gatekeeperNetworkData.received = response;
                            });
                        })
                            .catch(function (error) {
                            _this.log.error('Error retrieving gatekeeper network data', error);
                            if (_this.abortController.signal.aborted)
                                return;
                            _this.gatewayCoreStore.setState(function (state) {
                                state.inputs.gatekeeperNetworkData.status = InputStatus.ERROR;
                                state.inputs.gatekeeperNetworkData.error = error;
                            });
                        })];
                });
            });
        };
        Orchestrator.prototype.lookupTokenState = function () {
            return __awaiter(this, void 0, void 0, function () {
                var retrieveGKRecord, retrieveGatewayToken, lookupFunctions;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            retrieveGKRecord = function () { return __awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                return __generator(this, function (_a) {
                                    this.gatewayCoreStore.setState(function (state) {
                                        state.inputs.gatekeeperRecord.status = InputStatus.IN_PROGRESS;
                                    });
                                    return [2, this.gatekeeperClient
                                            .getGatekeeperRecordWithPayload()
                                            .then(function (response) {
                                            _this.log.debug('getGatekeeperRecordWithPayload record', response);
                                            if (_this.abortController.signal.aborted)
                                                return;
                                            _this.gatewayCoreStore.setState(function (state) {
                                                state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
                                                state.inputs.gatekeeperRecord.received = response;
                                            });
                                        })
                                            .catch(function (error) {
                                            _this.log.error('Error retrieving gatekeeper record', error);
                                            if (_this.abortController.signal.aborted)
                                                return;
                                            _this.gatewayCoreStore.setState(function (state) {
                                                state.inputs.gatekeeperRecord.status = InputStatus.ERROR;
                                                state.inputs.gatekeeperRecord.error = error;
                                            });
                                        })];
                                });
                            }); };
                            retrieveGatewayToken = function () { return __awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                return __generator(this, function (_a) {
                                    this.gatewayCoreStore.setState(function (state) {
                                        state.inputs.gatewayToken.status = InputStatus.IN_PROGRESS;
                                    });
                                    return [2, this.chainImplementation
                                            .findGatewayToken()
                                            .then(function (response) {
                                            if (_this.abortController.signal.aborted)
                                                return;
                                            _this.gatewayCoreStore.setState(function (state) {
                                                state.inputs.gatewayToken.status = InputStatus.COMPLETE;
                                                if (response) {
                                                    state.inputs.gatewayToken.received = response;
                                                }
                                            });
                                        })
                                            .catch(function (error) {
                                            if (_this.abortController.signal.aborted)
                                                return;
                                            _this.log.error('Error retrieving gateway token', error);
                                            _this.gatewayCoreStore.setState(function (state) {
                                                state.inputs.gatewayToken.status = InputStatus.ERROR;
                                                state.inputs.gatewayToken.error = error;
                                            });
                                        })];
                                });
                            }); };
                            lookupFunctions = [retrieveGatewayToken()];
                            if (!this.inputs.disableInitialGatekeeperLookup) {
                                lookupFunctions.push(retrieveGKRecord());
                            }
                            return [4, Promise.allSettled(lookupFunctions)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        Orchestrator.prototype.initialise = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.log.debug('Initialising orchestrator');
                            this.abortController = new AbortController();
                            this.remoteSignInstance = undefined;
                            this.gatewayCoreStore.getState().functions.reset();
                            return [4, Promise.allSettled([
                                    this.getOwnerDids(),
                                    this.lookupTokenState(),
                                    this.fetchGatekeeperNetworkData(),
                                ])];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        Orchestrator.prototype.reset = function () {
            this.log.debug('resetting orchestrator');
            this.initialise();
        };
        Orchestrator.prototype.onInternalStatusChange = function (status, previousStatus) {
            var _a, _b;
            if (status === exports.GatewayStatus.ERROR) {
                var fullState = this.gatewayCoreStore.getState();
                if (tokenNoGatekeeperRecordError(fullState)) {
                    this.gatewayCoreStore.setState(function (state) {
                        if (!state.internal.errors) {
                            state.internal.errors = {};
                        }
                        state.internal.errors.expectedTokenGatekeeperRecord = new ChainError('Token has no gatekeeper record', ErrorCode.EXPECTED_GATEKEEPER_RECORD);
                    });
                }
                return;
            }
            if (status === exports.GatewayStatus.ACTIVE) {
                if (previousStatus !== exports.GatewayStatus.ACTIVE) {
                    (_a = this._refresh) === null || _a === void 0 ? void 0 : _a.onActiveTokenFound();
                    if (!this._refresh) {
                        (_b = this._issuance) === null || _b === void 0 ? void 0 : _b.onActiveTokenFound();
                    }
                }
                return;
            }
            if (status === exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION) {
                return this.issuance.restartDataCollection();
            }
            if (status === exports.GatewayStatus.USER_INFORMATION_VALIDATED) {
                return this.issuance.makeGatekeeperRequest({ payer: this.payer });
            }
            if ([
                exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX,
                exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            ].includes(status)) {
                return this.issuance.makeGatekeeperRequest({ payer: this.payer, isFreshTransactionRequest: true });
            }
            if ([
                exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
                exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            ].includes(status)) {
                return this.issuance.sendTransaction();
            }
            if (status === exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN) {
                return this.issuance.expectOnChainToken();
            }
            if (status === exports.ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED) {
                return this.refresh.makeGatekeeperRequest({ payer: this.payer });
            }
            if ([
                exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX,
                exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            ].includes(status)) {
                return this.refresh.makeGatekeeperRequest({ payer: this.payer, isFreshTransactionRequest: true });
            }
            if (status === exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND) {
                return this.refresh.sendTransaction();
            }
            if (status === exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN) {
                return this.refresh.expectOnChainToken();
            }
            if (status === exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW) {
                return this.partnerReview.pollForReviewFinished();
            }
            if ([exports.ExtendedGatewayStatus.RESTART, exports.ExtendedGatewayStatus.RESTART_REFRESH].includes(status)) {
                return this.reset();
            }
        };
        Orchestrator.prototype.orchestrate = function () {
            var _this = this;
            this.log.debug('running orchestrate()');
            this.gatewayCoreStore.subscribe(function (state) { return state.internal.status; }, function (status, previousStatus) { return _this.onInternalStatusChange(status, previousStatus); });
            this.gatewayCoreStore.subscribe(function (state) { var _a; return (_a = state.inputs.gatewayToken.received) === null || _a === void 0 ? void 0 : _a.expiryTime; }, function (expiryTime, previousExpiryTime) {
                if (expiryTime && previousExpiryTime && expiryTime > previousExpiryTime) {
                    _this.gatewayCoreStore.setState(function (state) {
                        var _a;
                        if (((_a = state.inputs.dynamicParameters) === null || _a === void 0 ? void 0 : _a.forceRequireRefresh) !== undefined) {
                            state.inputs.dynamicParameters.forceRequireRefresh = false;
                        }
                    });
                }
            });
            this.gatewayCoreStore.subscribe(function (state) { return state.inputs.civicPass.received; }, function (civicPass) {
                return _this.gatewayCoreStore.setState(function (state) {
                    var userIteractionStatus = getUserInteractionStatusFromAction(state, civicPass === null || civicPass === void 0 ? void 0 : civicPass.action);
                    state.internal.userInteraction.status = userIteractionStatus;
                });
            });
            this.listenerManager.registerCivicPassListener(function (response) {
                _this.gatewayCoreStore.setState(function (state) {
                    state.inputs.civicPass.status = InputStatus.COMPLETE;
                    state.inputs.civicPass.received = response;
                });
            });
            this.listenerManager.registerCivicSignListener(function (response) {
                _this.gatewayCoreStore.setState(function (state) {
                    state.inputs.civicSign.status = InputStatus.RECEIVED;
                    state.inputs.civicSign.received = response;
                });
                var ownerDids = _this.gatewayCoreStore.getState().internal.ownerDids;
                handleRemoteSignEvent(response, _this.getRemoteSignInstance(), {
                    chainImplementation: _this.chainImplementation,
                    wallet: _this.wallet,
                    ownerDids: ownerDids,
                })
                    .then(function (result) {
                    if (!result) {
                        _this.log.warn('No result from remote sign event');
                    }
                    _this.gatewayCoreStore.setState(function (draft) {
                        draft.inputs.civicSign.received = null;
                        draft.inputs.civicSign.sent = result;
                        draft.inputs.civicSign.error = null;
                        draft.inputs.civicSign.status = InputStatus.RESPONDED;
                    });
                })
                    .catch(function (error) {
                    _this.gatewayCoreStore.setState(function (draft) {
                        var useError = !!error.errorCode
                            ? error
                            : new ChainError('handleRemoteSignEvent failed', ErrorCode.POWO_ERROR);
                        draft.inputs.civicSign.error = useError;
                        draft.inputs.civicSign.status = InputStatus.ERROR;
                    });
                });
            });
            this.listenerManager.registerOnChainListeners(function (gatewayToken) {
                _this.gatewayCoreStore.setState(function (state) {
                    state.inputs.gatewayToken.received = gatewayToken;
                });
            });
        };
        Orchestrator.prototype.abort = function () {
            var _a, _b, _c;
            this.log.info('Aborting orchestration');
            this.chainImplementation.onDestroy();
            (_a = this._issuance) === null || _a === void 0 ? void 0 : _a.abort();
            (_b = this._refresh) === null || _b === void 0 ? void 0 : _b.abort();
            (_c = this._partnerReview) === null || _c === void 0 ? void 0 : _c.abort();
            this.abortController.abort();
            this.gatekeeperClient.abort();
            this.listenerManager.unregisterAllListeners();
        };
        return Orchestrator;
    }());

    const createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const getInitialState = () => initialState;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if ((undefined ? undefined.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, getInitialState, subscribe, destroy };
      const initialState = state = createState(setState, getState, api);
      return api;
    };
    const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

    // src/utils/env.ts
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");

    // src/utils/errors.ts
    var errors = process.env.NODE_ENV !== "production" ? [
      // All error codes, starting by 0:
      function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
      },
      function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
      },
      "This object has been frozen and should not be mutated",
      function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      "Immer forbids circular references",
      "The first or second argument to `produce` must be a function",
      "The third argument to `produce` must be a function or undefined",
      "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      "First argument to `finishDraft` must be a draft returned by `createDraft`",
      function(thing) {
        return `'current' expects a draft, got: ${thing}`;
      },
      "Object.defineProperty() cannot be used on an Immer draft",
      "Object.setPrototypeOf() cannot be used on an Immer draft",
      "Immer only supports deleting array indices",
      "Immer only supports setting array indices and the 'length' property",
      function(thing) {
        return `'original' expects a draft, got: ${thing}`;
      }
      // Note: if more errors are added, the errorOffset in Patches.ts should be increased
      // See Patches.ts for additional errors
    ] : [];
    function die(error, ...args) {
      if (process.env.NODE_ENV !== "production") {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error(`[Immer] ${msg}`);
      }
      throw new Error(
        `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
      );
    }

    // src/utils/common.ts
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      const proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function each(obj, iter) {
      if (getArchtype(obj) === 0 /* Object */) {
        Reflect.ownKeys(obj).forEach((key) => {
          iter(key, obj[key], obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function set(thing, propOrOldValue, value) {
      const t = getArchtype(thing);
      if (t === 2 /* Map */)
        thing.set(propOrOldValue, value);
      else if (t === 3 /* Set */) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target) {
      return target instanceof Map;
    }
    function isSet(target) {
      return target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base, strict) {
      if (isMap(base)) {
        return new Map(base);
      }
      if (isSet(base)) {
        return new Set(base);
      }
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      if (!strict && isPlainObject(base)) {
        if (!getPrototypeOf(base)) {
          const obj = /* @__PURE__ */ Object.create(null);
          return Object.assign(obj, base);
        }
        return { ...base };
      }
      const descriptors = Object.getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      let keys = Reflect.ownKeys(descriptors);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(getPrototypeOf(base), descriptors);
    }
    function freeze(obj, deep = false) {
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        Object.entries(obj).forEach(([key, value]) => freeze(value, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      return Object.isFrozen(obj);
    }

    // src/utils/plugins.ts
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }

    // src/core/scope.ts
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)
        state.revoke_();
      else
        state.revoked_ = true;
    }

    // src/core/finalize.ts
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      const baseDraft = scope.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope.patches_,
            scope.inversePatches_
          );
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3 /* Set */) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
        );
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (process.env.NODE_ENV !== "production" && childValue === targetObject)
        die(5);
      if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep = false) {
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }

    // src/core/proxy.ts
    function createProxyProxy(base, parent) {
      const isArray = Array.isArray(base);
      const state = {
        type_: isArray ? 1 /* Array */ : 0 /* Object */,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target = state;
      let traps = objectTraps;
      if (isArray) {
        target = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop) {
        return prop in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc?.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek(latest(state), prop);
          const currentState = current2?.[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 /* Array */ || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key, fn) => {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      const state = draft[DRAFT_STATE];
      const source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      const desc = getDescriptorFromProto(source, prop);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        desc.get?.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      let proto = getPrototypeOf(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }

    // src/core/immerClass.ts
    var Immer2 = class {
      constructor(config) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        /**
         * The `produce` function takes a value and a "recipe function" (whose
         * return value often depends on the base state). The recipe function is
         * free to mutate its first argument however it wants. All mutations are
         * only ever applied to a __copy__ of the base state.
         *
         * Pass only a function to create a "curried producer" which relieves you
         * from passing the recipe function every time.
         *
         * Only plain objects and arrays are made mutable. All other objects are
         * considered uncopyable.
         *
         * Note: This function is __bound__ to its `Immer` instance.
         *
         * @param {any} base - the initial state
         * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
         * @param {Function} patchListener - optional function that will be called with all the patches produced here
         * @returns {any} a new state, or the initial state if nothing was modified
         */
        this.produce = (base, recipe, patchListener) => {
          if (typeof base === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base;
            const self = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base)) {
            const scope = enterScope(this);
            const proxy = createProxy(base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              const p = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (typeof base === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p, ip) => {
            patches = p;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof config?.autoFreeze === "boolean")
          this.setAutoFreeze(config.autoFreeze);
        if (typeof config?.useStrictShallowCopy === "boolean")
          this.setUseStrictShallowCopy(config.useStrictShallowCopy);
      }
      createDraft(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      applyPatches(base, patches) {
        let i;
        for (i = patches.length - 1; i >= 0; i--) {
          const patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value, parent) {
      const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
      const scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }

    // src/core/current.ts
    function current(value) {
      if (!isDraft(value))
        die(10, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value) || isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      let copy;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
      } else {
        copy = shallowCopy(value, true);
      }
      each(copy, (key, childValue) => {
        set(copy, key, currentImpl(childValue));
      });
      if (state) {
        state.finalized_ = false;
      }
      return copy;
    }

    // src/immer.ts
    var immer$1 = new Immer2();
    var produce = immer$1.produce;
    immer$1.produceWithPatches.bind(
      immer$1
    );
    immer$1.setAutoFreeze.bind(immer$1);
    immer$1.setUseStrictShallowCopy.bind(immer$1);
    immer$1.applyPatches.bind(immer$1);
    immer$1.createDraft.bind(immer$1);
    immer$1.finishDraft.bind(immer$1);

    const immerImpl = (initializer) => (set, get, store) => {
      store.setState = (updater, replace, ...a) => {
        const nextState = typeof updater === "function" ? produce(updater) : updater;
        return set(nextState, replace, ...a);
      };
      return initializer(store.setState, get, store);
    };
    const immer = immerImpl;

    const trackedConnections = /* @__PURE__ */ new Map();
    const getTrackedConnectionState = (name) => {
      const api = trackedConnections.get(name);
      if (!api)
        return {};
      return Object.fromEntries(
        Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
      );
    };
    const extractConnectionInformation = (store, extensionConnector, options) => {
      if (store === void 0) {
        return {
          type: "untracked",
          connection: extensionConnector.connect(options)
        };
      }
      const existingConnection = trackedConnections.get(options.name);
      if (existingConnection) {
        return { type: "tracked", store, ...existingConnection };
      }
      const newConnection = {
        connection: extensionConnector.connect(options),
        stores: {}
      };
      trackedConnections.set(options.name, newConnection);
      return { type: "tracked", store, ...newConnection };
    };
    const devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
      const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
      let extensionConnector;
      try {
        extensionConnector = (enabled != null ? enabled : (undefined ? undefined.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
      } catch (e) {
      }
      if (!extensionConnector) {
        if ((undefined ? undefined.MODE : void 0) !== "production" && enabled) {
          console.warn(
            "[zustand devtools middleware] Please install/enable Redux devtools extension"
          );
        }
        return fn(set, get, api);
      }
      const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
      let isRecording = true;
      api.setState = (state, replace, nameOrAction) => {
        const r = set(state, replace);
        if (!isRecording)
          return r;
        const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
        if (store === void 0) {
          connection == null ? void 0 : connection.send(action, get());
          return r;
        }
        connection == null ? void 0 : connection.send(
          {
            ...action,
            type: `${store}/${action.type}`
          },
          {
            ...getTrackedConnectionState(options.name),
            [store]: api.getState()
          }
        );
        return r;
      };
      const setStateFromDevtools = (...a) => {
        const originalIsRecording = isRecording;
        isRecording = false;
        set(...a);
        isRecording = originalIsRecording;
      };
      const initialState = fn(api.setState, get, api);
      if (connectionInformation.type === "untracked") {
        connection == null ? void 0 : connection.init(initialState);
      } else {
        connectionInformation.stores[connectionInformation.store] = api;
        connection == null ? void 0 : connection.init(
          Object.fromEntries(
            Object.entries(connectionInformation.stores).map(([key, store2]) => [
              key,
              key === connectionInformation.store ? initialState : store2.getState()
            ])
          )
        );
      }
      if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
        let didWarnAboutReservedActionType = false;
        const originalDispatch = api.dispatch;
        api.dispatch = (...a) => {
          if ((undefined ? undefined.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
            console.warn(
              '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
            );
            didWarnAboutReservedActionType = true;
          }
          originalDispatch(...a);
        };
      }
      connection.subscribe((message) => {
        var _a;
        switch (message.type) {
          case "ACTION":
            if (typeof message.payload !== "string") {
              console.error(
                "[zustand devtools middleware] Unsupported action format"
              );
              return;
            }
            return parseJsonThen(
              message.payload,
              (action) => {
                if (action.type === "__setState") {
                  if (store === void 0) {
                    setStateFromDevtools(action.state);
                    return;
                  }
                  if (Object.keys(action.state).length !== 1) {
                    console.error(
                      `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                    );
                  }
                  const stateFromDevtools = action.state[store];
                  if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                    return;
                  }
                  if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                    setStateFromDevtools(stateFromDevtools);
                  }
                  return;
                }
                if (!api.dispatchFromDevtools)
                  return;
                if (typeof api.dispatch !== "function")
                  return;
                api.dispatch(action);
              }
            );
          case "DISPATCH":
            switch (message.payload.type) {
              case "RESET":
                setStateFromDevtools(initialState);
                if (store === void 0) {
                  return connection == null ? void 0 : connection.init(api.getState());
                }
                return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              case "COMMIT":
                if (store === void 0) {
                  connection == null ? void 0 : connection.init(api.getState());
                  return;
                }
                return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              case "ROLLBACK":
                return parseJsonThen(message.state, (state) => {
                  if (store === void 0) {
                    setStateFromDevtools(state);
                    connection == null ? void 0 : connection.init(api.getState());
                    return;
                  }
                  setStateFromDevtools(state[store]);
                  connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                });
              case "JUMP_TO_STATE":
              case "JUMP_TO_ACTION":
                return parseJsonThen(message.state, (state) => {
                  if (store === void 0) {
                    setStateFromDevtools(state);
                    return;
                  }
                  if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                    setStateFromDevtools(state[store]);
                  }
                });
              case "IMPORT_STATE": {
                const { nextLiftedState } = message.payload;
                const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
                if (!lastComputedState)
                  return;
                if (store === void 0) {
                  setStateFromDevtools(lastComputedState);
                } else {
                  setStateFromDevtools(lastComputedState[store]);
                }
                connection == null ? void 0 : connection.send(
                  null,
                  // FIXME no-any
                  nextLiftedState
                );
                return;
              }
              case "PAUSE_RECORDING":
                return isRecording = !isRecording;
            }
            return;
        }
      });
      return initialState;
    };
    const devtools = devtoolsImpl;
    const parseJsonThen = (stringified, f) => {
      let parsed;
      try {
        parsed = JSON.parse(stringified);
      } catch (e) {
        console.error(
          "[zustand devtools middleware] Could not parse the received json",
          e
        );
      }
      if (parsed !== void 0)
        f(parsed);
    };

    const subscribeWithSelectorImpl = (fn) => (set, get, api) => {
      const origSubscribe = api.subscribe;
      api.subscribe = (selector, optListener, options) => {
        let listener = selector;
        if (optListener) {
          const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
          let currentSlice = selector(api.getState());
          listener = (state) => {
            const nextSlice = selector(state);
            if (!equalityFn(currentSlice, nextSlice)) {
              const previousSlice = currentSlice;
              optListener(currentSlice = nextSlice, previousSlice);
            }
          };
          if (options == null ? void 0 : options.fireImmediately) {
            optListener(currentSlice, currentSlice);
          }
        }
        return origSubscribe(listener);
      };
      const initialState = fn(set, get, api);
      return initialState;
    };
    const subscribeWithSelector = subscribeWithSelectorImpl;

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }

    var prefix = '$$_computed_';
    function injectComputedMiddleware(f) {
      return function (set, get, api) {
        var _st$prefix;
        var setWithComputed = function setWithComputed(update, replace) {
          set(function (state) {
            var _state$prefix;
            var updated = typeof update === 'object' ? update : update(state);
            var computedSt = (_state$prefix = state[prefix]) == null ? void 0 : _state$prefix.call(state, updated);
            return _extends({}, state, updated, computedSt);
          }, replace);
        };
        api.setState = setWithComputed;
        var st = f(setWithComputed, get, api);
        var computedSt = (_st$prefix = st[prefix]) == null ? void 0 : _st$prefix.call(st, st);
        return Object.assign({}, st, computedSt);
      };
    }
    function compute(
    // @ts-ignore
    get, fn) {
      var _ref;
      return _ref = {}, _ref[prefix] = fn, _ref;
    }
    var computed = function computed(f) {
      return injectComputedMiddleware(f);
    };

    var _a$1;
    var gatewayStatusToCivicPassAction = (_a$1 = {},
        _a$1[exports.GatewayStatus.IN_REVIEW] = CivicPassMessageAction.TOKEN_IN_REVIEW,
        _a$1[exports.GatewayStatus.ERROR] = CivicPassMessageAction.ERROR,
        _a$1[exports.GatewayStatus.ACTIVE] = CivicPassMessageAction.TOKEN_ACTIVE,
        _a$1[exports.GatewayStatus.REVOKED] = CivicPassMessageAction.TOKEN_REVOKED,
        _a$1[exports.GatewayStatus.FROZEN] = CivicPassMessageAction.TOKEN_FROZEN,
        _a$1[exports.GatewayStatus.REJECTED] = CivicPassMessageAction.TOKEN_REJECTED,
        _a$1[exports.GatewayStatus.LOCATION_NOT_SUPPORTED] = CivicPassMessageAction.TOKEN_REJECTED,
        _a$1[exports.GatewayStatus.VPN_NOT_SUPPORTED] = CivicPassMessageAction.TOKEN_REJECTED,
        _a$1[exports.GatewayStatus.REFRESH_TOKEN_REQUIRED] = CivicPassMessageAction.REFRESH,
        _a$1[exports.GatewayStatus.CHECKING] = CivicPassMessageAction.STATUS,
        _a$1[exports.GatewayStatus.UNKNOWN] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.GatewayStatus.NOT_REQUESTED] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.GatewayStatus.COLLECTING_USER_INFORMATION] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.GatewayStatus.VALIDATING_USER_INFORMATION] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.GatewayStatus.USER_INFORMATION_VALIDATED] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.GatewayStatus.USER_INFORMATION_REJECTED] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND] = CivicPassMessageAction.TOKEN_IN_REVIEW,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN] = CivicPassMessageAction.AWAITING_TRANSACTION_CONFIRMATION,
        _a$1[exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION] = CivicPassMessageAction.AWAITING_TRANSACTION_CONFIRMATION,
        _a$1[exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR] = CivicPassMessageAction.CHAIN_ERROR,
        _a$1[exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR] = CivicPassMessageAction.CHAIN_ERROR,
        _a$1[exports.ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR] = CivicPassMessageAction.CHAIN_ERROR,
        _a$1[exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW] = CivicPassMessageAction.TOKEN_IN_PARTNER_REVIEW,
        _a$1[exports.ExtendedGatewayStatus.TOKEN_REFRESH_IN_REVIEW] = CivicPassMessageAction.TOKEN_REFRESH_IN_REVIEW,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN] = CivicPassMessageAction.AWAITING_TRANSACTION_CONFIRMATION,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED] = CivicPassMessageAction.REFRESH,
        _a$1[exports.ExtendedGatewayStatus.RESTART] = CivicPassMessageAction.ISSUANCE,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_IN_REVIEW] = CivicPassMessageAction.REFRESH,
        _a$1[exports.ExtendedGatewayStatus.RESTART_REFRESH] = CivicPassMessageAction.REFRESH,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND] = CivicPassMessageAction.TOKEN_REFRESH_IN_REVIEW,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX] = CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX] = CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX] = CivicPassMessageAction.SIGN_TRANSACTION,
        _a$1[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX] = CivicPassMessageAction.TOKEN_IN_REVIEW,
        _a$1[exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX] = CivicPassMessageAction.TOKEN_REFRESH_IN_REVIEW,
        _a$1);
    var internalToOutputGatewayStatus = function (internalStatus) {
        switch (internalStatus) {
            case exports.ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR:
                return exports.GatewayStatus.ERROR;
            case exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR:
                return exports.GatewayStatus.ERROR;
            case exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.TOKEN_REFRESH_IN_REVIEW:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.RESTART:
                return exports.GatewayStatus.NOT_REQUESTED;
            case exports.ExtendedGatewayStatus.RESTART_REFRESH:
                return exports.GatewayStatus.REFRESH_TOKEN_REQUIRED;
            case exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED:
                return exports.GatewayStatus.USER_INFORMATION_REJECTED;
            case exports.ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR:
                return exports.GatewayStatus.ERROR;
            case exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION:
                return exports.GatewayStatus.NOT_REQUESTED;
            case exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED:
                return exports.GatewayStatus.USER_INFORMATION_VALIDATED;
            case exports.ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_IN_REVIEW:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX:
                return exports.GatewayStatus.USER_INFORMATION_VALIDATED;
            case exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX:
                return exports.GatewayStatus.USER_INFORMATION_VALIDATED;
            case exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX:
                return exports.GatewayStatus.IN_REVIEW;
            case exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX:
                return exports.GatewayStatus.IN_REVIEW;
            default:
                return internalStatus;
        }
    };

    var DEFAULT_FLOW_ID_PREFIX = 'GWC';
    var flowTypeFromState = function (state, computedInternalStatus) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if ((_a = state.inputs.gatewayToken) === null || _a === void 0 ? void 0 : _a.received) {
            var tokenRefreshRequired = isTokenRefreshRequired({
                gatewayToken: (_b = state.inputs.gatewayToken) === null || _b === void 0 ? void 0 : _b.received,
                tokenExpirationMarginSeconds: 0,
                forceRequireRefresh: (_d = (_c = state.inputs) === null || _c === void 0 ? void 0 : _c.dynamicParameters) === null || _d === void 0 ? void 0 : _d.forceRequireRefresh,
            });
            if (tokenRefreshRequired ||
                ((_e = state.internal.status) === null || _e === void 0 ? void 0 : _e.toLowerCase().includes('refresh')) ||
                computedInternalStatus.toLowerCase().includes('refresh')) {
                return exports.FlowType.REFRESH;
            }
            if ((_g = (_f = state.output) === null || _f === void 0 ? void 0 : _f.flowParameters) === null || _g === void 0 ? void 0 : _g.flowId.toLowerCase().includes(exports.FlowType.REFRESH.toLowerCase())) {
                return exports.FlowType.REFRESH;
            }
            if ((_j = (_h = state.output) === null || _h === void 0 ? void 0 : _h.flowParameters) === null || _j === void 0 ? void 0 : _j.flowId.toLowerCase().includes(exports.FlowType.ISSUANCE.toLowerCase())) {
                return exports.FlowType.ISSUANCE;
            }
            return exports.FlowType.STATUS;
        }
        if ([exports.GatewayStatus.CHECKING, exports.GatewayStatus.UNKNOWN].includes(computedInternalStatus)) {
            return exports.FlowType.STATUS;
        }
        return exports.FlowType.ISSUANCE;
    };
    var getFlowId = function (state, computedInternalStatus) {
        var _a, _b, _c;
        var existingFlowId = (_b = (_a = state.output) === null || _a === void 0 ? void 0 : _a.flowParameters) === null || _b === void 0 ? void 0 : _b.flowId;
        var flowType = flowTypeFromState(state, computedInternalStatus);
        var prefix = "".concat(flowType, "_");
        return !existingFlowId || existingFlowId === '' || !existingFlowId.includes(prefix)
            ? "".concat(((_c = state.inputs.parameters) === null || _c === void 0 ? void 0 : _c.flowIdPrefix) || DEFAULT_FLOW_ID_PREFIX, "_").concat(prefix).concat(v4())
            : existingFlowId;
    };
    var initialFlowResultStatuses = [
        exports.GatewayStatus.REFRESH_TOKEN_REQUIRED,
        exports.GatewayStatus.FROZEN,
        exports.GatewayStatus.REVOKED,
        exports.GatewayStatus.ERROR,
    ];
    var flowResultsStatuses = [
        exports.GatewayStatus.ACTIVE,
        exports.GatewayStatus.REFRESH_TOKEN_REQUIRED,
        exports.GatewayStatus.FROZEN,
        exports.GatewayStatus.REVOKED,
        exports.GatewayStatus.ERROR,
    ];
    var flowStatusFromState = function (state, computedInternalStatus) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!((_a = state.internal) === null || _a === void 0 ? void 0 : _a.userInteraction)) {
            return undefined;
        }
        var previousStatus = state.internal.status;
        if ((previousStatus === exports.GatewayStatus.CHECKING && initialFlowResultStatuses.includes(computedInternalStatus)) ||
            (previousStatus !== exports.GatewayStatus.CHECKING &&
                flowResultsStatuses.includes(computedInternalStatus) &&
                !flowResultsStatuses.includes(previousStatus)) ||
            (previousStatus === exports.GatewayStatus.ACTIVE && ((_c = (_b = state.inputs) === null || _b === void 0 ? void 0 : _b.dynamicParameters) === null || _c === void 0 ? void 0 : _c.forceRequireRefresh))) {
            if (((_f = (_e = (_d = state.inputs.gatekeeperNetworkData) === null || _d === void 0 ? void 0 : _d.received) === null || _e === void 0 ? void 0 : _e.client) === null || _f === void 0 ? void 0 : _f.tokenActiveDisplay) === 'hidden') {
                return exports.FlowStatus.FINISHED;
            }
            return exports.FlowStatus.RESULT;
        }
        if (((_g = state.internal) === null || _g === void 0 ? void 0 : _g.userInteraction.status) === UserInteractionStatus.FINISHED) {
            return exports.FlowStatus.FINISHED;
        }
        if (previousStatus === exports.GatewayStatus.ACTIVE &&
            ((_k = (_j = (_h = state.inputs.gatekeeperNetworkData) === null || _h === void 0 ? void 0 : _h.received) === null || _j === void 0 ? void 0 : _j.client) === null || _k === void 0 ? void 0 : _k.tokenActiveDisplay) === 'hidden' &&
            ((_m = (_l = state.internal) === null || _l === void 0 ? void 0 : _l.userInteraction) === null || _m === void 0 ? void 0 : _m.status) === null) {
            return exports.FlowStatus.FINISHED;
        }
        if (computedInternalStatus === exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED) {
            return exports.FlowStatus.FINISHED;
        }
        if (((_o = state.internal) === null || _o === void 0 ? void 0 : _o.userInteraction.status) === UserInteractionStatus.STARTED) {
            return exports.FlowStatus.IN_PROGRESS;
        }
        return (_q = (_p = state.output) === null || _p === void 0 ? void 0 : _p.flowState) === null || _q === void 0 ? void 0 : _q.status;
    };

    var handleChainError = function (state) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (((_a = state.inputs.civicPass.received) === null || _a === void 0 ? void 0 : _a.event) === CivicPassMessageEventResult.FAILURE &&
            ((_b = state.inputs.civicPass.received) === null || _b === void 0 ? void 0 : _b.action) === CivicPassMessageAction.CHAIN_ERROR) {
            var isRefreshFlow = !!((_c = state.inputs.gatewayToken) === null || _c === void 0 ? void 0 : _c.received);
            if (((_d = state.internal.chainTransaction) === null || _d === void 0 ? void 0 : _d.error) &&
                (state.internal.chainTransaction.attempts || 0) <=
                    (((_f = (_e = state.inputs.parameters) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.clientSendsMaxRetries) || DEFAULT_MAX_CLIENT_SENDS_RETRIES)) {
                if (isRefreshFlow) {
                    return payerIsWalletOwner(state)
                        ? exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND
                        : exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
                }
                return payerIsWalletOwner(state)
                    ? exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND
                    : exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
            }
            if (isRefreshFlow) {
                return payerIsWalletOwner(state)
                    ? exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
                    : exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
            }
            return payerIsWalletOwner(state)
                ? exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
                : exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
        }
        return (_g = state.internal) === null || _g === void 0 ? void 0 : _g.status;
    };
    var handleGatekeeperError = function (state) {
        var _a, _b, _c;
        var isRefreshFlow = !!state.inputs.gatewayToken.received;
        if (((_a = state.inputs.civicPass.received) === null || _a === void 0 ? void 0 : _a.event) === CivicPassMessageEventResult.FAILURE &&
            ((_b = state.inputs.civicPass.received) === null || _b === void 0 ? void 0 : _b.action) === CivicPassMessageAction.ERROR) {
            return isRefreshFlow ? exports.ExtendedGatewayStatus.RESTART_REFRESH : exports.ExtendedGatewayStatus.RESTART;
        }
        return (_c = state.internal) === null || _c === void 0 ? void 0 : _c.status;
    };
    var handleUserValidationFailed = function (state) {
        var _a, _b;
        return ((_b = (_a = state.inputs.parameters) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.disableAutoRestartOnValidationFailure)
            ? exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED
            : exports.ExtendedGatewayStatus.RESTART;
    };

    var getPendingRequestFromGatekeeperRecord = function (gatekeeperRecord) { var _a, _b, _c; return (((_b = (_a = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.pending) || ((_c = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _c === void 0 ? void 0 : _c.pending)); };

    var calculateIssuanceStartPreApprovedTransaction = function (state) {
        var _a;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.payload) !== undefined) {
            return payerIsWalletOwner(state)
                ? exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
                : exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
        }
    };
    var hasExistingDataCollectionProcessInProgress = function (civicPassEvent) {
        var _a;
        return ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.STATUS &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS &&
            ((_a = civicPassEvent.payload) === null || _a === void 0 ? void 0 : _a.status) !== ValidationStatus.NOT_FOUND) ||
            ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.ISSUANCE &&
                (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.IN_PROGRESS);
    };
    var isInPartnerReview = function (gatekeeperRecord) {
        return !!getPendingRequestFromGatekeeperRecord(gatekeeperRecord);
    };
    var preApprovedTxAvailable = function (gatekeeperRecord) {
        var _a, _b;
        return !!((_b = (_a = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.preApprovedTxAvailable);
    };
    var calculateFromIssuanceAwaitingOnChain = function (state) {
        var _a, _b;
        if (((_b = (_a = state.internal.errors) === null || _a === void 0 ? void 0 : _a.expectedOnChainToken) === null || _b === void 0 ? void 0 : _b.errorCode) ===
            ErrorCode.CHAIN_CONFIRMATION_TIMEOUT_ERROR) {
            return exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR;
        }
    };
    var calculateFromIssuanceInReview = function (state) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        var gatekeeperRecord = state.inputs.gatekeeperRecord;
        if ((gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.status) === InputStatus.IN_PROGRESS) {
            return state.internal.status;
        }
        if (isInPartnerReview(gatekeeperRecord)) {
            return exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW;
        }
        if ((_b = state.inputs.parameters) === null || _b === void 0 ? void 0 : _b.payer) {
            if ((gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.status) === InputStatus.COMPLETE &&
                (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) !== CivicPassMessageAction.ISSUANCE &&
                !((_c = gatekeeperRecord.received) === null || _c === void 0 ? void 0 : _c.transaction)) {
                return exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION;
            }
            if ((_e = (_d = state.internal) === null || _d === void 0 ? void 0 : _d.chainTransaction) === null || _e === void 0 ? void 0 : _e.sentTxId) {
                return exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
            }
            if ((_g = (_f = state.internal) === null || _f === void 0 ? void 0 : _f.chainTransaction) === null || _g === void 0 ? void 0 : _g.error) {
                return exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR;
            }
            if ((_h = gatekeeperRecord.received) === null || _h === void 0 ? void 0 : _h.transaction) {
                if (payerIsWalletOwner(state)) {
                    return exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND;
                }
                return exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
            }
            return undefined;
        }
        return exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
    };
    var calculateFromGatekeeperIssuanceRequested = function (state) {
        var _a, _b, _c;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        var gatekeeperRecord = state.inputs.gatekeeperRecord;
        if (civicPassEvent &&
            (((_b = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _b === void 0 ? void 0 : _b.state) === GatekeeperAPIStatus.REQUESTED ||
                (gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.status) === InputStatus.IN_PROGRESS)) {
            return ((_c = state.inputs.parameters) === null || _c === void 0 ? void 0 : _c.payer) && payerIsWalletOwner(state)
                ? exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED
                : exports.GatewayStatus.IN_REVIEW;
        }
    };
    var calculateIssuanceRequestedDataCollectionRestart = function (state) {
        var _a, _b;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.FAILURE) {
            return exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED;
        }
        var gatewayStatusFromValidationProcess = validationProcessToGatewayStatus[(_b = civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.payload) === null || _b === void 0 ? void 0 : _b.status];
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.STATUS &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS &&
            gatewayStatusFromValidationProcess) {
            if (gatewayStatusFromValidationProcess === exports.GatewayStatus.USER_INFORMATION_VALIDATED) {
                return civicPassEvent.payload ? exports.GatewayStatus.USER_INFORMATION_VALIDATED : exports.GatewayStatus.NOT_REQUESTED;
            }
            return gatewayStatusFromValidationProcess;
        }
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.ISSUANCE &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS) {
            return exports.GatewayStatus.USER_INFORMATION_VALIDATED;
        }
        if (hasExistingDataCollectionProcessInProgress(civicPassEvent)) {
            return gatewayStatusFromValidationProcess || exports.GatewayStatus.COLLECTING_USER_INFORMATION;
        }
    };
    var computeIssuanceDataCollectionRestart = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            calculateIssuanceRequestedDataCollectionRestart(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeIssuanceRequested = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            calculateFromGatekeeperIssuanceRequested(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeIssuanceAwaitingOnChainToken = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            calculateFromIssuanceAwaitingOnChain(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeIssuanceInReview = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            statusIfGatekeeperRecordRejected(state) ||
            calculateFromIssuanceInReview(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var calculateIssuanceStatus = function (state) {
        var _a, _b, _c, _d, _e, _f;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        var gatekeeperRecord = state.inputs.gatekeeperRecord;
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.FAILURE) {
            return exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED;
        }
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.ISSUANCE &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS) {
            return exports.GatewayStatus.USER_INFORMATION_VALIDATED;
        }
        if (!(gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) || ((_b = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _b === void 0 ? void 0 : _b.state) === GatekeeperAPIStatus.NOT_REQUESTED) {
            if (hasExistingDataCollectionProcessInProgress(civicPassEvent)) {
                var gatewayStatusFromValidationProcess = validationProcessToGatewayStatus[(_c = civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.payload) === null || _c === void 0 ? void 0 : _c.status];
                if (gatewayStatusFromValidationProcess === exports.GatewayStatus.USER_INFORMATION_VALIDATED) {
                    return exports.GatewayStatus.NOT_REQUESTED;
                }
                return gatewayStatusFromValidationProcess || exports.GatewayStatus.COLLECTING_USER_INFORMATION;
            }
            return exports.GatewayStatus.NOT_REQUESTED;
        }
        if (((_d = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _d === void 0 ? void 0 : _d.state) === GatekeeperAPIStatus.REQUESTED) {
            if (preApprovedTxAvailable(gatekeeperRecord)) {
                if (payerIsWalletOwner(state)) {
                    return exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX;
                }
                return exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
            }
            if (isInPartnerReview(gatekeeperRecord)) {
                return exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW;
            }
            if ((_e = state.inputs.parameters) === null || _e === void 0 ? void 0 : _e.payer) {
                if ((gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.status) === InputStatus.COMPLETE &&
                    (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) !== CivicPassMessageAction.ISSUANCE &&
                    !((_f = gatekeeperRecord.received) === null || _f === void 0 ? void 0 : _f.transaction)) {
                    return exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION;
                }
            }
            else {
                return exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
            }
        }
    };
    var computeIssuanceStatus = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            calculateIssuanceStatus(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeIssuanceStartPreApprovedTransaction = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            calculateIssuanceStartPreApprovedTransaction(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };

    var civicPassStatusLookupInProgress = function (state) {
        var _a, _b, _c;
        return ((_a = state.inputs.civicPass.received) === null || _a === void 0 ? void 0 : _a.action) === CivicPassMessageAction.STATUS &&
            (!state.inputs.gatewayToken.status ||
                state.inputs.gatewayToken.status === InputStatus.IN_PROGRESS ||
                (!((_b = state.inputs.parameters) === null || _b === void 0 ? void 0 : _b.disableInitialGatekeeperLookup) &&
                    (!state.inputs.gatekeeperRecord.status || ((_c = state.inputs.gatekeeperRecord) === null || _c === void 0 ? void 0 : _c.status) === InputStatus.IN_PROGRESS)));
    };
    var computeChecking = function (state) {
        if (!state.inputs.civicPass.status || civicPassStatusLookupInProgress(state)) {
            if (state.inputs.gatekeeperRecord.status === InputStatus.ERROR ||
                state.inputs.gatewayToken.status === InputStatus.ERROR) {
                return exports.GatewayStatus.ERROR;
            }
            if (state.inputs.gatekeeperRecord.status === InputStatus.IN_PROGRESS ||
                state.inputs.gatewayToken.status === InputStatus.IN_PROGRESS) {
                return exports.GatewayStatus.CHECKING;
            }
        }
        return undefined;
    };
    var checkForInProgress = function (state) {
        var _a;
        return statusFromGatewayTokenIfExists(state) ||
            computeChecking(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeInitialState = function (state) {
        var _a;
        return computeChecking(state) ||
            statusIfGatekeeperRecordRejected(state) ||
            statusFromGatewayTokenIfExists(state) ||
            computeIssuanceStatus(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };

    var calculateRefreshStartPreApprovedTransaction = function (state) {
        var _a;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.payload) !== undefined) {
            return payerIsWalletOwner(state)
                ? exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
                : exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
        }
    };
    var calculateFromRefreshInReview = function (state) {
        var _a, _b, _c, _d, _e, _f;
        var gatekeeperRecord = state.inputs.gatekeeperRecord;
        if ((_a = state.inputs.parameters) === null || _a === void 0 ? void 0 : _a.payer) {
            if ((_c = (_b = state.internal) === null || _b === void 0 ? void 0 : _b.chainTransaction) === null || _c === void 0 ? void 0 : _c.sentTxId) {
                return exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN;
            }
            if ((_e = (_d = state.internal) === null || _d === void 0 ? void 0 : _d.chainTransaction) === null || _e === void 0 ? void 0 : _e.error) {
                return exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR;
            }
            if ((_f = gatekeeperRecord.received) === null || _f === void 0 ? void 0 : _f.transaction) {
                if (payerIsWalletOwner(state)) {
                    return exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND;
                }
                return exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
            }
        }
        else {
            return exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN;
        }
    };
    var calculateFromGatekeeperRefreshRequested = function (state) {
        var _a, _b;
        var gatekeeperRecord = state.inputs.gatekeeperRecord;
        if (((_a = gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.received) === null || _a === void 0 ? void 0 : _a.state) === GatekeeperAPIStatus.REQUESTED ||
            (gatekeeperRecord === null || gatekeeperRecord === void 0 ? void 0 : gatekeeperRecord.status) === InputStatus.IN_PROGRESS) {
            return ((_b = state.inputs.parameters) === null || _b === void 0 ? void 0 : _b.payer) && payerIsWalletOwner(state)
                ? exports.ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED
                : exports.ExtendedGatewayStatus.REFRESH_IN_REVIEW;
        }
    };
    var tokenNotRefreshRequired = function (state) {
        var tokenStatus = statusFromGatewayTokenIfExists(state);
        return tokenStatus &&
            ![exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN, exports.GatewayStatus.REFRESH_TOKEN_REQUIRED].includes(tokenStatus)
            ? tokenStatus
            : undefined;
    };
    var computeRefreshRequested = function (state) {
        var _a;
        return tokenNotRefreshRequired(state) ||
            calculateFromGatekeeperRefreshRequested(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeRefreshInReview = function (state) {
        var _a;
        return tokenNotRefreshRequired(state) ||
            statusIfGatekeeperRecordRejected(state) ||
            calculateFromRefreshInReview(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var calculateRefreshStatus = function (state) {
        var _a;
        var civicPassEvent = (_a = state.inputs.civicPass) === null || _a === void 0 ? void 0 : _a.received;
        if (preApprovedTxAvailable(state.inputs.gatekeeperRecord)) {
            if (payerIsWalletOwner(state)) {
                return exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX;
            }
            return exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
        }
        if ((civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.action) === CivicPassMessageAction.REFRESH &&
            (civicPassEvent === null || civicPassEvent === void 0 ? void 0 : civicPassEvent.event) === CivicPassMessageEventResult.SUCCESS) {
            return exports.ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED;
        }
    };
    var computeRefreshStatus = function (state) {
        var _a;
        return tokenNotRefreshRequired(state) ||
            statusIfGatekeeperRecordRejected(state) ||
            calculateRefreshStatus(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var calculateFromRefreshAwaitingOnChain = function (state) {
        var _a, _b;
        if (((_b = (_a = state.internal.errors) === null || _a === void 0 ? void 0 : _a.expectedOnChainToken) === null || _b === void 0 ? void 0 : _b.errorCode) ===
            ErrorCode.CHAIN_CONFIRMATION_TIMEOUT_ERROR) {
            return exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR;
        }
    };
    var computeRefreshAwaitingOnChainToken = function (state) {
        var _a;
        return tokenNotRefreshRequired(state) ||
            statusIfGatekeeperRecordRejected(state) ||
            calculateFromRefreshAwaitingOnChain(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };
    var computeRefreshStartPreApprovedTransaction = function (state) {
        var _a;
        return tokenNotRefreshRequired(state) ||
            calculateRefreshStartPreApprovedTransaction(state) ||
            ((_a = state.internal) === null || _a === void 0 ? void 0 : _a.status);
    };

    var _a;
    var logDebug = prefixLogger('gatewayStatus').debug;
    var logError = prefixLogger('gatewayStatus').error;
    var gatewayTokenStatuses = [
        exports.GatewayStatus.ACTIVE,
        exports.GatewayStatus.FROZEN,
        exports.GatewayStatus.REVOKED,
        exports.GatewayStatus.REFRESH_TOKEN_REQUIRED,
    ];
    var validationProcessStatuses = [
        exports.GatewayStatus.COLLECTING_USER_INFORMATION,
        exports.GatewayStatus.VALIDATING_USER_INFORMATION,
        exports.GatewayStatus.USER_INFORMATION_REJECTED,
        exports.GatewayStatus.USER_INFORMATION_VALIDATED,
    ];
    var errorStatuses = [
        exports.GatewayStatus.REJECTED,
        exports.GatewayStatus.ERROR,
        exports.GatewayStatus.LOCATION_NOT_SUPPORTED,
        exports.GatewayStatus.VPN_NOT_SUPPORTED,
    ];
    function createTransition(nextState, compute) {
        return { nextState: nextState, compute: compute };
    }
    var transitions = (_a = {},
        _a[exports.GatewayStatus.UNKNOWN] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [exports.GatewayStatus.CHECKING], false), checkForInProgress),
        _a[exports.GatewayStatus.CHECKING] = createTransition(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), validationProcessStatuses, true), [
            exports.GatewayStatus.NOT_REQUESTED,
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
        ], false), computeInitialState),
        _a[exports.GatewayStatus.NOT_REQUESTED] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), validationProcessStatuses, true), [
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.GatewayStatus.NOT_REQUESTED,
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
        ], false), computeIssuanceStatus),
        _a[exports.GatewayStatus.COLLECTING_USER_INFORMATION] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), validationProcessStatuses, true), [
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.GatewayStatus.NOT_REQUESTED,
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED,
        ], false), computeIssuanceStatus),
        _a[exports.GatewayStatus.USER_INFORMATION_VALIDATED] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED, exports.GatewayStatus.IN_REVIEW], false), computeIssuanceRequested),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
        ], false), computeIssuanceInReview),
        _a[exports.GatewayStatus.IN_REVIEW] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
        ], false), computeIssuanceInReview),
        _a[exports.GatewayStatus.REJECTED] = createTransition([], function () { return exports.GatewayStatus.REJECTED; }),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION,
            exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ], false), computeIssuanceInReview),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION,
            exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ], false), computeIssuanceInReview),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR], false), computeIssuanceAwaitingOnChainToken),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), validationProcessStatuses, true), [
            exports.GatewayStatus.USER_INFORMATION_VALIDATED,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED,
            exports.GatewayStatus.NOT_REQUESTED,
        ], false), computeIssuanceDataCollectionRestart),
        _a[exports.GatewayStatus.REVOKED] = createTransition([], handleGatewayTokenExistsStatus),
        _a[exports.GatewayStatus.FROZEN] = createTransition(__spreadArray([], gatewayTokenStatuses, true), handleGatewayTokenExistsStatus),
        _a[exports.GatewayStatus.ACTIVE] = createTransition(__spreadArray([], gatewayTokenStatuses, true), handleGatewayTokenExistsStatus),
        _a[exports.GatewayStatus.ERROR] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [exports.ExtendedGatewayStatus.RESTART, exports.ExtendedGatewayStatus.RESTART_REFRESH], false), handleGatekeeperError),
        _a[exports.GatewayStatus.LOCATION_NOT_SUPPORTED] = createTransition([], function () { return exports.GatewayStatus.LOCATION_NOT_SUPPORTED; }),
        _a[exports.GatewayStatus.VPN_NOT_SUPPORTED] = createTransition([], function () { return exports.GatewayStatus.VPN_NOT_SUPPORTED; }),
        _a[exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED] = createTransition([exports.ExtendedGatewayStatus.USER_VALIDATION_FAILED, exports.ExtendedGatewayStatus.RESTART], handleUserValidationFailed),
        _a[exports.GatewayStatus.REFRESH_TOKEN_REQUIRED] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX,
        ], false), computeRefreshStatus),
        _a[exports.ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED,
            exports.ExtendedGatewayStatus.REFRESH_IN_REVIEW,
        ], false), computeRefreshRequested),
        _a[exports.ExtendedGatewayStatus.REFRESH_IN_REVIEW] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
        ], false), computeRefreshInReview),
        _a[exports.ExtendedGatewayStatus.TOKEN_REFRESH_IN_REVIEW] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
        ], false), computeRefreshInReview),
        _a[exports.ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
        ], false), computeRefreshInReview),
        _a[exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION,
            exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ], false), computeRefreshInReview),
        _a[exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION,
            exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ], false), computeRefreshInReview),
        _a[exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR], false), computeRefreshAwaitingOnChainToken),
        _a[exports.ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.GatewayStatus.USER_INFORMATION_VALIDATED,
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.RESTART_REFRESH,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
        ], false), handleChainError),
        _a[exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.RESTART_REFRESH,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
        ], false), handleChainError),
        _a[exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN], false), computeIssuanceInReview),
        _a[exports.ExtendedGatewayStatus.RESTART] = createTransition([exports.ExtendedGatewayStatus.RESTART], function () { return exports.ExtendedGatewayStatus.RESTART; }),
        _a[exports.ExtendedGatewayStatus.RESTART_REFRESH] = createTransition([exports.ExtendedGatewayStatus.RESTART_REFRESH], function () { return exports.ExtendedGatewayStatus.RESTART_REFRESH; }),
        _a[exports.ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR] = createTransition([
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.RESTART_REFRESH,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
        ], handleChainError),
        _a[exports.GatewayStatus.VALIDATING_USER_INFORMATION] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), validationProcessStatuses, true), [
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.GatewayStatus.NOT_REQUESTED,
        ], false), computeIssuanceStatus),
        _a[exports.GatewayStatus.USER_INFORMATION_REJECTED] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), validationProcessStatuses, true), [
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.RESTART,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.GatewayStatus.NOT_REQUESTED,
        ], false), computeIssuanceStatus),
        _a[exports.ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION] = createTransition([], function () { return exports.ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION; }),
        _a[exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION] = createTransition([], function () { return exports.ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION; }),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_START_NEW_TX] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
        ], false), computeIssuanceStartPreApprovedTransaction),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ], false), computeIssuanceInReview),
        _a[exports.ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
            exports.ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
            exports.ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ], false), computeIssuanceInReview),
        _a[exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_START_NEW_TX] = createTransition(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX,
            exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX,
        ], false), computeRefreshStartPreApprovedTransaction),
        _a[exports.ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
        ], false), computeRefreshInReview),
        _a[exports.ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX] = createTransition(__spreadArray(__spreadArray(__spreadArray([], gatewayTokenStatuses, true), errorStatuses, true), [
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
            exports.ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
        ], false), computeRefreshInReview),
        _a);
    var isValidTransition = function (current, next) {
        var _a;
        return (_a = transitions[current]) === null || _a === void 0 ? void 0 : _a.nextState.includes(next);
    };
    var performTransition = function (state) {
        var _a, _b;
        var currentStatus = (_a = state.internal) === null || _a === void 0 ? void 0 : _a.status;
        var computeFn = (_b = transitions[currentStatus]) === null || _b === void 0 ? void 0 : _b.compute;
        if (!computeFn) {
            throw new Error("No transition function defined for ".concat(currentStatus, " status"));
        }
        var computedStatus = computeFn(state);
        if (computedStatus === currentStatus) {
            return currentStatus;
        }
        if (!isValidTransition(currentStatus, computedStatus)) {
            logError('Invalid transition, throwing an error...', { currentStatus: currentStatus, computedStatus: computedStatus });
            throw new Error("Invalid transition, returning currentStatus currentStatus: ".concat(currentStatus, " computedStatus: ").concat(computedStatus));
        }
        logDebug('Transitioning to new status', { currentStatus: currentStatus, computedStatus: computedStatus });
        return computedStatus;
    };
    var computeInternalStatus = function (state) {
        return performTransition(state);
    };

    var isEmptyObject = function (obj) {
        return obj === null || obj === undefined || Object.keys(obj).length === 0;
    };

    var VERSION = '@civic/gateway-client-core:1.1.1-beta.1';

    var computeFlowParameters = function (state, computedInternalStatus) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
        if (!(((_a = state.inputs.parameters) === null || _a === void 0 ? void 0 : _a.wallet) && ((_b = state.internal.chainDetails) === null || _b === void 0 ? void 0 : _b.chainType) && ((_c = state.internal) === null || _c === void 0 ? void 0 : _c.instanceId)) ||
            [exports.GatewayStatus.UNKNOWN, exports.GatewayStatus.CHECKING].includes(computedInternalStatus)) {
            return null;
        }
        var errorCode = ((_e = (_d = state.internal.errors) === null || _d === void 0 ? void 0 : _d.expectedTokenGatekeeperRecord) === null || _e === void 0 ? void 0 : _e.errorCode) ||
            ((_g = (_f = state.internal.chainTransaction) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.errorCode) ||
            ((_j = (_h = state.inputs.gatekeeperRecord) === null || _h === void 0 ? void 0 : _h.received) === null || _j === void 0 ? void 0 : _j.errorCode) ||
            ((_m = (_l = (_k = state.inputs.gatekeeperRecord) === null || _k === void 0 ? void 0 : _k.received) === null || _l === void 0 ? void 0 : _l.payload) === null || _m === void 0 ? void 0 : _m.errorCode) ||
            ((_p = (_o = state.inputs.civicSign) === null || _o === void 0 ? void 0 : _o.error) === null || _p === void 0 ? void 0 : _p.errorCode);
        var action = gatewayStatusToCivicPassAction[computedInternalStatus];
        var flowId = getFlowId(state, computedInternalStatus);
        var payload = isEmptyObject((_r = (_q = state.inputs.gatekeeperRecord) === null || _q === void 0 ? void 0 : _q.received) === null || _r === void 0 ? void 0 : _r.payload)
            ? undefined
            : JSON.stringify((_t = (_s = state.inputs.gatekeeperRecord) === null || _s === void 0 ? void 0 : _s.received) === null || _t === void 0 ? void 0 : _t.payload);
        var ownerSigns = !state.inputs.parameters.gatekeeperSendsTransaction && payerIsWalletOwner(state);
        return __assign(__assign({ action: action, flowId: flowId, ownerSigns: ownerSigns, errorCode: errorCode, flowType: flowTypeFromState(state, computedInternalStatus) }, (payload ? { payload: payload } : {})), { redirectUrl: (_u = state.inputs.parameters) === null || _u === void 0 ? void 0 : _u.redirectUrl, networkAddress: (_v = state.inputs.parameters) === null || _v === void 0 ? void 0 : _v.gatekeeperNetwork, wallet: state.inputs.parameters.wallet.address, chain: (_w = state.internal.chainDetails) === null || _w === void 0 ? void 0 : _w.chainType, chainNetwork: (_x = state.internal.chainDetails) === null || _x === void 0 ? void 0 : _x.chainNetwork, did: (_y = state.internal.ownerDids) === null || _y === void 0 ? void 0 : _y[0], gatekeeperSendsTransaction: state.inputs.parameters.gatekeeperSendsTransaction, partnerAppId: state.inputs.parameters.partnerAppId, referrer: state.inputs.parameters.referrer, domain: state.inputs.parameters.domain, instanceId: state.internal.instanceId, hideWalletPrompts: state.inputs.parameters.payer && state.inputs.parameters.payer !== state.inputs.parameters.wallet.address
                ? (_z = state.inputs.parameters.options) === null || _z === void 0 ? void 0 : _z.hideWalletPrompts
                : undefined, signedTx: (_1 = (_0 = state.internal) === null || _0 === void 0 ? void 0 : _0.chainTransaction) === null || _1 === void 0 ? void 0 : _1.sentTxId, civicClient: ((_3 = (_2 = state.inputs) === null || _2 === void 0 ? void 0 : _2.parameters) === null || _3 === void 0 ? void 0 : _3.xCivicClientHeader) || VERSION, stage: (_5 = (_4 = state.inputs) === null || _4 === void 0 ? void 0 : _4.parameters) === null || _5 === void 0 ? void 0 : _5.stage });
    };

    var IFRAME_ENDPOINTS = {
        local: 'http://localhost:3004',
        test: 'http://localhost:3004',
        dev: 'https://passv2-dev.civic.com',
        preprod: 'https://passv2-preprod.civic.com',
        prod: 'https://passv2.civic.com',
    };
    var getCivicPassEndpoint = function (stage) {
        var endpoint = IFRAME_ENDPOINTS[stage];
        if (!endpoint) {
            throw new Error("Invalid stage ".concat(stage));
        }
        return endpoint;
    };

    var getUrl = function (state, flowParameters) {
        var _a, _b;
        if (!flowParameters) {
            return undefined;
        }
        if (!((_b = (_a = state.inputs) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.stage)) {
            return undefined;
        }
        var url = new URL(getCivicPassEndpoint(state.inputs.parameters.stage));
        var urlParams = objectToURLParams(flowParameters || {});
        var getParams = new URLSearchParams(urlParams);
        return "".concat(url.href, "?").concat(getParams.toString());
    };
    var computeUiState = function (state, flowStatus, flowParameters) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var options = (_a = state.inputs.parameters) === null || _a === void 0 ? void 0 : _a.options;
        var calculatedIsVisible = !!((_c = (_b = state.output) === null || _b === void 0 ? void 0 : _b.ui) === null || _c === void 0 ? void 0 : _c.isVisible);
        if (flowStatus === exports.FlowStatus.FINISHED ||
            ((_e = (_d = state.internal) === null || _d === void 0 ? void 0 : _d.userInteraction) === null || _e === void 0 ? void 0 : _e.status) === UserInteractionStatus.FINISHED) {
            calculatedIsVisible = false;
        }
        else if (((_g = (_f = state.internal) === null || _f === void 0 ? void 0 : _f.userInteraction) === null || _g === void 0 ? void 0 : _g.status) === UserInteractionStatus.STARTED ||
            flowStatus === exports.FlowStatus.IN_PROGRESS) {
            calculatedIsVisible = true;
        }
        if (flowStatus === exports.FlowStatus.RESULT && (options === null || options === void 0 ? void 0 : options.autoShowModal)) {
            calculatedIsVisible = true;
        }
        var url = getUrl(state, flowParameters);
        var isLoading = ((_j = (_h = state.output) === null || _h === void 0 ? void 0 : _h.ui) === null || _j === void 0 ? void 0 : _j.url) !== url;
        return __assign(__assign({}, (_k = state.output) === null || _k === void 0 ? void 0 : _k.ui), { isLoading: isLoading, url: url, isVisible: !!calculatedIsVisible });
    };

    var initialInternalState = {
        status: exports.GatewayStatus.UNKNOWN,
        userInteraction: {
            status: null,
        },
        errors: {},
        ownerDids: [],
        chainDetails: undefined,
    };
    var initialOutputState = {
        flowParameters: undefined,
        flowState: {
            status: undefined,
            userInteraction: {
                status: null,
                count: 0,
            },
        },
        gatewayStatus: exports.GatewayStatus.UNKNOWN,
        gatewayToken: undefined,
        gatewayTokenTransaction: undefined,
        pendingRequests: undefined,
        ui: undefined,
    };
    var initialInputState = {
        civicSign: { status: null, received: null },
        civicPass: { status: null, received: null },
        gatewayToken: { status: null, received: null },
        gatekeeperRecord: { status: null, received: null },
        parameters: null,
        dynamicParameters: { forceRequireRefresh: false },
        gatekeeperNetworkData: { status: null, received: null },
    };
    var initialState = {
        inputs: initialInputState,
        internal: initialInternalState,
        output: initialOutputState,
    };
    var computeState = function (state) {
        var _a, _b, _c, _d, _e, _f;
        var computedInternalStatus = computeInternalStatus(state);
        var flowParameters = computeFlowParameters(state, computedInternalStatus) || undefined;
        var flowStatus = flowStatusFromState(state, computedInternalStatus);
        var ui = __assign(__assign({}, (_a = state.output) === null || _a === void 0 ? void 0 : _a.ui), computeUiState(state, flowStatus, flowParameters));
        var computedUserInteractionStatus = [exports.FlowStatus.RESULT, exports.FlowStatus.FINISHED].includes(flowStatus) &&
            ((_d = (_c = (_b = state.inputs.gatekeeperNetworkData) === null || _b === void 0 ? void 0 : _b.received) === null || _c === void 0 ? void 0 : _c.client) === null || _d === void 0 ? void 0 : _d.tokenActiveDisplay) === 'hidden'
            ? null
            : state.internal.userInteraction.status;
        return {
            internal: __assign(__assign({}, state.internal), { status: computedInternalStatus, userInteraction: __assign(__assign({}, state.internal.userInteraction), { status: computedUserInteractionStatus }) }),
            output: __assign(__assign({}, state.output), { ui: ui, flowParameters: flowParameters, flowState: {
                    status: flowStatus,
                    userInteraction: __assign(__assign({}, state.internal.userInteraction), { status: computedUserInteractionStatus }),
                }, gatewayStatus: internalToOutputGatewayStatus(computedInternalStatus), gatewayToken: state.inputs.gatewayToken.received || undefined, gatewayTokenTransaction: (_f = (_e = state.inputs.gatekeeperRecord) === null || _e === void 0 ? void 0 : _e.received) === null || _f === void 0 ? void 0 : _f.transaction, pendingRequests: getPendingRequestFromGatekeeperRecord(state.inputs.gatekeeperRecord) }),
        };
    };
    var combinedMiddleware = function (options) { return function (config) {
        return subscribeWithSelector(computed(immer(devtools(config, options))));
    }; };
    var createGatewayCoreStore = function (options) {
        return createStore(combinedMiddleware(options)(function (set, get) { return (__assign(__assign(__assign({}, initialState), { functions: {
                reset: function () {
                    return set(produce(function (state) {
                        var _a;
                        state.inputs = __assign(__assign({}, initialInputState), { dynamicParameters: state.inputs.dynamicParameters, parameters: state.inputs.parameters });
                        state.internal = __assign(__assign({}, initialInternalState), { userInteraction: {
                                status: state.internal.userInteraction.status,
                            }, instanceId: state.internal.instanceId, ownerDids: [], chainDetails: state.internal.chainDetails });
                        state.output = __assign(__assign({}, initialOutputState), { ui: (_a = state.output) === null || _a === void 0 ? void 0 : _a.ui });
                    }));
                },
            } }), compute(get, computeState))); }));
    };

    var defaultValues = { isVisible: false, isLoading: false, url: undefined, isLoaded: false };
    var UIManager = (function () {
        function UIManager(gatewayCoreStore) {
            this.gatewayCoreStore = gatewayCoreStore;
            this.log = prefixLogger("UIManager");
        }
        UIManager.prototype.onShow = function () {
            this.log.debug('onShow');
            this.gatewayCoreStore.setState(function (state) {
                var _a;
                state.output = state.output || { gatewayStatus: exports.GatewayStatus.UNKNOWN };
                state.output.ui = ((_a = state.output) === null || _a === void 0 ? void 0 : _a.ui) || __assign({}, defaultValues);
                state.output.ui.isVisible = true;
                state.internal.userInteraction.status = UserInteractionStatus.STARTED;
            });
        };
        UIManager.prototype.onHide = function () {
            this.log.debug('onHide');
            this.gatewayCoreStore.setState(function (state) {
                var _a;
                state.output = state.output || { gatewayStatus: exports.GatewayStatus.UNKNOWN };
                state.output.ui = ((_a = state.output) === null || _a === void 0 ? void 0 : _a.ui) || __assign({}, defaultValues);
                state.output.ui.isVisible = false;
                state.internal.userInteraction.status = UserInteractionStatus.FINISHED;
            });
        };
        UIManager.prototype.onLoad = function () {
            this.log.debug('onLoad');
            this.gatewayCoreStore.setState(function (state) {
                var _a;
                state.output = state.output || { gatewayStatus: exports.GatewayStatus.UNKNOWN };
                state.output.ui = ((_a = state.output) === null || _a === void 0 ? void 0 : _a.ui) || __assign({}, defaultValues);
                state.output.ui.isLoading = false;
                state.output.ui.isLoaded = true;
            });
        };
        return UIManager;
    }());

    var _placeholder = {
      '@@functional/placeholder': true
    };

    function _isPlaceholder(a) {
      return a === _placeholder;
    }

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    function _curry1(fn) {
      return function f1(a) {
        if (arguments.length === 0 || _isPlaceholder(a)) {
          return f1;
        } else {
          return fn.apply(this, arguments);
        }
      };
    }

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    function _curry2(fn) {
      return function f2(a, b) {
        switch (arguments.length) {
          case 0:
            return f2;
          case 1:
            return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
              return fn(a, _b);
            });
          default:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
              return fn(_a, b);
            }) : _isPlaceholder(b) ? _curry1(function (_b) {
              return fn(a, _b);
            }) : fn(a, b);
        }
      };
    }

    function _arrayFromIterator(iter) {
      var list = [];
      var next;
      while (!(next = iter.next()).done) {
        list.push(next.value);
      }
      return list;
    }

    function _includesWith(pred, x, list) {
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        if (pred(x, list[idx])) {
          return true;
        }
        idx += 1;
      }
      return false;
    }

    function _functionName(f) {
      // String(x => x) evaluates to "x => x", so the pattern may not match.
      var match = String(f).match(/^function (\w*)/);
      return match == null ? '' : match[1];
    }

    function _has(prop, obj) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    function _objectIs(a, b) {
      // SameValue algorithm
      if (a === b) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return a !== 0 || 1 / a === 1 / b;
      } else {
        // Step 6.a: NaN == NaN
        return a !== a && b !== b;
      }
    }
    var _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

    var toString = Object.prototype.toString;
    var _isArguments = /*#__PURE__*/function () {
      return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
        return toString.call(x) === '[object Arguments]';
      } : function _isArguments(x) {
        return _has('callee', x);
      };
    }();

    // cover IE < 9 keys issues
    var hasEnumBug = ! /*#__PURE__*/{
      toString: null
    }.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    // Safari bug
    var hasArgsEnumBug = /*#__PURE__*/function () {

      return arguments.propertyIsEnumerable('length');
    }();
    var contains = function contains(list, item) {
      var idx = 0;
      while (idx < list.length) {
        if (list[idx] === item) {
          return true;
        }
        idx += 1;
      }
      return false;
    };

    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @see R.keysIn, R.values, R.toPairs
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? /*#__PURE__*/_curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) : /*#__PURE__*/_curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig * -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     *      R.type(() => {}); //=> "Function"
     *      R.type(async () => {}); //=> "AsyncFunction"
     *      R.type(undefined); //=> "Undefined"
     *      R.type(BigInt(123)); //=> "BigInt"
     */
    var type = /*#__PURE__*/_curry1(function type(val) {
      return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * private _uniqContentEquals function.
     * That function is checking equality of 2 iterator contents with 2 assumptions
     * - iterators lengths are the same
     * - iterators values are unique
     *
     * false-positive result will be returned for comparison of, e.g.
     * - [1,2,3] and [1,2,3,4]
     * - [1,1,1] and [1,2,3]
     * */

    function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
      var a = _arrayFromIterator(aIterator);
      var b = _arrayFromIterator(bIterator);
      function eq(_a, _b) {
        return _equals(_a, _b, stackA.slice(), stackB.slice());
      }

      // if *a* array contains any element that is not included in *b*
      return !_includesWith(function (b, aItem) {
        return !_includesWith(eq, aItem, b);
      }, b, a);
    }
    function _equals(a, b, stackA, stackB) {
      if (_objectIs$1(a, b)) {
        return true;
      }
      var typeA = type(a);
      if (typeA !== type(b)) {
        return false;
      }
      if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
        return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
      }
      if (typeof a.equals === 'function' || typeof b.equals === 'function') {
        return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
      }
      switch (typeA) {
        case 'Arguments':
        case 'Array':
        case 'Object':
          if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
            return a === b;
          }
          break;
        case 'Boolean':
        case 'Number':
        case 'String':
          if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
            return false;
          }
          break;
        case 'Date':
          if (!_objectIs$1(a.valueOf(), b.valueOf())) {
            return false;
          }
          break;
        case 'Error':
          return a.name === b.name && a.message === b.message;
        case 'RegExp':
          if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
            return false;
          }
          break;
      }
      var idx = stackA.length - 1;
      while (idx >= 0) {
        if (stackA[idx] === a) {
          return stackB[idx] === b;
        }
        idx -= 1;
      }
      switch (typeA) {
        case 'Map':
          if (a.size !== b.size) {
            return false;
          }
          return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
        case 'Set':
          if (a.size !== b.size) {
            return false;
          }
          return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
        case 'Arguments':
        case 'Array':
        case 'Object':
        case 'Boolean':
        case 'Number':
        case 'String':
        case 'Date':
        case 'Error':
        case 'RegExp':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'ArrayBuffer':
          break;
        default:
          // Values of other types are only equal if identical.
          return false;
      }
      var keysA = keys(a);
      if (keysA.length !== keys(b).length) {
        return false;
      }
      var extendedStackA = stackA.concat([a]);
      var extendedStackB = stackB.concat([b]);
      idx = keysA.length - 1;
      while (idx >= 0) {
        var key = keysA[idx];
        if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
          return false;
        }
        idx -= 1;
      }
      return true;
    }

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      const a = {}; a.v = a;
     *      const b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = /*#__PURE__*/_curry2(function equals(a, b) {
      return _equals(a, b, [], []);
    });
    var equals$1 = equals;

    function _cloneRegExp(pattern) {
      return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : '') + (pattern.dotAll ? 's' : ''));
    }

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Boolean} deep Whether or not to perform deep cloning.
     * @return {*} The copied value.
     */
    function _clone(value, deep, map) {
      map || (map = new _ObjectMap());

      // this avoids the slower switch with a quick if decision removing some milliseconds in each run.
      if (_isPrimitive(value)) {
        return value;
      }
      var copy = function copy(copiedValue) {
        // Check for circular and same references on the object graph and return its corresponding clone.
        var cachedCopy = map.get(value);
        if (cachedCopy) {
          return cachedCopy;
        }
        map.set(value, copiedValue);
        for (var key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            copiedValue[key] = deep ? _clone(value[key], true, map) : value[key];
          }
        }
        return copiedValue;
      };
      switch (type(value)) {
        case 'Object':
          return copy(Object.create(Object.getPrototypeOf(value)));
        case 'Array':
          return copy(Array(value.length));
        case 'Date':
          return new Date(value.valueOf());
        case 'RegExp':
          return _cloneRegExp(value);
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'BigInt64Array':
        case 'BigUint64Array':
          return value.slice();
        default:
          return value;
      }
    }
    function _isPrimitive(param) {
      var type = typeof param;
      return param == null || type != 'object' && type != 'function';
    }
    var _ObjectMap = /*#__PURE__*/function () {
      function _ObjectMap() {
        this.map = {};
        this.length = 0;
      }
      _ObjectMap.prototype.set = function (key, value) {
        var hashedKey = this.hash(key);
        var bucket = this.map[hashedKey];
        if (!bucket) {
          this.map[hashedKey] = bucket = [];
        }
        bucket.push([key, value]);
        this.length += 1;
      };
      _ObjectMap.prototype.hash = function (key) {
        var hashedKey = [];
        for (var value in key) {
          hashedKey.push(Object.prototype.toString.call(key[value]));
        }
        return hashedKey.join();
      };
      _ObjectMap.prototype.get = function (key) {
        /**
         * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,
         * on my tests this number is 180, anything above that using the hash function is faster.
         */
        if (this.length <= 180) {
          for (var p in this.map) {
            var bucket = this.map[p];
            for (var i = 0; i < bucket.length; i += 1) {
              var element = bucket[i];
              if (element[0] === key) {
                return element[1];
              }
            }
          }
          return;
        }
        var hashedKey = this.hash(key);
        var bucket = this.map[hashedKey];
        if (!bucket) {
          return;
        }
        for (var i = 0; i < bucket.length; i += 1) {
          var element = bucket[i];
          if (element[0] === key) {
            return element[1];
          }
        }
      };
      return _ObjectMap;
    }();

    /**
     * Creates a deep copy of the source that can be used in place of the source
     * object without retaining any references to it.
     * The source object may contain (nested) `Array`s and `Object`s,
     * `Number`s, `String`s, `Boolean`s and `Date`s.
     * `Function`s are assigned by reference rather than copied.
     *
     * Dispatches to a `clone` method if present.
     *
     * Note that if the source object has multiple nodes that share a reference,
     * the returned object will have the same structure, but the references will
     * be pointed to the location within the cloned value.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A deeply cloned copy of `val`
     * @example
     *
     *      const objects = [{}, {}, {}];
     *      const objectsClone = R.clone(objects);
     *      objects === objectsClone; //=> false
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = /*#__PURE__*/_curry1(function clone(value) {
      return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, true);
    });

    var getInstanceInputObject = function (input) {
        var _a;
        return input
            ? __assign(__assign({}, input.parameters), (_a = input.chainImplementation) === null || _a === void 0 ? void 0 : _a.chainDetails) : {};
    };
    var shouldUpdateInstance = function (inputs, instance) {
        return !instance || !equals$1(getInstanceInputObject(instance.inputs), getInstanceInputObject(inputs));
    };
    var hasRequiredInputs = function (inputs) { var _a; return !!(((_a = inputs.parameters.wallet) === null || _a === void 0 ? void 0 : _a.address) && inputs.chainImplementation); };
    var getInstanceName = function (inputs, instanceId) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return "gcc_".concat((_b = (_a = inputs.parameters.wallet) === null || _a === void 0 ? void 0 : _a.address) === null || _b === void 0 ? void 0 : _b.substring(0, 4), "_").concat((_d = (_c = inputs.parameters) === null || _c === void 0 ? void 0 : _c.gatekeeperNetwork) === null || _d === void 0 ? void 0 : _d.substring(0, 4), "_").concat((_f = (_e = inputs.chainImplementation) === null || _e === void 0 ? void 0 : _e.chainDetails) === null || _f === void 0 ? void 0 : _f.chainType, "_").concat((_h = (_g = inputs.chainImplementation) === null || _g === void 0 ? void 0 : _g.chainDetails) === null || _h === void 0 ? void 0 : _h.chainNetwork, "_").concat(instanceId.substring(0, 4));
    };
    var GatewayClientCore = (function () {
        function GatewayClientCore(inputs) {
            var _this = this;
            var _a, _b, _c, _d;
            this.inputs = inputs;
            this.instanceId = v4();
            this.log = prefixLogger("Core instance: ".concat(this.instanceId));
            (_b = (_a = this.log) === null || _a === void 0 ? void 0 : _a.setLogLevel) === null || _b === void 0 ? void 0 : _b.call(_a, ((_d = (_c = inputs.parameters) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.logLevel) || DEFAULT_LOG_LEVEL);
            this.log.info('GatewayClientCore created', { inputs: inputs });
            this.gatewayCoreStore = createGatewayCoreStore({
                name: getInstanceName(inputs, this.instanceId),
                store: 'gateway-client-core',
            });
            this.log.info('GatewayClientCore gatewayCoreStore created', this.gatewayCoreStore);
            this.gatewayCoreStore.subscribe(function (state) { return state.output; }, function (output) {
                _this.log.debug('GatewayClientCore output changed', output);
                inputs.onOutputChange(clone(output));
            });
            this.orchestratorInst = new Orchestrator(this.gatewayCoreStore, inputs.messageEventInterface, this.instanceId, inputs.parameters, inputs.fetchConfig, inputs.postMessageTargetCallback, inputs.chainImplementation);
            this.gatewayCoreStore.setState(function (state) {
                state.inputs.parameters = clone(__assign(__assign({}, inputs.parameters), { payer: getPayer(inputs.parameters) }));
                state.internal.chainDetails = clone(inputs.chainImplementation.chainDetails);
                state.inputs.dynamicParameters = clone(inputs.dynamicParameters);
                state.internal.instanceId = _this.instanceId;
            });
            this.orchestratorInst.orchestrate();
            this.orchestratorInst.initialise();
            this.uiInst = new UIManager(this.gatewayCoreStore);
        }
        GatewayClientCore.getSingleInstance = function (inputs) {
            var _a, _b;
            var logger = prefixLogger('GatewayClientCore.getSingleInstance');
            if (!hasRequiredInputs(inputs)) {
                logger.debug('Missing wallet address or chain implementation, aborting previous and setting to undefined', inputs);
                (_a = GatewayClientCore.currentInstance) === null || _a === void 0 ? void 0 : _a.abort();
                GatewayClientCore.currentInstance = undefined;
                return undefined;
            }
            if (shouldUpdateInstance(inputs, GatewayClientCore.currentInstance)) {
                logger.debug('Inputs have changed, aborting previous and creating a new instance', inputs);
                (_b = GatewayClientCore.currentInstance) === null || _b === void 0 ? void 0 : _b.abort();
                GatewayClientCore.currentInstance = new GatewayClientCore(inputs);
            }
            return GatewayClientCore.currentInstance;
        };
        GatewayClientCore.prototype.updateDynamicParameters = function (dynamicParameters) {
            this.gatewayCoreStore.setState(function (state) {
                state.internal.userInteraction.status = null;
                state.inputs.dynamicParameters = clone(dynamicParameters);
            });
        };
        GatewayClientCore.prototype.updateGatekeeperNetworkServiceData = function (gknData) {
            this.gatewayCoreStore.setState(function (state) {
                state.inputs.gatekeeperNetworkData = clone(gknData);
            });
        };
        GatewayClientCore.prototype.startOrResumeFlow = function () {
            this.gatewayCoreStore.setState(function (state) {
                state.internal.userInteraction.status = UserInteractionStatus.STARTED;
            });
        };
        GatewayClientCore.prototype.abort = function () {
            this.log.info("GatewayClientCore aborting");
            this.orchestratorInst.abort();
        };
        Object.defineProperty(GatewayClientCore.prototype, "ui", {
            get: function () {
                var _this = this;
                return {
                    onShow: function () { return _this.uiInst.onShow(); },
                    onHide: function () { return _this.uiInst.onHide(); },
                    onLoad: function () { return _this.uiInst.onLoad(); },
                };
            },
            enumerable: false,
            configurable: true
        });
        return GatewayClientCore;
    }());

    var CIVIC_ANALYTICS_ENDPOINTS = {
        local: null,
        test: null,
        dev: 'https://dev.api.civic.com/analytics-dev/events',
        preprod: 'https://dev.api.civic.com/analytics-preprod/events',
        prod: 'https://api.civic.com/analytics/events',
    };
    var sendAnalyticsEvent = function (stage, event, sendBeacon) { return __awaiter(void 0, void 0, void 0, function () {
        var url, packageVersion, eventWithSource;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    url = CIVIC_ANALYTICS_ENDPOINTS[stage];
                    if (!url) {
                        localLogger.warn("No analytics endpoint configured for stage ".concat(stage, "."));
                        return [2];
                    }
                    packageVersion = event.civicClient || VERSION;
                    eventWithSource = __assign(__assign({}, event), { source: "passApi_".concat(stage), civicClient: packageVersion });
                    if (!sendBeacon) return [3, 1];
                    localLogger.debug('Beacon API supported. Using it to send analytics event.', { event: event });
                    sendBeacon(url, JSON.stringify(eventWithSource));
                    localLogger.debug('Analytics event sent.', { eventWithSource: eventWithSource });
                    return [3, 3];
                case 1:
                    localLogger.debug('Beacon API not supported. Falling back to fetch.', { eventWithSource: eventWithSource });
                    return [4, fetch(url, {
                            method: 'POST',
                            mode: 'no-cors',
                            body: JSON.stringify(eventWithSource),
                        })];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2];
            }
        });
    }); };
    var sendOnCloseAnalyticsEvent = function (flowParameters, pendingTxHash, sendBeacon) { return __awaiter(void 0, void 0, void 0, function () {
        var event_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!pendingTxHash) return [3, 2];
                    localLogger.debug('Abort received while tx is still pending on the chainImplementation. Sending analytics event.');
                    event_1 = {
                        did: flowParameters.did || '',
                        networkAddress: flowParameters.networkAddress || '',
                        chain: flowParameters.chain || '',
                        chainNetwork: flowParameters.chainNetwork || '',
                        ownerSigns: flowParameters.ownerSigns ? 'true' : 'false',
                        wallet: flowParameters.wallet || '',
                        domain: flowParameters.domain || '',
                        referrer: flowParameters.referrer || '',
                        action: 'CHAIN_ERROR',
                        errorCode: ErrorCode.BROWSER_CLOSED_WHILE_TRANSACTION_PENDING,
                        flowId: flowParameters.flowId || '',
                        flowType: flowParameters.flowType || '',
                        signedTx: pendingTxHash,
                        civicClient: flowParameters.civicClient,
                    };
                    if (!flowParameters.stage) {
                        localLogger.error('Unknown stage. Cannot send analytics event');
                        return [2];
                    }
                    return [4, sendAnalyticsEvent(flowParameters.stage, event_1, sendBeacon)];
                case 1:
                    _a.sent();
                    return [3, 3];
                case 2:
                    localLogger.debug('No pending tx in abort analytics handler. Not sending event.');
                    _a.label = 3;
                case 3: return [2];
            }
        });
    }); };

    exports.ChainError = ChainError;
    exports.ErrorCode = ErrorCode;
    exports.GKN_SERVICE_ENDPOINTS = GKN_SERVICE_ENDPOINTS;
    exports.GatekeeperClient = GatekeeperClient;
    exports.default = GatewayClientCore;
    exports.getGatekeeperEndpoint = getGatekeeperEndpoint;
    exports.getGatekeeperNetworkData = getGatekeeperNetworkData;
    exports.getInstanceInputObject = getInstanceInputObject;
    exports.hasRequiredInputs = hasRequiredInputs;
    exports.logger = localLogger;
    exports.prefixLogger = prefixLogger;
    exports.sendAnalyticsEvent = sendAnalyticsEvent;
    exports.sendOnCloseAnalyticsEvent = sendOnCloseAnalyticsEvent;
    exports.shouldUpdateInstance = shouldUpdateInstance;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=civic-gateway-client-core.umd.js.map

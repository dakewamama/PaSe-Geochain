import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import { Store } from '../src/state/state';
import { PartnerReview } from '../src/partnerReview';
import { GatekeeperAPIStatus, GatekeeperClientConfig } from '../src/types/gatekeeperApi';
import { GatekeeperClient } from '../src/gatekeeperClient';
import { getFetchStub, IntegrationTestHelpers, sleep } from './testSupport';
import { ChainType } from '../src/types/chain';
import { InputStatus } from '../src/types/fetch';

chai.use(chaiSubset);
const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('partner in review', () => {
  let fetchImplementationStub: any;
  let gatewayCoreStore: Store;
  let abortController: AbortController;
  let gatekeeperClient: GatekeeperClient;
  let partnerReview: PartnerReview;

  afterEach(() => {
    sandbox.restore();
    partnerReview.abort();
  });

  let clock: sinon.SinonFakeTimers;
  let pollingIntervalSeconds: number;
  let testHelpers: IntegrationTestHelpers;
  beforeEach(() => {
    pollingIntervalSeconds = 1;
    clock = sandbox.useFakeTimers();
    abortController = new AbortController();

    testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
    gatewayCoreStore = testHelpers.getInitializedStore();

    fetchImplementationStub = sandbox.stub();

    const config: GatekeeperClientConfig = {
      abortController: abortController,
      baseUrl: 'https://api.example.com',
      fetchImplementation: fetchImplementationStub,
      numRetries: 3,
      walletAddress: '0x123',
      stage: 'prod',
      queryParams: { network: 'test_network', gatekeeperNetworkAddress: 'test_gatekeeperNetworkAddress' },
      chainType: ChainType.ETHEREUM,
    };

    // Initialize the GatekeeperClient with the stubbed fetch
    gatekeeperClient = new GatekeeperClient(config);
  });

  context('pollForReviewFinished', () => {
    context('when the gatekeeper record is in the REQUESTED state', () => {
      beforeEach(() => {
        fetchImplementationStub
          .withArgs(
            `https://api.example.com/0x123?network=test_network&gatekeeperNetworkAddress=test_gatekeeperNetworkAddress`,
            {
              method: 'GET',
              headers: {
                'x-civic-flowid': sinon.match(
                  (value: string) => value.startsWith('GWRC_'),
                  'x-civic-flowid should start with GWRC_'
                ),
              },
              signal: sinon.match.any,
            }
          )
          .resolves(getFetchStub(GatekeeperAPIStatus.REQUESTED, { pending: { presentationRequestId: '123' } }));
      });

      it('should create a new timer and call the gatekeeper-api', async () => {
        partnerReview = new PartnerReview(gatewayCoreStore, gatekeeperClient, abortController, pollingIntervalSeconds);
        await partnerReview.pollForReviewFinished();
        // one initial call and one using the interval
        clock.tick(pollingIntervalSeconds * 1 * 1000);
        expect(fetchImplementationStub.callCount).to.equal(2);
      });

      it('should not update state', async () => {
        const setStateStub: sinon.SinonStub<any[], any> = sandbox.stub();
        gatewayCoreStore.setState = setStateStub;
        partnerReview = new PartnerReview(gatewayCoreStore, gatekeeperClient, abortController, pollingIntervalSeconds);
        await partnerReview.pollForReviewFinished();
        clock.tick(pollingIntervalSeconds * 1 * 1000);

        expect(setStateStub.callCount).to.eq(0);
      });

      context('when the gatekeeper returns SERVER_FAILURE', () => {
        beforeEach(() => {
          fetchImplementationStub
            .withArgs(
              `https://api.example.com/0x123?network=test_network&gatekeeperNetworkAddress=test_gatekeeperNetworkAddress`,
              {
                method: 'GET',
                headers: {
                  'x-civic-flowid': sinon.match(
                    (value: string) => value.startsWith('GWRC_'),
                    'x-civic-flowid should start with GWRC_'
                  ),
                },
                signal: sinon.match.any,
              }
            )
            .resolves(getFetchStub(GatekeeperAPIStatus.SERVER_FAILURE, {}));
        });
        it('should clear interval and not poll again', async () => {
          partnerReview = new PartnerReview(
            gatewayCoreStore,
            gatekeeperClient,
            abortController,
            pollingIntervalSeconds
          );
          await partnerReview.pollForReviewFinished();
          expect(fetchImplementationStub.callCount).to.equal(1);
        });
      });

      context('should stop polling on aborted signal', () => {
        beforeEach(() => {
          fetchImplementationStub
            .withArgs(
              `https://api.example.com/0x123?network=test_network&gatekeeperNetworkAddress=test_gatekeeperNetworkAddress`,
              {
                method: 'GET',
                headers: {
                  'x-civic-flowid': sinon.match(
                    (value: string) => value.startsWith('GWRC_'),
                    'x-civic-flowid should start with GWRC_'
                  ),
                },
                signal: sinon.match.any,
              }
            )
            .resolves(getFetchStub(GatekeeperAPIStatus.REQUESTED, { pending: { presentationRequestId: '123' } }));
        });

        it('should stop polling after abort is called', async () => {
          partnerReview = new PartnerReview(
            gatewayCoreStore,
            gatekeeperClient,
            abortController,
            pollingIntervalSeconds
          );
          await partnerReview.pollForReviewFinished();
          clock.tick(pollingIntervalSeconds * 1 * 1000);
          expect(fetchImplementationStub.callCount).to.equal(2);
          // should stop the polling
          partnerReview.abort();
          fetchImplementationStub.resetHistory();
          clock.tick(pollingIntervalSeconds * 4 * 1000);
          expect(fetchImplementationStub.callCount).to.equal(0);
        });
      });
    });

    Object.values(GatekeeperAPIStatus)
      // filter out statuses that are handled explicitly
      .filter(
        (apiStatus: GatekeeperAPIStatus) =>
          ![GatekeeperAPIStatus.REQUESTED, GatekeeperAPIStatus.SERVER_FAILURE].includes(apiStatus)
      )
      .forEach((status: GatekeeperAPIStatus) => {
        context('if the abort signal is triggered', () => {
          let clearIntervalStub: sinon.SinonStub<[intervalId: NodeJS.Timeout | undefined], void>;
          beforeEach(() => {
            // use sandbox to stub clearInterval
            clearIntervalStub = sandbox.stub(global, 'clearInterval');
          });
          afterEach(() => {
            abortController = new AbortController();
          });
          it('should clear the review finished interval', async () => {
            abortController.abort();
            partnerReview = new PartnerReview(
              gatewayCoreStore,
              gatekeeperClient,
              abortController,
              pollingIntervalSeconds
            );
            await partnerReview.pollForReviewFinished();
            expect(clearIntervalStub.calledOnce).to.be.true;
          });
        });

        context(
          `with a GatekeeperAPIStatus of ${GatekeeperAPIStatus[status]} when the gatekeeper record starts with a non-requested state`,
          () => {
            beforeEach(async () => {
              fetchImplementationStub.resetHistory();
              fetchImplementationStub
                .withArgs(
                  `https://api.example.com/0x123?network=test_network&gatekeeperNetworkAddress=test_gatekeeperNetworkAddress`,
                  {
                    method: 'GET',
                    headers: {
                      'x-civic-flowid': sinon.match(
                        (value: string) => value.startsWith('GWRC_'),
                        'x-civic-flowid should start with GWRC_'
                      ),
                    },
                    signal: sinon.match.any,
                  }
                )
                .resolves(getFetchStub(status, { pending: { presentationRequestId: '123' } }));

              partnerReview = new PartnerReview(
                gatewayCoreStore,
                gatekeeperClient,
                abortController,
                pollingIntervalSeconds
              );
              await partnerReview.pollForReviewFinished();
              clock.runToLastAsync();
            });

            it('should update the state and clear the interval', async () => {
              await sleep(10);
              const state = gatewayCoreStore.getState();
              expect(state.inputs.gatekeeperRecord.status).to.equal(InputStatus.COMPLETE);
              expect(state.inputs.gatekeeperRecord.received).to.containSubset({
                state: status,
                payload: {
                  pending: { presentationRequestId: '123' },
                },
              });
              expect(fetchImplementationStub.callCount).to.equal(1);
            });
          }
        );

        context(
          `with a GatekeeperAPIStatus of ${GatekeeperAPIStatus[status]} when the gatekeeper record starts with a requested state and changes to non-requested`,
          () => {
            it('should eventually update the state and clear the interval after polling', async () => {
              fetchImplementationStub.resetHistory();
              fetchImplementationStub
                .withArgs(
                  `https://api.example.com/0x123?network=test_network&gatekeeperNetworkAddress=test_gatekeeperNetworkAddress`,
                  {
                    method: 'GET',
                    headers: {
                      'x-civic-flowid': sinon.match(
                        (value: string) => value.startsWith('GWRC_'),
                        'x-civic-flowid should start with GWRC_'
                      ),
                    },
                    signal: sinon.match.any,
                  }
                )
                .onFirstCall()
                .resolves(getFetchStub(GatekeeperAPIStatus.REQUESTED, { pending: { presentationRequestId: '123' } }));

              fetchImplementationStub
                .withArgs(
                  `https://api.example.com/0x123?network=test_network&gatekeeperNetworkAddress=test_gatekeeperNetworkAddress`,
                  {
                    method: 'GET',
                    headers: {
                      'x-civic-flowid': sinon.match(
                        (value: string) => value.startsWith('GWRC_'),
                        'x-civic-flowid should start with GWRC_'
                      ),
                    },
                    signal: sinon.match.any,
                  }
                )
                .onSecondCall()
                .resolves(getFetchStub(status, { pending: { presentationRequestId: '123' } }));

              partnerReview = new PartnerReview(
                gatewayCoreStore,
                gatekeeperClient,
                abortController,
                pollingIntervalSeconds
              );
              await partnerReview.pollForReviewFinished();
              clock.tick(pollingIntervalSeconds * 1 * 1000);
              clock.runToLastAsync();
              await sleep(10);
              const state = gatewayCoreStore.getState();
              expect(state.inputs.gatekeeperRecord.status).to.equal(InputStatus.COMPLETE);
              expect(state.inputs.gatekeeperRecord.received).to.containSubset({
                state: status,
                payload: {
                  pending: { presentationRequestId: '123' },
                },
              });
              expect(fetchImplementationStub.callCount).to.equal(2);
            });
          }
        );
      });
  });
});

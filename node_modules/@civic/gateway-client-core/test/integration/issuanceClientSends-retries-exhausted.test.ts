import { step } from 'mocha-steps';
import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import chaiAsPromised from 'chai-as-promised';
import sinonChai from 'sinon-chai';
import { IntegrationTestHelpers, sleep } from '../testSupport';

chai.use(sinonChai);
chai.use(chaiSubset);
chai.use(chaiAsPromised);

const sandbox = sinon.createSandbox();

describe('GatewayClientCore issuance resume from requested state requesting a fresh transaction', () => {
  let testHelpers: IntegrationTestHelpers;

  context('send chain TX with all the attempts failing', () => {
    before(() => {
      testHelpers = new IntegrationTestHelpers(sandbox);
      testHelpers.stubSuccessfulFetchCalls();
      testHelpers.stubFreshTransactionPostFetchCall();
    });

    after(() => {
      testHelpers.cleanup();
      sandbox.restore();
    });

    step('1. expect the Gatekeeper client to successfully initialize with clientSendMaxRetries of 2', () => {
      testHelpers.initializeGatewayCore({ options: { clientSendsMaxRetries: 2 } });
    });

    step('wait for GK and on-chain checks to complete', async () => {
      await sleep(110);
    });

    step('2. Expect gateway status to change to NOT_REQUESTED', async () => {
      testHelpers.expectNotRequested();
    });

    step('3. Expect successful civic-sign public-key, did and POWO flows', async () => {
      await testHelpers.expectSuccessfulCivicSignProofFlow();
    });

    step('4. Set up tests so that user will abort transaction', () => {
      testHelpers.prepareUserAbortedTransaction();
    });

    step('5. Simulate initial client sending data to gatekeeper then aborting transaction', async () => {
      await testHelpers.simulateSucessfulDataCollectionTriggeringGKTokenRequest();
    });

    step('6. Wait for chain transaction to attempt to send and fail', async () => {
      await sleep(120);
    });

    step('7. The status should change to ERROR when the transaction gets aborted', async () => {
      testHelpers.expectChainError();
    });

    step('8. Simulate client retrying once the chain error screen is shown', async () => {
      await testHelpers.simulateCivicPassChainFailureEvent();
    });

    step('9. Wait for chain transaction to attempt to send and fail', async () => {
      await sleep(120);
    });

    step('10. The status should change to ERROR', async () => {
      testHelpers.expectChainError();
    });

    step('11. Simulate another error client sending the transaction', async () => {
      await testHelpers.simulateCivicPassChainFailureEvent();
    });

    step('12. Wait for chain transaction to attempt to send and fail', async () => {
      await sleep(120);
    });

    step('13. The status should change to ERROR', async () => {
      testHelpers.expectChainError();
    });

    step('14. Simulate a successfull client sending of transaction when presented to the user', async () => {
      await sleep(110);
      testHelpers.prepareSuccessfulHandleTransaction();
    });

    step('15. Simulate the user confirming they want to try with a new transaction', async () => {
      await testHelpers.simulateCivicPassChainFailureEvent();
    });

    step('16. The user should be presented with a screen to re-issue the transaction', async () => {
      await sleep(120);
      testHelpers.expectClientSendsRequestNewTransaction();
    });

    step('17. Wait for the transaction to be returned and sent by the client', async () => {
      await sleep(120);
      await testHelpers.expectClientSendTransactionToBeSent(4);
    });

    step(
      '18. OnChain listener fires with active token and gateway status and gateway token are updated to active',
      async () => {
        await testHelpers.simulateActiveOnChainToken();
        testHelpers.expectActiveToken();
      }
    );
  });
});

import { ExtendedGatewayStatus, GatewayStatus } from '../../src';
import { internalToOutputGatewayStatus } from '../../src/state/stateMapping';
import chai from 'chai';

const { expect } = chai;
describe('stateMapping', () => {
  context('internalToOutputGatewayStatus', () => {
    context('GatewayStatus.IN_REVIEW mappings', () => {
      [
        ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION,
        ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION,
        ExtendedGatewayStatus.TOKEN_IN_PARTNER_REVIEW,
        ExtendedGatewayStatus.TOKEN_REFRESH_IN_REVIEW,
        ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND,
        ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN,
        ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED,
        ExtendedGatewayStatus.REFRESH_CLIENT_PAYER_REQUESTED,
        ExtendedGatewayStatus.REFRESH_IN_REVIEW,
        ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND,
        ExtendedGatewayStatus.REFRESH_AWAITING_ON_CHAIN_TOKEN,
        ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
        ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND,
      ].forEach((status) => {
        it(`should map ${status} to GatewayStatus.IN_REVIEW`, () => {
          // Arrange
          // Act
          const result = internalToOutputGatewayStatus(status);
          // Assert
          expect(result).to.equal(GatewayStatus.IN_REVIEW);
        });
      });
    });

    context('ERROR mappings', () => {
      [
        ExtendedGatewayStatus.CHAIN_TIMEOUT_ERROR,
        ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
        ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR,
      ].forEach((status) => {
        it(`should map ${status} to GatewayStatus.ERROR`, () => {
          // Arrange
          // Act
          const result = internalToOutputGatewayStatus(status);
          // Assert
          expect(result).to.equal(GatewayStatus.ERROR);
        });
      });
    });

    context('NOT_REQUESTED mappings', () => {
      [ExtendedGatewayStatus.RESTART, ExtendedGatewayStatus.ISSUANCE_RESTART_DATA_COLLECTION].forEach((status) => {
        it(`should map ${status} to GatewayStatus.NOT_REQUESTED`, () => {
          // Arrange
          // Act
          const result = internalToOutputGatewayStatus(status);
          // Assert
          expect(result).to.equal(GatewayStatus.NOT_REQUESTED);
        });
      });
    });
    context('REFRESH_TOKEN_REQUIRED mappings', () => {
      [ExtendedGatewayStatus.RESTART_REFRESH].forEach((status) => {
        it(`should map ${status} to GatewayStatus.REFRESH_TOKEN_REQUIRED`, () => {
          // Arrange
          // Act
          const result = internalToOutputGatewayStatus(status);
          // Assert
          expect(result).to.equal(GatewayStatus.REFRESH_TOKEN_REQUIRED);
        });
      });
    });

    context('USER_INFORMATION_VALIDATED mappings', () => {
      [ExtendedGatewayStatus.REFRESH_USER_INFORMATION_VALIDATED].forEach((status) => {
        it(`should map ${status} to GatewayStatus.USER_INFORMATION_VALIDATED`, () => {
          // Arrange
          // Act
          const result = internalToOutputGatewayStatus(status);
          // Assert
          expect(result).to.equal(GatewayStatus.USER_INFORMATION_VALIDATED);
        });
      });
    });

    context('default mappings', () => {
      it('should return the input status', () => {
        // Arrange
        const status = GatewayStatus.ACTIVE;
        // Act
        const result = internalToOutputGatewayStatus(status);
        // Assert
        expect(result).to.equal(status);
      });
    });
  });
});

import { InputStatus } from '../../src/types/fetch';
import { ExtendedGatewayStatus, GatewayStatus } from '../../src/types/gateway';
import { computeInternalStatus } from '../../src/state/gatewayStatus';
import { GatewayCoreState } from '../../src/types/gatewayCore';
import chai from 'chai';
import sinon from 'sinon';
import { initialInputState } from '../../src/state/state';
import { CivicPassMessageAction, CivicPassMessageEventResult } from '../../src/types/civicPass';
import { ChainError } from '../../src/utils/errors';
import { GatekeeperAPIStatus } from '../../src/types/gatekeeperApi';
import * as common from '../../src/state/common';

const { expect } = chai;
const sandbox = sinon.createSandbox();

describe('gatewayStatus', () => {
  afterEach(sandbox.restore);

  context('computeInternalStatus', () => {
    context('with a civic sign error', () => {
      context('with no civic-pass event', () => {
        it('should not change gateway status', () => {
          const state = {
            inputs: {
              ...initialInputState,
              civicSign: {
                status: InputStatus.ERROR,
              },
            },
            internal: {
              status: GatewayStatus.UNKNOWN,
            },
          } as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(GatewayStatus.UNKNOWN);
        });
      });

      it('should return the existing status', () => {
        const state = {
          inputs: {
            ...initialInputState,
            civicPass: {
              received: {
                event: CivicPassMessageEventResult.FAILURE,
                action: CivicPassMessageAction.CHAIN_ERROR,
              },
            },
            civicSign: {
              status: InputStatus.ERROR,
            },
          },
          internal: {
            status: ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION,
          },
        } as GatewayCoreState;
        const result = computeInternalStatus(state);
        expect(result).to.equal(ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION);
      });
    });
  });
  context('after initialization with gateway status as CHECKING', () => {
    const checkingState = {
      inputs: { ...initialInputState },
      internal: { status: GatewayStatus.CHECKING },
    } as GatewayCoreState;

    it('should return REJECTED if API state is REJECTED', () => {
      const state = {
        ...checkingState,
        inputs: {
          ...checkingState.inputs,
          gatekeeperRecord: {
            received: {
              state: GatekeeperAPIStatus.REJECTED,
            },
          },
        },
      };
      const result = computeInternalStatus(state as GatewayCoreState);
      expect(result).to.equal(GatewayStatus.REJECTED);
    });

    it('should return LOCATION_NOT_SUPPORTED if API state is LOCATION_NOT_SUPPORTED or ISSUED_LOCATION_NOT_SUPPORTED', () => {
      [GatekeeperAPIStatus.LOCATION_NOT_SUPPORTED, GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED].forEach(
        (recordState) => {
          const state = {
            ...checkingState,
            inputs: {
              ...checkingState.inputs,
              gatekeeperRecord: {
                received: {
                  state: recordState,
                },
              },
            },
          };
          const result = computeInternalStatus(state as GatewayCoreState);
          expect(result).to.equal(GatewayStatus.LOCATION_NOT_SUPPORTED);
        }
      );
    });

    it('should return VPN_NOT_SUPPORTED if API state is VPN_NOT_SUPPORTED or ISSUED_VPN_NOT_SUPPORTED', () => {
      [GatekeeperAPIStatus.VPN_NOT_SUPPORTED, GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED].forEach((recordState) => {
        const state = {
          ...checkingState,
          inputs: {
            ...checkingState.inputs,
            gatekeeperRecord: {
              received: {
                state: recordState,
              },
            },
          },
        };
        const result = computeInternalStatus(state as GatewayCoreState);
        expect(result).to.equal(GatewayStatus.VPN_NOT_SUPPORTED);
      });
    });

    it('should return ERROR if API state is REQUESTED_RETRIES_EXHAUSTED', () => {
      const state = {
        ...checkingState,
        inputs: {
          ...checkingState.inputs,
          gatekeeperRecord: {
            received: {
              state: GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED,
            },
          },
        },
      };
      const result = computeInternalStatus(state as GatewayCoreState);
      expect(result).to.equal(GatewayStatus.ERROR);
    });
  });

  context('information retrieval is still in progress', () => {
    context('if gatewayRecord and gatewayToken inputs are in progress', () => {
      it('should return GatewayStatus.CHECKING', () => {
        // Arrange
        const state = {
          inputs: {
            ...initialInputState,
            gatekeeperRecord: { status: InputStatus.IN_PROGRESS },
            gatewayToken: { status: InputStatus.IN_PROGRESS },
          },
          internal: { status: GatewayStatus.UNKNOWN },
        } as GatewayCoreState;
        const result = computeInternalStatus(state);
        expect(result).to.equal(GatewayStatus.CHECKING);
      });
    });

    context('with a civic-pass chain error failure', () => {
      context('with too many client sends attempts', () => {
        it('should set status to RESTART', () => {
          const state = {
            inputs: {
              ...initialInputState,
              civicPass: {
                received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
              },
            },
            internal: {
              chainTransaction: { error: new ChainError('error sending tx'), attempts: 4 },
              status: ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
            },
          } as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX);
        });

        context('with a third party payer', () => {
          it('should set status to RESTART', () => {
            const state = {
              inputs: {
                ...initialInputState,
                civicPass: {
                  received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
                },
                parameters: {
                  payer: 'test-payer',
                },
              },
              internal: {
                chainTransaction: { error: new ChainError('error sending tx'), attempts: 4 },
                status: ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
              },
            } as GatewayCoreState;
            const result = computeInternalStatus(state);
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
          });
        });
      });

      context('with internal status as CHAIN_SIGN_MESSAGE_ERROR', () => {
        it('should set status to RESTART if it is not refresh flow', () => {
          const state = {
            inputs: {
              ...initialInputState,
              civicPass: {
                received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
              },
              gatewayToken: {
                received: undefined,
              },
            },
            internal: {
              status: ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR,
            },
          } as unknown as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX);
        });

        context('with a third party payer', () => {
          it('should set status to RESTART if it is not refresh flow', () => {
            const state = {
              inputs: {
                ...initialInputState,
                civicPass: {
                  received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
                },
                gatewayToken: {
                  received: undefined,
                },
                parameters: {
                  payer: 'test-payer',
                },
              },
              internal: {
                status: ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR,
              },
            } as unknown as GatewayCoreState;
            const result = computeInternalStatus(state);
            expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
          });
        });

        it('should set status to RESTART_REFRESH if it is a refreh flow', () => {
          const state = {
            inputs: {
              ...initialInputState,
              civicPass: {
                received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
              },
              gatewayToken: {
                received: { state: 'ACTIVE' },
              },
            },
            internal: {
              status: ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR,
            },
          } as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX);
        });

        context('with a third party payer', () => {
          it('should set status to RESTART_REFRESH if it is a refreh flow', () => {
            const state = {
              inputs: {
                ...initialInputState,
                civicPass: {
                  received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
                },
                gatewayToken: {
                  received: { state: 'ACTIVE' },
                },
                parameters: {
                  payer: 'test-payer',
                },
              },
              internal: {
                status: ExtendedGatewayStatus.CHAIN_SIGN_MESSAGE_ERROR,
              },
            } as GatewayCoreState;
            const result = computeInternalStatus(state);
            expect(result).to.equal(ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX);
          });
        });
      });

      context('with some client-sends attempts left', () => {
        it('should set status to ISSUANCE_AWAITING_TRANSACTION_SEND', () => {
          const state = {
            inputs: {
              ...initialInputState,
              civicPass: {
                received: { event: CivicPassMessageEventResult.FAILURE, action: CivicPassMessageAction.CHAIN_ERROR },
              },
            },
            internal: {
              chainTransaction: { error: new ChainError('error sending tx'), attempts: 1 },
              status: ExtendedGatewayStatus.CHAIN_TRANSACTION_ERROR,
            },
          } as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND);
        });
      });
    });

    context('with user validation failed', () => {
      context('with disableAutoRestartOnValidationFailure set to false or undefined', () => {
        it('should return RESTART state', () => {
          const state = {
            inputs: {
              ...initialInputState,
              parameters: {},
            },
            internal: {
              status: ExtendedGatewayStatus.USER_VALIDATION_FAILED,
            },
          } as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.RESTART);
        });
      });

      context('with disableAutoRestartOnValidationFailure set to true', () => {
        it('should return USER_VALIDATION_FAILED as a final state', () => {
          const state = {
            inputs: {
              ...initialInputState,
              parameters: {
                options: {
                  disableAutoRestartOnValidationFailure: true,
                },
              },
            },
            internal: {
              status: ExtendedGatewayStatus.USER_VALIDATION_FAILED,
            },
          } as GatewayCoreState;
          const result = computeInternalStatus(state);
          expect(result).to.equal(ExtendedGatewayStatus.USER_VALIDATION_FAILED);
        });
      });
    });
  });

  context('issuance is requested and GatewayStatus is IN_REVIEW', () => {
    const inReviewState = {
      inputs: {
        ...initialInputState,
        civicPass: {
          received: {
            event: CivicPassMessageEventResult.SUCCESS,
            action: CivicPassMessageAction.ISSUANCE,
          },
        },
      },
      internal: {
        status: ExtendedGatewayStatus.ISSUANCE_CLIENT_PAYER_REQUESTED,
      },
    } as GatewayCoreState;

    context('with GK-API returning a failed or rejected state', () => {
      it('should return REJECTED if API state is REJECTED', () => {
        const state = {
          ...inReviewState,
          inputs: {
            ...inReviewState.inputs,
            gatekeeperRecord: {
              received: {
                state: GatekeeperAPIStatus.REJECTED,
              },
            },
          },
        };
        const result = computeInternalStatus(state as GatewayCoreState);
        expect(result).to.equal(GatewayStatus.REJECTED);
      });

      it('should return LOCATION_NOT_SUPPORTED if API state is LOCATION_NOT_SUPPORTED or ISSUED_LOCATION_NOT_SUPPORTED', () => {
        [GatekeeperAPIStatus.LOCATION_NOT_SUPPORTED, GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED].forEach(
          (recordState) => {
            const state = {
              ...inReviewState,
              inputs: {
                ...inReviewState.inputs,
                gatekeeperRecord: {
                  received: {
                    state: recordState,
                  },
                },
              },
            };
            const result = computeInternalStatus(state as GatewayCoreState);
            expect(result).to.equal(GatewayStatus.LOCATION_NOT_SUPPORTED);
          }
        );
      });

      it('should return VPN_NOT_SUPPORTED if API state is VPN_NOT_SUPPORTED or ISSUED_VPN_NOT_SUPPORTED', () => {
        [GatekeeperAPIStatus.VPN_NOT_SUPPORTED, GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED].forEach((recordState) => {
          const state = {
            ...inReviewState,
            inputs: {
              ...inReviewState.inputs,
              gatekeeperRecord: {
                received: {
                  state: recordState,
                },
              },
            },
          };
          const result = computeInternalStatus(state as GatewayCoreState);
          expect(result).to.equal(GatewayStatus.VPN_NOT_SUPPORTED);
        });
      });

      it('should return ERROR if API state is REQUESTED_RETRIES_EXHAUSTED', () => {
        const state = {
          ...inReviewState,
          inputs: {
            ...inReviewState.inputs,
            gatekeeperRecord: {
              received: {
                state: GatekeeperAPIStatus.REQUESTED_RETRIES_EXHAUSTED,
              },
            },
          },
        };
        const result = computeInternalStatus(state as GatewayCoreState);
        expect(result).to.equal(GatewayStatus.ERROR);
      });
    });
  });

  context('final states', () => {
    [
      ExtendedGatewayStatus.RESTART,
      ExtendedGatewayStatus.RESTART_REFRESH,
      GatewayStatus.ERROR,
      GatewayStatus.REJECTED,
      GatewayStatus.LOCATION_NOT_SUPPORTED,
      GatewayStatus.VPN_NOT_SUPPORTED,
    ].forEach((finalStatus) => {
      it(`should return the same status as ${finalStatus} is a final state`, () => {
        const state = {
          inputs: {
            ...initialInputState,
          },
          internal: {
            status: finalStatus,
          },
        } as GatewayCoreState;
        const result = computeInternalStatus(state);
        expect(result).to.equal(finalStatus);
      });
    });
  });

  context('unhandled states', () => {
    [
      ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION,
      ExtendedGatewayStatus.AWAITING_OWNER_TRANSACTION,
      ExtendedGatewayStatus.CONFIRM_OWNER_TRANSACTION,
    ].forEach((finalStatus) => {
      it(`should return the same status as ${finalStatus} these status are not mapped to other states`, () => {
        const state = {
          inputs: {
            ...initialInputState,
          },
          internal: {
            status: finalStatus,
          },
        } as GatewayCoreState;
        const result = computeInternalStatus(state);
        expect(result).to.equal(finalStatus);
      });
    });
  });

  context('with a state that is invalid or not mapped', () => {
    it('should throw an error if status is unknow', () => {
      const state = {
        inputs: {
          ...initialInputState,
        },
        internal: {
          status: 'known-invalid-status' as ExtendedGatewayStatus,
        },
      } as GatewayCoreState;
      expect(() => computeInternalStatus(state)).to.throw(
        'No transition function defined for known-invalid-status status'
      );
    });

    it('should throw an error if no status if undefined', () => {
      const state = {
        inputs: {
          ...initialInputState,
        },
        internal: {
          // status is not defined
        },
      } as GatewayCoreState;
      expect(() => computeInternalStatus(state)).to.throw('No transition function defined for undefined status');
    });
  });

  context('with a computeFn that returns a new state that is not a valid transition', () => {
    beforeEach(() => {
      sandbox
        .stub(common, 'statusFromGatewayTokenIfExists')
        .returns('invalid-state' as unknown as common.GatewayTokenCheckType);
    });

    afterEach(() => {
      sandbox.restore();
    });

    it('should throw an error', async () => {
      const state = {
        inputs: {
          ...initialInputState,
        },
        internal: {
          status: GatewayStatus.UNKNOWN,
        },
      } as GatewayCoreState;
      // stub the UNKNOWN compute function to return an invalid state for that transition
      expect(() => computeInternalStatus(state)).to.throw(/Invalid transition/);
    });
  });
});

import GatewayClientCore, {
  ClientCoreInput,
  ClientCoreOutput,
  FlowParameters,
  FlowStatus,
  GatewayInput,
  GatewayStatus,
  GknData,
  PostMessageInterface,
} from '../src';
import { ChainClientInterface, ChainEvent, ChainType, GatewayToken, SignatureMethod, State } from '../src/types/chain';
import EventEmitter from 'events';
import chai from 'chai';
import sinon from 'sinon';
import { FetchConfig, InputStatus } from '../src/types/fetch';
import chaiSubset from 'chai-subset';
import chaiAsPromised from 'chai-as-promised';
import sinonChai from 'sinon-chai';
import { GatekeeperAPIStatus } from '../src/types/gatekeeperApi';
import {
  CivicPassMessageAction,
  CivicPassMessageEventResult,
  CivicPassMessageResponse,
  ValidationStatus,
} from '../src/types/civicPass';
import { CivicSignEventTypeRequest, CivicSignEventTypeResponse } from '../src/types/civicSign';
import { GatekeeperHttpConfig, GatewayClientParameters } from '../src/types/parameters';
import { nowSeconds } from '../src/utils/expiry';
import { UserInteractionStatus } from '../src/types/userInteraction';
import { createGatewayCoreStore, Store } from '../src/state/state';
import * as getGatekeeperNetworkData from '../src/gatekeeperNetworkService';
import { v4 as uuid } from 'uuid';

chai.use(sinonChai);
chai.use(chaiSubset);
chai.use(chaiAsPromised);
const { expect } = chai;
export const sleep = (ms: number): Promise<void> => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

export const getFetchStub = (status: number, response: any = {}) => {
  return {
    status,
    json: () => Promise.resolve(response),
    clone: () => ({
      // Add a clone method that returns an object similar to the original response
      json: () => Promise.resolve(response),
    }),
  };
};

export type IntegrationTestHelperInputs = {
  walletAddress: string;
  network: string;
  gatekeeperNetwork: string;
  did: string;
  clientSends: boolean;
};

export const defaultHelperInputs: IntegrationTestHelperInputs = {
  walletAddress: '0x123',
  network: '123',
  gatekeeperNetwork: 'testnetwork',
  did: `did:example:${123}`,
  clientSends: true,
};

export const mockProofObj = {
  proof: 'proof',
  signatureMethod: SignatureMethod.MESSAGE,
};
const requestTokenPayload = {
  acceptedTermsAndConditionsLink: 'https://www.civic.com/terms',
  provider: 'web',
  civicPassAuthToken: 'civicPassAuthToken',
};

const refreshTokenPayload = {
  acceptedTermsAndConditionsLink: 'https://www.civic.com/terms',
  provider: 'web',
  civicPassAuthToken: 'civicPassAuthToken',
  request: 'refresh',
};

const transactionStub = 'tx';
const transactionId = 'txId';

export class IntegrationTestHelpers {
  protected client: GatewayClientCore;

  protected gatekeeperConfig: GatekeeperHttpConfig;

  protected postMessageCallbackStub: sinon.SinonStub<any[], any>;

  protected signMessageStub: sinon.SinonStub<any[], any>;

  protected handleTransactionStub: sinon.SinonStub<any[], any>;

  protected fetchStub: sinon.SinonStub<any[], any>;

  protected proveWalletOwnershipStub: sinon.SinonStub<any[], any>;

  public clientOutput: ClientCoreOutput;

  protected onTokenChange: (gatewayToken: GatewayToken) => void;

  protected simulateTokenChange;

  protected chainImplementationStub: ChainClientInterface;

  protected findTokenStub: sinon.SinonStub<[], Promise<GatewayToken | undefined>>;

  protected emitter: EventEmitter;

  readonly inputs: IntegrationTestHelperInputs;

  private initTokenExpirySeconds: number;

  private clientSendsAttemptCount = 0;

  protected getGatekeeperNetworkDataStub: sinon.SinonStub<
    [stage: string, gknId: string],
    Promise<getGatekeeperNetworkData.GknData>
  >;

  constructor(
    readonly sandbox: sinon.SinonSandbox,
    inInputs: Partial<IntegrationTestHelperInputs> = defaultHelperInputs
  ) {
    this.gatekeeperConfig = {
      baseUrl: 'https://civicgatekeeperapi.com',
      headers: {},
    };
    this.inputs = { ...defaultHelperInputs, ...inInputs };
    this.postMessageCallbackStub = sandbox.stub();
    this.emitter = new EventEmitter();
    this.initTokenExpirySeconds = nowSeconds() + 1000;
    this.signMessageStub = this.sandbox.stub();
    this.handleTransactionStub = sandbox.stub();
    this.fetchStub = sandbox.stub();
    this.proveWalletOwnershipStub = sandbox.stub();
    this.proveWalletOwnershipStub.resolves(mockProofObj);
    this.simulateTokenChange = (token: GatewayToken) => this.onTokenChange(token);

    this.findTokenStub = this.sandbox.stub();
    this.findTokenStub.callsFake(async () => {
      await sleep(100);
      return Promise.resolve(undefined);
    });
    this.chainImplementationStub = {
      on: (_event: ChainEvent, listener: (GatewayToken: GatewayToken) => void) => {
        this.onTokenChange = listener;
      },
      findGatewayToken: this.findTokenStub,
      proveWalletOwnership: this.proveWalletOwnershipStub,
      handleTransaction: this.handleTransactionStub,
      // dids that own the passed-in address
      ownerDids: () => Promise.resolve([this.inputs.did]),
      chainDetails: {
        chainType: ChainType.SOLANA,
        chainNetwork: this.inputs.network,
      },
      onDestroy: () => {},
    } as unknown as ChainClientInterface;
    this.stubGatekeeperNetworkServiceCall();
  }

  getInitializedStore(): Store {
    const store = createGatewayCoreStore({ name: 'test' });
    store.setState((state) => {
      state.internal.instanceId = 'test';
      state.internal.status = GatewayStatus.CHECKING;
      state.internal.userInteraction.status = UserInteractionStatus.STARTED;
      state.inputs.parameters = this.getCoreInputs().parameters;
      state.internal.chainDetails = {
        chainType: ChainType.SOLANA,
        chainNetwork: this.inputs.network,
      };
      state.inputs.gatewayToken.status = InputStatus.COMPLETE;
      state.inputs.gatewayToken.received = null;
      state.inputs.civicPass.status = InputStatus.COMPLETE;
      state.inputs.civicPass.received = {
        event: CivicPassMessageEventResult.SUCCESS,
        action: CivicPassMessageAction.STATUS,
        payload: {
          status: ValidationStatus.NOT_FOUND,
        },
      };
      state.inputs.gatekeeperNetworkData.status = InputStatus.COMPLETE;
      state.inputs.gatekeeperNetworkData.received = {
        id: 'testId',
        chains: {},
      };
    });
    return store;
  }

  resetStubsHistory() {
    this.postMessageCallbackStub.resetHistory();
  }

  stubGatekeeperNetworkServiceCall() {
    this.fetchStub.callsFake(async () => {
      await sleep(10);
      return getFetchStub(200, {});
    });
  }

  stubGetFetchCall({ getResponsePayload }: { getResponsePayload: [GatekeeperAPIStatus, Record<string, unknown>] }) {
    // stub GK call to check for an existing record
    // add a delay of 100 ms to simulate an async GK response
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/${this.inputs.walletAddress}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        {
          method: 'GET',
          headers: sinon.match.any,
          signal: sinon.match.any,
        }
      )
      .callsFake(async () => {
        await sleep(100);
        const [status, payload] = getResponsePayload;
        return getFetchStub(status, payload);
      });
  }

  stubPostFetchCall(
    {
      postResponsePayload,
      payer,
      additionalUrlPath = '',
      postRequestPayload,
    }: {
      postResponsePayload?: Record<string, unknown>;
      payer?: string | undefined | null;
      additionalUrlPath?: string;
      postRequestPayload?: Record<string, unknown> | null;
    } = {
      postResponsePayload: {},
      payer: this.inputs.walletAddress,
      additionalUrlPath: '',
      postRequestPayload: null,
    }
  ) {
    const usePostRequestPayload = postRequestPayload || {
      ...requestTokenPayload,
      address: this.inputs.walletAddress,
      ...(payer ? { payer } : {}),
    };
    // stub GK issuance request
    // add a delay of 1 second to simulate an async GK response
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/${additionalUrlPath}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        {
          method: 'POST',
          headers: {
            'x-civic-flowid': sinon.match(
              (value: string) => value.startsWith('GWRC_'),
              'x-civic-flowid should start with GWRC_'
            ),
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(usePostRequestPayload),
          signal: sinon.match.any,
        }
      )
      .callsFake(async () => {
        await sleep(110);
        return getFetchStub(GatekeeperAPIStatus.REQUESTED, {
          state: GatekeeperAPIStatus.REQUESTED,
          transaction: transactionStub,
          ...(postResponsePayload ? postResponsePayload : {}),
        });
      });
  }

  stubFreshTransactionPostFetchCall(
    {
      payer,
    }: {
      payer?: string | undefined | null;
    } = {
      payer: this.inputs.walletAddress,
    }
  ) {
    const postRequestPayload = {
      ...(payer ? { payer } : {}),
    };
    return this.stubPostFetchCall({
      payer,
      additionalUrlPath: `${this.inputs.walletAddress}/transaction`,
      postRequestPayload,
    });
  }

  stubFreshTransactionRefreshPostFetchCall(
    {
      payer,
    }: {
      payer?: string | undefined | null;
    } = {
      payer: this.inputs.walletAddress,
    }
  ) {
    const usePostRequestPayload = {
      ...(payer ? { payer } : {}),
    };
    return this.stubPostFetchCall({
      payer,
      additionalUrlPath: `${this.inputs.walletAddress}/transaction`,
      postRequestPayload: usePostRequestPayload,
    });
  }

  stubRefreshPatchCall({
    patchRequestPayload,
    patchResponsePayload,
  }: {
    patchRequestPayload?: Record<string, unknown> | undefined;
    patchResponsePayload?: Record<string, unknown> | undefined;
  } = {}) {
    const usePatchRequestPayload = patchRequestPayload || {
      ...refreshTokenPayload,
      payer: this.inputs.walletAddress,
    };
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/${this.inputs.walletAddress}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        {
          method: 'PATCH',
          headers: {
            'x-civic-flowid': sinon.match(
              (value: string) => value.startsWith('GWRC_'),
              'x-civic-flowid should start with GWRC_'
            ),
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(usePatchRequestPayload),
          signal: sinon.match.any,
        }
      )
      .callsFake(async () => {
        await sleep(110);
        return getFetchStub(GatekeeperAPIStatus.ISSUED, {
          state: GatekeeperAPIStatus.ISSUED,
          transaction: transactionStub,
          ...(patchResponsePayload ? patchResponsePayload : {}),
        });
      });
  }

  stubSuccessfulFetchCalls(
    {
      withExistingGatekeeperRecord,
      getResponsePayload,
      postResponsePayload,
      payer,
      postRequestPayload,
    }: {
      withExistingGatekeeperRecord?: boolean;
      getResponsePayload?: [GatekeeperAPIStatus, Record<string, unknown>];
      postResponsePayload?: Record<string, unknown>;
      payer?: string | undefined | null;
      postRequestPayload?: Record<string, unknown> | null;
    } = {
      withExistingGatekeeperRecord: false,
      getResponsePayload: undefined,
      postResponsePayload: {},
      payer: this.inputs.walletAddress,
    }
  ) {
    const payload: [GatekeeperAPIStatus, Record<string, unknown>] = getResponsePayload
      ? getResponsePayload
      : withExistingGatekeeperRecord
      ? [GatekeeperAPIStatus.REQUESTED, { provider: 'web' }]
      : [GatekeeperAPIStatus.NOT_REQUESTED, {}];

    this.stubGetFetchCall({ getResponsePayload: payload });

    this.stubPostFetchCall({
      postResponsePayload,
      postRequestPayload,
      payer,
    });
  }

  simulateGatekeeperRequestTokenRejection(
    gatekeeperAPIStatus: GatekeeperAPIStatus = GatekeeperAPIStatus.REJECTED,
    errorCode?: string,
    payload: Record<string, unknown> = {}
  ) {
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/${this.inputs.walletAddress}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        {
          method: 'GET',
          headers: sinon.match.any,
          signal: sinon.match.any,
        }
      )
      .callsFake(async () => {
        await sleep(100);
        return getFetchStub(gatekeeperAPIStatus, {
          state: gatekeeperAPIStatus,
          errorCode,
          ...(payload ? { payload } : {}),
        });
      });

    // stub GK issuance request to simulate a rejection
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        {
          method: 'POST',
          headers: {
            'x-civic-flowid': sinon.match(
              (value: string) => value.startsWith('GWRC_'),
              'x-civic-flowid should start with GWRC_'
            ),
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            ...requestTokenPayload,
            address: this.inputs.walletAddress,
            payer: this.inputs.clientSends ? this.inputs.walletAddress : undefined,
          }),
          signal: sinon.match.any,
        }
      )
      .callsFake(async () => {
        await sleep(110);
        return getFetchStub(gatekeeperAPIStatus, {
          state: gatekeeperAPIStatus,
          errorCode,
          ...(payload ? { payload } : {}),
        });
      });
    // stub GK refresh request to simulate a rejection
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/${this.inputs.walletAddress}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        sinon.match({
          method: 'PATCH',
        })
      )
      .callsFake(async () => {
        await sleep(110);
        return getFetchStub(gatekeeperAPIStatus, {
          state: gatekeeperAPIStatus,
          errorCode,
          ...(payload ? { payload } : {}),
        });
      });
  }

  expectFlowParameterInputs(testParams: Partial<FlowParameters> = {}) {
    expect(this.clientOutput.flowParameters).to.containSubset({
      wallet: this.inputs.walletAddress,
      networkAddress: this.inputs.gatekeeperNetwork,
      gatekeeperSendsTransaction: !this.inputs.clientSends,
      instanceId: this.client.instanceId,
      ...testParams,
    });
  }

  getCoreInputs(
    parameterOverrides: Partial<GatewayClientParameters> = {},
    chainImplementation: ChainClientInterface = this.chainImplementationStub
  ) {
    return {
      postMessageTargetCallback: () => ({ postMessage: this.postMessageCallbackStub } as PostMessageInterface),
      messageEventInterface: {
        addMessageEventListener: (handler: EventListener): void => {
          this.emitter.on('message', handler);
        },
        removeMessageEventListener: () => ({}),
      },
      parameters: {
        wallet: { address: this.inputs.walletAddress },
        gatekeeperConfig: this.gatekeeperConfig,
        gatekeeperNetwork: this.inputs.gatekeeperNetwork,
        stage: 'test',
        payer: this.inputs.clientSends ? this.inputs.walletAddress : undefined,
        gatekeeperSendsTransaction: !this.inputs.clientSends,
        flowIdPrefix: 'GWRC',
        ...parameterOverrides,
      },
      fetchConfig: { fetchImplementation: this.fetchStub, numRetries: 3 } as FetchConfig,
      onOutputChange: (output: ClientCoreOutput) => {
        this.clientOutput = output;
      },
      chainImplementation: chainImplementation,
    } as ClientCoreInput;
  }

  initializeGatewayCore(
    parameterOverrides: Partial<GatewayClientParameters> = {},
    expectedInitialState = GatewayStatus.CHECKING
  ) {
    const coreInputs = this.getCoreInputs(parameterOverrides);

    // initialize the GatewayClientCore
    this.client = new GatewayClientCore(coreInputs);

    // check the initial status
    expect(this.clientOutput.gatewayStatus).to.equal(expectedInitialState);
    // it should have called the fetch method to check for an existing record
    if (!parameterOverrides.disableInitialGatekeeperLookup) {
      expect(this.fetchStub).to.have.been.calledOnce;
    }

    return this;
  }

  expectNotRequested() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.NOT_REQUESTED);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.ISSUANCE });
  }

  expectStartNewTx() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.USER_INFORMATION_VALIDATED);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION });
  }

  expectClientSendsInReview() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.SIGN_TRANSACTION });
  }

  expectClientSendsAwaitingConfirmation() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.AWAITING_TRANSACTION_CONFIRMATION });
  }

  expectCivicSendsInReview() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.TOKEN_IN_REVIEW });
  }

  expectInPartnerReview() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.TOKEN_IN_PARTNER_REVIEW });
  }

  expectClientSendsRequestNewTransaction() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
    this.expectFlowParameterInputs({ action: CivicPassMessageAction.AWAITING_TRANSACTION_CONFIRMATION });
  }

  prepareGKApiPollingResponse(gatekeeperAPIStatus: GatekeeperAPIStatus, payload: Record<string, unknown> = {}) {
    this.fetchStub
      .withArgs(
        `${this.gatekeeperConfig.baseUrl}/${this.inputs.walletAddress}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`,
        {
          method: 'GET',
          headers: sinon.match.any,
          signal: sinon.match.any,
        }
      )
      .callsFake(async () => {
        await sleep(100);
        return getFetchStub(gatekeeperAPIStatus, {
          state: gatekeeperAPIStatus,
          ...payload,
        });
      });
  }

  expectPendingPayload(payload: Record<string, unknown>) {
    expect(this.clientOutput.pendingRequests).to.deep.eq(payload);
  }

  expectGKApiPolling() {
    expect(this.fetchStub.callCount).to.be.greaterThan(1);
  }

  expectRefreshTokenRequired() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.REFRESH_TOKEN_REQUIRED);
  }

  expectCivicSignResponse(postMessageInput: any) {
    expect(this.postMessageCallbackStub).to.have.been.calledWith(postMessageInput);
  }

  async expectSuccessfulCivicSignPublicKeyRequestResponse() {
    const requestId = uuid();
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        request: CivicSignEventTypeRequest.REQUEST_PUBLIC_KEY,
        payload: {},
        requestId,
      },
    });
    // The event handler is asynchronous. The call above just emits the event, it doesn't await the promise of the handler.
    // So we have to give the event time to be handled.
    await sleep(200);
    this.expectCivicSignResponse({
      event: CivicSignEventTypeResponse.RESPONSE_PUBLIC_KEY,
      instanceId: this.client.instanceId,
      data: this.inputs.walletAddress,
      requestId,
    });
  }

  async expectSuccessfulCivicSignDIDRequestResponse() {
    const requestId = uuid();
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        request: CivicSignEventTypeRequest.REQUEST_DID,
        payload: {},
        requestId,
      },
    });
    // The event handler is asynchronous. The call above just emits the event, it doesn't await the promise of the handler.
    // So we have to give the event time to be handled.
    await sleep(200);
    this.expectCivicSignResponse({
      event: CivicSignEventTypeResponse.RESPONSE_DID,
      instanceId: this.client.instanceId,
      data: this.inputs.did,
      requestId,
    });
  }

  async expectSuccessfulCivicSignProofRequestResponse() {
    const requestId = uuid();
    this.signMessageStub.resolves(Buffer.from('signature'));
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        request: CivicSignEventTypeRequest.REQUEST_SIGNED_PROOF,
        payload: 'message-to-sign',
        requestId,
      },
    });
    // The event handler is asynchronous. The call above just emits the event, it doesn't await the promise of the handler.
    // So we have to give the event time to be handled.
    await sleep(200);
    expect(this.proveWalletOwnershipStub).to.have.been.calledWith('message-to-sign');
    this.expectCivicSignResponse({
      event: CivicSignEventTypeResponse.RESPONSE_SIGNED_PROOF,
      instanceId: this.client.instanceId,
      data: mockProofObj,
      requestId,
    });
  }

  async expectSuccessfulCivicSignProofFlow() {
    //  await this.expectSuccessfulCivicSignPublicKeyRequestResponse();
    await this.expectSuccessfulCivicSignDIDRequestResponse();
    // await this.expectSuccessfulCivicSignProofRequestResponse();
  }

  UiOnShow() {
    this.client.ui.onShow();
  }

  UiOnHide() {
    this.client.ui.onHide();
  }

  async simulateDataCollectionStatusEvent(validationStatus: ValidationStatus) {
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.SUCCESS,
        action: CivicPassMessageAction.STATUS,
        // here goes the payload required for the issuance action
        // it will be different depending on the pass type
        payload: {
          status: validationStatus,
        },
      },
    });
  }

  async simulateSucessfulDataCollectionTriggeringGKRefreshRequest() {
    this.fetchStub.resetHistory();
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.SUCCESS,
        action: CivicPassMessageAction.REFRESH,
        // here goes the payload required for the issuance action
        // it will be different depending on the pass type
        payload: refreshTokenPayload,
        requiresProviderApproval: false,
      },
    });
    // should have requested a token refresh
    const url = this.fetchStub.getCall(0).args[0];
    expect(url).to.eq(
      `https://civicgatekeeperapi.com/${this.inputs.walletAddress}?network=${this.inputs.network}&gatekeeperNetworkAddress=${this.inputs.gatekeeperNetwork}`
    );
    const postMessageCallObj = this.fetchStub.getCall(0).args[1];

    expect(postMessageCallObj).to.containSubset({
      method: 'PATCH',
      body: JSON.stringify({
        ...refreshTokenPayload,
        payer: this.inputs.clientSends ? this.inputs.walletAddress : undefined,
      }),
    });
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
  }

  async simulateSucessfulDataCollectionTriggeringGKTokenRequest() {
    this.fetchStub.resetHistory();
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.SUCCESS,
        action: CivicPassMessageAction.ISSUANCE,
        // here goes the payload required for the issuance action
        // it will be different depending on the pass type
        payload: requestTokenPayload,
        requiresProviderApproval: false,
      },
    });
    // should have requested the token issuance
    const postMessageCallObj = this.fetchStub.getCall(0).args[1];
    expect(postMessageCallObj).to.containSubset({
      method: 'POST',
      body: JSON.stringify({
        ...requestTokenPayload,
        address: this.inputs.walletAddress,
        payer: this.inputs.clientSends ? this.inputs.walletAddress : undefined,
      }),
    });
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
  }

  async simulateIframeEventTriggeringFreshTransactionRequest() {
    this.fetchStub.resetHistory();
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.SUCCESS,
        action: CivicPassMessageAction.START_PRE_APPROVED_TRANSACTION,
        // the payload for pre-approved tx is null as no POWO or checks are required
        payload: null,
        requiresProviderApproval: false,
      },
    });
    await sleep(120);
    // should have requested the token issuance
    const postMessageCallObj = this.fetchStub.getCall(0).args[1];
    expect(postMessageCallObj).to.containSubset({
      method: 'POST',
      body: JSON.stringify({
        payer: this.inputs.clientSends ? this.inputs.walletAddress : undefined,
      }),
    });
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
  }

  prepareUserAbortedTransaction() {
    this.handleTransactionStub.rejects(new Error('User aborted'));
  }

  async simulateClientSideSendTransactionError() {
    this.fetchStub.resetHistory();

    await this.simulateSucessfulDataCollectionTriggeringGKTokenRequest();
    // state changed to IN_REVIEW after token is requested
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
  }

  async simulateCivicPassInProgressEvent() {
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.IN_PROGRESS,
        action: CivicPassMessageAction.ISSUANCE,
        // here goes the payload required for the issuance action
        // it will be different depending on the pass type
        payload: {
          provider: 'web',
        },
        requiresProviderApproval: false,
      },
    });
  }

  async prepareSuccessfulHandleTransaction() {
    this.handleTransactionStub.callsFake(() => {
      this.clientSendsAttemptCount += 1;
      return Promise.resolve(`${transactionId}_${this.clientSendsAttemptCount}`);
    });
  }

  async prepareSuccessfulThirdPartyHandleTransaction() {
    this.handleTransactionStub.callsFake(() => {
      return Promise.resolve(`${transactionId}_third_party`);
    });
  }

  async simulateCivicPassChainFailureEvent() {
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.FAILURE,
        action: CivicPassMessageAction.CHAIN_ERROR,
      },
    });
  }

  async simulateCivicPassFailureEvent() {
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.FAILURE,
        action: CivicPassMessageAction.ISSUANCE,
      },
    });
  }

  async simulateCivicPassRejectionAction(gkAPIState: GatekeeperAPIStatus) {
    let action;
    switch (gkAPIState) {
      case GatekeeperAPIStatus.REJECTED:
        action = CivicPassMessageAction.TOKEN_REJECTED;
        break;
      case GatekeeperAPIStatus.VPN_NOT_SUPPORTED:
      case GatekeeperAPIStatus.ISSUED_VPN_NOT_SUPPORTED:
        action = CivicPassMessageAction.FAILED_VPN_CHECK;
        break;
      case GatekeeperAPIStatus.LOCATION_NOT_SUPPORTED:
      case GatekeeperAPIStatus.ISSUED_LOCATION_NOT_SUPPORTED:
        action = CivicPassMessageAction.FAILED_IP_CHECK;
        break;
      default:
        action = CivicPassMessageAction.ERROR;
    }
    this.emitter.emit('message', {
      data: {
        instanceId: this.client.instanceId,
        source: '',
        event: CivicPassMessageEventResult.SUCCESS,
        action,
      },
    });
    // these actions have no follow-up actions, so userIntegration status should be finished
    expect(this.clientOutput.flowState?.userInteraction?.status).to.equal(UserInteractionStatus.FINISHED);
  }

  expectClientSendTransactionToBeSent(expectedNumberOfAttempts = this.clientSendsAttemptCount) {
    expect(this.handleTransactionStub.callCount).to.eq(expectedNumberOfAttempts);
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.IN_REVIEW);
    this.expectFlowParameterInputs({
      signedTx: `${transactionId}_${this.clientSendsAttemptCount}`,
    });
  }

  expectChainError() {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.ERROR);
    expect(this.clientOutput.flowParameters?.action).to.equal(CivicPassMessageAction.CHAIN_ERROR);
  }

  expectError(errorCode?: string) {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.ERROR);
    expect(this.clientOutput.flowParameters?.action).to.equal(CivicPassMessageAction.ERROR);
    if (errorCode) {
      expect(this.clientOutput.flowParameters?.errorCode).to.equal(errorCode);
    }
  }

  getGatewayToken(expiry?: number): GatewayToken {
    return {
      expiryTime: expiry || this.initTokenExpirySeconds,
      state: State.ACTIVE,
      identifier: 'token123',
      owner: this.inputs.walletAddress,
      gatekeeperNetworkAddress: this.inputs.gatekeeperNetwork,
      issuingGatekeeper: 'gk123',
    } as GatewayToken;
  }

  async simulateActiveOnChainToken(expiry?: number) {
    await this.simulateTokenChange(this.getGatewayToken(expiry));
  }

  async simulateExpiredOnChainToken() {
    await this.simulateTokenChange(this.getGatewayToken(this.initTokenExpirySeconds - 10000));
  }

  stubFindToken(tokenDetails: Partial<GatewayToken> | null) {
    this.findTokenStub.callsFake(async () => {
      await sleep(100);
      return Promise.resolve(tokenDetails === null ? undefined : { ...this.getGatewayToken(), ...tokenDetails });
    });
  }

  stubFindTokenRejection() {
    this.findTokenStub.callsFake(async () => {
      await sleep(100);
      return Promise.reject(new Error('RPC error'));
    });
  }

  expectActiveToken(expiry?: number) {
    expect(this.clientOutput.gatewayStatus).to.equal(GatewayStatus.ACTIVE);
    expect(this.clientOutput.gatewayToken).to.deep.eq(this.getGatewayToken(expiry));
  }

  expectTokenActiveScreenShown() {
    expect(this.clientOutput?.flowState?.status).to.eq(FlowStatus.IN_PROGRESS);
    expect(this.clientOutput?.ui?.isVisible).to.be.true;
  }

  expectTokenActiveScreenHidden() {
    expect(this.clientOutput?.flowState?.status).to.eq(FlowStatus.FINISHED);
    expect(this.clientOutput?.ui?.isVisible).to.be.false;
  }

  async simulateUserFinishedFlow(eventOverrides: Partial<CivicPassMessageResponse> = {}) {
    this.emitter.emit('message', {
      data: {
        action: CivicPassMessageAction.TOKEN_ACTIVE,
        event: CivicPassMessageEventResult.SUCCESS,
        requiresProofOfWalletOwnership: false,
        instanceId: this.client.instanceId,
        ...eventOverrides,
      },
    });
    await sleep(100);
    expect(this.clientOutput.flowState?.status).to.eq(UserInteractionStatus.FINISHED);
  }

  async simulateUserErrorRetryFlow(eventOverrides: Partial<CivicPassMessageResponse> = {}) {
    this.emitter.emit('message', {
      data: {
        action: CivicPassMessageAction.ERROR,
        event: CivicPassMessageEventResult.FAILURE,
        requiresProofOfWalletOwnership: false,
        instanceId: this.client.instanceId,
        ...eventOverrides,
      },
    });
  }

  expectRejected(
    rejectionStatus = GatewayStatus.REJECTED,
    expectedErrorCode?: string,
    expectedPayload?: Record<string, unknown>
  ) {
    expect(this.clientOutput.gatewayStatus).to.equal(rejectionStatus);
    if (expectedErrorCode) {
      expect(this.clientOutput?.flowParameters?.errorCode).to.equal(expectedErrorCode);
    }
    if (expectedPayload) {
      expect(this.clientOutput?.flowParameters?.payload).to.equal(JSON.stringify(expectedPayload));
    }
  }

  expectStatus(gatewayStatus: GatewayStatus) {
    expect(this.clientOutput.gatewayStatus).to.equal(gatewayStatus);
  }

  triggerForceRefresh() {
    this.client.updateDynamicParameters({ forceRequireRefresh: true });
  }

  updateGknData(gknData: GatewayInput<GknData>) {
    this.client.updateGatekeeperNetworkServiceData(gknData);
  }

  expectFlowIdToBeSet(prefix = 'GWRC') {
    expect(this.clientOutput.flowParameters?.flowId).to.be.a('string');
    expect(this.clientOutput.flowParameters?.flowId).contains(prefix);
  }

  cleanup() {
    if (this.client) {
      this.client.abort();
    }
  }
}

import { SinonStubbedInstance } from 'sinon';
import {
  CivicSignEventTypeRequest,
  CivicSignEventTypeRequestMessage,
  CivicSignEventTypeResponse,
} from '../src/types/civicSign';
import { EventEmitter, handleRemoteSignEvent, RemoteError, RemoteSignWindowEventEmitter } from '../src/remoteSign';
import { ChainClientInterface, ProveWalletOwnershipResponse, SignatureMethod } from '../src/types/chain';
import { WalletAdapter } from '../src/types/parameters';
import chai from 'chai';
import sinon from 'sinon';
import { ChainError } from '../src/utils/errors';
import { v4 as uuid } from 'uuid';
const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('remoteSign', () => {
  let message: CivicSignEventTypeRequestMessage;
  let remoteSignerInstStub: SinonStubbedInstance<RemoteSignWindowEventEmitter>;
  let wallet: WalletAdapter;
  let did: string;
  let chainImplementationStub: ChainClientInterface;
  let requestId: string;
  afterEach(sandbox.restore);

  beforeEach(() => {
    wallet = { address: '0x123' };
    did = 'did:sol:0x123';
    requestId = uuid();
    chainImplementationStub = {
      ownerDids: () => Promise.resolve([did]),
      proveWalletOwnership: () => {},
      signMessage: (useMessage: Uint8Array) => useMessage,
    } as unknown as ChainClientInterface;

    remoteSignerInstStub = sandbox.createStubInstance(RemoteSignWindowEventEmitter);
    remoteSignerInstStub.sendPublicKey.withArgs(wallet.address).resolves(wallet.address);
    remoteSignerInstStub.sendDid.withArgs(did).resolves(did);
  });

  context('with unstubbed class instance', () => {
    let remoteSignerInst: RemoteSignWindowEventEmitter;
    let postMessageTarget: EventEmitter;
    let postMessageStub: sinon.SinonStub;

    beforeEach(() => {
      postMessageStub = sandbox.stub();
      postMessageTarget = {
        postMessage: postMessageStub,
      };
      remoteSignerInst = new RemoteSignWindowEventEmitter(postMessageTarget, 'test');
    });
    context('sendPublicKey', () => {
      it('should emit an event with the public key', async () => {
        await remoteSignerInst.sendPublicKey(requestId, wallet.address);
        expect(postMessageStub).calledWith({
          event: CivicSignEventTypeResponse.RESPONSE_PUBLIC_KEY,
          data: wallet.address,
          instanceId: 'test',
          requestId,
        });
      });
    });

    context('sendDid', () => {
      it('should emit an event with the did', async () => {
        await remoteSignerInst.sendDid(requestId, did);
        expect(postMessageStub).calledWith({
          event: CivicSignEventTypeResponse.RESPONSE_DID,
          data: did,
          instanceId: 'test',
          requestId,
        });
      });
    });

    context('sendSignedProof', () => {
      it('should emit an event with the proof and signatureMethod', async () => {
        await remoteSignerInst.sendSignedProof(requestId, 'proof', SignatureMethod.MESSAGE);
        expect(postMessageStub).calledWith({
          event: CivicSignEventTypeResponse.RESPONSE_SIGNED_PROOF,
          data: { proof: 'proof', signatureMethod: SignatureMethod.MESSAGE },
          instanceId: 'test',
          requestId,
        });
      });
    });

    context('sendSignedMessage', () => {
      it('should emit an event with the message', async () => {
        await remoteSignerInst.sendSignedMessage(requestId, Buffer.from('test_message'));
        expect(postMessageStub).calledWith({
          event: CivicSignEventTypeResponse.RESPONSE_SIGNED_MESSAGE,
          data: Buffer.from('test_message'),
          instanceId: 'test',
          requestId,
        });
      });
    });

    context('sendError', () => {
      it('should emit an event with the error', async () => {
        await remoteSignerInst.sendError(
          requestId,
          CivicSignEventTypeRequest.REQUEST_DID,
          new ChainError('test_error', 'test_code')
        );
        expect(postMessageStub).calledWith({
          event: CivicSignEventTypeResponse.RESPONSE_ERROR,
          data: {
            request: CivicSignEventTypeRequest.REQUEST_DID,
            error: {
              message: 'test_error',
              code: 'test_code',
            },
          },
          instanceId: 'test',
          requestId,
        });
      });
    });
  });

  context('handleRemoteSignEvent', () => {
    context('when the event is REQUEST_PUBLIC_KEY', () => {
      beforeEach(() => {
        wallet = { address: '0x123' };
        message = {
          requestId,
          request: CivicSignEventTypeRequest.REQUEST_PUBLIC_KEY,
        };
      });

      it('should call remoteSigner sendPublicKey with the wallet address', async () => {
        await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(remoteSignerInstStub.sendPublicKey).calledWith(requestId, wallet.address);
      });

      it('should return the sendPublicKey', async () => {
        const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(response).to.equal(wallet.address);
      });
    });

    context('when the event is REQUEST_DID', () => {
      beforeEach(() => {
        message = {
          requestId,
          request: CivicSignEventTypeRequest.REQUEST_DID,
        };
      });
      it('should call remoteSigner sendDid', async () => {
        await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(remoteSignerInstStub.sendDid).calledWith(requestId, did);
      });

      it('should return the did', async () => {
        const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(response).to.equal(did);
      });
    });

    context('when the event is REQUEST_SIGNED_PROOF', () => {
      let proveWalletOwnershipStub: sinon.SinonStub;
      beforeEach(() => {
        message = {
          requestId,
          request: CivicSignEventTypeRequest.REQUEST_SIGNED_PROOF,
          payload: 'proof',
        };
        proveWalletOwnershipStub = sinon.stub(chainImplementationStub, 'proveWalletOwnership');
        proveWalletOwnershipStub.withArgs(message.payload as string).resolves({
          proof: 'test_proof',
          signatureMethod: 'test_signatureMethod',
        } as unknown as ProveWalletOwnershipResponse);
      });

      it('should call chainImplementation.proveWalletOwnership with the payload', async () => {
        await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(chainImplementationStub.proveWalletOwnership).calledWith('proof');
      });

      it('should call remoteSigner sendSignedProof with the proof and signatureMethod', async () => {
        await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(remoteSignerInstStub.sendSignedProof).calledWith(requestId, 'test_proof', 'test_signatureMethod');
      });

      context('when the chainImplementation call throws an error', () => {
        beforeEach(() => {
          proveWalletOwnershipStub.withArgs(message.payload as string).rejects(new Error('test_error'));
        });

        it('should call remoteSigner sendError with the error', async () => {
          await handleRemoteSignEvent(message, remoteSignerInstStub, {
            wallet,
            chainImplementation: chainImplementationStub,
          });
          const sendErrorArgs = remoteSignerInstStub.sendError.getCall(0).args;
          expect(sendErrorArgs[0]).to.equal(requestId);
          expect(sendErrorArgs[1]).to.equal(CivicSignEventTypeRequest.REQUEST_SIGNED_PROOF);
          expect(sendErrorArgs[2]).to.be.instanceOf(ChainError);
        });

        it('should return the error', async () => {
          const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
            wallet,
            chainImplementation: chainImplementationStub,
          });
          expect((response as RemoteError)?.request).to.equal(CivicSignEventTypeRequest.REQUEST_SIGNED_PROOF);
        });
      });
    });

    context('when the event is REQUEST_SIGNED_MESSAGE', () => {
      let chainImplResponse: Buffer;
      let signMessageStub: sinon.SinonStub;
      beforeEach(() => {
        message = {
          requestId,
          request: CivicSignEventTypeRequest.REQUEST_SIGNED_MESSAGE,
          payload: 'proof',
        };
        chainImplResponse = Buffer.from(
          JSON.stringify({ proof: 'test_signedMessage', signatureMethod: SignatureMethod.MESSAGE })
        );
        signMessageStub = sinon.stub(chainImplementationStub, 'signMessage');
        signMessageStub.withArgs(Buffer.from(message.payload?.toString() as string)).resolves(chainImplResponse);
      });

      it('should call chainImplementation.signMessage with a buffer created from the payload', async () => {
        await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(chainImplementationStub.signMessage).calledWith(Buffer.from('proof'));
      });

      it('should call remoteSigner signMessage with the chainImpl signedMessage response', async () => {
        await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(remoteSignerInstStub.sendSignedMessage).calledWith(requestId, chainImplResponse);
      });

      it('should return the chainImpl signedMessage response', async () => {
        const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(response).to.deep.equal(chainImplResponse);
      });

      it('should return an error if the chainImplementation does not support signMessage', async () => {
        chainImplementationStub.signMessage = undefined;
        const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(response).to.have.property('error');
        expect((response as RemoteError).error.message).to.equal('Chain implementation does not support signMessage');
      });

      context('when the chainImplementation call throws an error', () => {
        beforeEach(() => {
          signMessageStub.withArgs(Buffer.from(message.payload as string)).rejects(new Error('test_error'));
        });

        it('should call remoteSigner sendError with the error', async () => {
          await handleRemoteSignEvent(message, remoteSignerInstStub, {
            wallet,
            chainImplementation: chainImplementationStub,
          });
          const sendErrorArgs = remoteSignerInstStub.sendError.getCall(0).args;
          expect(sendErrorArgs[0]).to.equal(requestId);
          expect(sendErrorArgs[1]).to.equal(CivicSignEventTypeRequest.REQUEST_SIGNED_MESSAGE);
          expect(sendErrorArgs[2]).to.be.instanceOf(ChainError);
        });

        it('should return the error', async () => {
          const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
            wallet,
            chainImplementation: chainImplementationStub,
          });
          expect((response as RemoteError)?.request).to.equal(CivicSignEventTypeRequest.REQUEST_SIGNED_MESSAGE);
        });
      });
    });

    context('when the event is UNKNOWN_EVENT', () => {
      beforeEach(() => {
        message = {
          request: 'UNKNOWN_EVENT' as CivicSignEventTypeRequest,
          payload: 'proof',
          requestId,
        };
      });

      it('should return undefined', async () => {
        const response = await handleRemoteSignEvent(message, remoteSignerInstStub, {
          wallet,
          chainImplementation: chainImplementationStub,
        });
        expect(response).to.be.undefined;
      });
    });
  });
});

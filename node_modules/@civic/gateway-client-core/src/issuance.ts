import { GatekeeperClient } from './gatekeeperClient';
import { prefixLogger } from './logger';
import { LoggingInterface } from './logger/provider.logger';
import { OrchestratorFlow } from './orchestratorFlow';
import { Store } from './state/state';
import { ChainClientInterface } from './types/chain';
import { CivicPassMessagePayload } from './types/civicPass';
import { InputStatus } from './types/fetch';
import { TokenRequest } from './types/gatekeeperApi';
import { GatewayCoreState } from './types/gatewayCore';
import { DEFAULT_EXPECT_TOKEN_TIMEOUT_SECONDS } from './utils/defaults';
import { ChainConfirmationTimeout } from './utils/errors';
import { getTokenRefreshIntervalMilliseconds } from './utils/expiry';

export class Issuance extends OrchestratorFlow {
  protected log: LoggingInterface;

  private timers: Partial<Record<'expectOnChainToken' | 'refreshCountdownTimer', any>> = {};

  currentPayload: CivicPassMessagePayload;

  constructor(
    readonly gatewayCoreStore: Store,
    readonly chainImplementation: ChainClientInterface,
    readonly gatekeeperClient: GatekeeperClient,
    readonly abortController: AbortController,
    readonly expectTokenTimeoutSeconds: number = DEFAULT_EXPECT_TOKEN_TIMEOUT_SECONDS
  ) {
    super(gatewayCoreStore, gatekeeperClient, abortController);
    this.log = prefixLogger(`Issuance instance with expectTokenTimeoutSeconds ${expectTokenTimeoutSeconds}`);
  }

  /**
   * gatewayStatus flow:
   * CHECKING
   * NOT_REQUESTED
   *
   * @param chainImplementation
   * @param this.abortController
   */
  async sendTransaction() {
    const fullState = this.gatewayCoreStore.getState();
    if (!fullState.inputs.gatekeeperRecord.received?.transaction) {
      this.log.error('Missing gatekeeperRecord payload');
      throw new Error('Missing gatekeeperRecord payload');
    }

    //clear any previous sending errors
    this.gatewayCoreStore.setState((draft) => {
      if (!draft.internal.chainTransaction) {
        draft.internal.chainTransaction = {
          attempts: 0,
        };
      }
      if (draft.internal.chainTransaction.attempts !== undefined) {
        draft.internal.chainTransaction.attempts += 1;
      }
      draft.internal.chainTransaction.sentTxId = undefined;
      draft.internal.errors.expectedOnChainToken = null;
      draft.inputs.gatewayToken.status = InputStatus.COMPLETE;
      draft.internal.chainTransaction.error = undefined;
      draft.inputs.civicPass.received = null;
    });
    // clear any previous errors
    this.abortExpectedTokenTimer();
    // client sends case
    if (!this.chainImplementation.handleTransaction) {
      this.log.error('No handleTransaction defined on chainImplementation.');
      throw new Error('No handleTransaction defined on chainImplementation');
    }

    const chainType = fullState.internal.chainDetails?.chainType;
    const frontendPollingTimeoutSeconds = chainType
      ? fullState.inputs.gatekeeperNetworkData.received?.chains[chainType]?.frontendPollingTimeoutSeconds
      : undefined;

    this.chainImplementation
      .handleTransaction(fullState.inputs.gatekeeperRecord.received.transaction, frontendPollingTimeoutSeconds)
      .then((txId) => {
        if (this.abortController.signal.aborted) return;
        this.gatewayCoreStore.setState((state) => {
          if (!state.internal.chainTransaction) {
            state.internal.chainTransaction = {};
          }

          // Fire and forget the request to set the TXId on the gatekeeper
          this.gatekeeperClient.updateTransactionStatus(txId);

          state.internal.chainTransaction.sentTxId = txId;
        });
      })
      .catch((error) => {
        this.gatewayCoreStore.setState((draft) => {
          if (!draft.internal.chainTransaction) {
            draft.internal.chainTransaction = {};
          }
          draft.internal.chainTransaction.error = error;
        });
      });
  }

  async gatekeeperRequest(payer: string | undefined, fullState: GatewayCoreState) {
    if (!fullState.inputs.civicPass.received?.payload) {
      this.log.error('Missing civicPass payload', fullState);
      throw new Error('Missing civicPass payload');
    }
    this.currentPayload = fullState.inputs.civicPass.received?.payload;
    return this.gatekeeperClient.requestGatewayTokenFromGatekeeper({
      payload: fullState.inputs.civicPass.received?.payload,
      payer,
    } as TokenRequest);
  }

  async freshTransactionGatekeeperRequest(payer: string | undefined) {
    return this.gatekeeperClient.fetchFreshTransaction({
      payer,
    } as TokenRequest);
  }

  clearStateBeforeGatekeeperRequest(isFreshTransactionRequest = false) {
    this.gatewayCoreStore.setState((state) => {
      state.internal.errors.expectedOnChainToken = null;
      state.inputs.gatewayToken.status = InputStatus.COMPLETE;
      state.inputs.gatekeeperRecord.received = null;
      state.inputs.gatekeeperRecord.status = InputStatus.IN_PROGRESS;
      if (isFreshTransactionRequest) {
        state.internal.chainTransaction = undefined;
      }
    });
  }

  async makeGatekeeperRequest({
    payer,
    isFreshTransactionRequest,
  }: {
    payer: string | undefined;
    isFreshTransactionRequest?: boolean;
  }) {
    const fullState = this.gatewayCoreStore.getState();
    this.setGatekeeperClientFlowId();
    this.log.debug('makeGatekeeperRequest', fullState);
    // clear any previous errors
    this.abortExpectedTokenTimer();
    this.clearStateBeforeGatekeeperRequest(isFreshTransactionRequest);
    const requestPromise = isFreshTransactionRequest
      ? this.freshTransactionGatekeeperRequest(payer)
      : this.gatekeeperRequest(payer, fullState);

    requestPromise
      .then((response) => {
        if (this.abortController.signal.aborted) return;
        this.gatewayCoreStore.setState((state) => {
          state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
          state.inputs.gatekeeperRecord.received = response;
        });
      })
      .catch((error) => {
        this.gatewayCoreStore.setState((state) => {
          state.inputs.gatekeeperRecord.status = InputStatus.ERROR;
          state.inputs.gatekeeperRecord.error = error;
        });
      });
  }

  async retrieveFreshTransaction(payer: string | undefined) {
    const fullState = this.gatewayCoreStore.getState();
    if (!fullState.inputs.civicPass.received?.payload) {
      this.log.error('Missing civicPass payload', fullState);
      throw new Error('Missing civicPass payload');
    }
    this.setGatekeeperClientFlowId();
    this.log.debug('retrieveFreshTransaction', fullState);
    // clear any previous errors
    this.abortExpectedTokenTimer();
    this.clearStateBeforeGatekeeperRequest();
    this.gatekeeperRequest(payer, fullState)
      .then((response) => {
        if (this.abortController.signal.aborted) return;
        this.gatewayCoreStore.setState((state) => {
          state.inputs.gatekeeperRecord.status = InputStatus.COMPLETE;
          state.inputs.gatekeeperRecord.received = response;
        });
      })
      .catch((error) => {
        this.gatewayCoreStore.setState((state) => {
          state.inputs.gatekeeperRecord.status = InputStatus.ERROR;
          state.inputs.gatekeeperRecord.error = error;
        });
      });
  }

  statusHasValidToken(): boolean {
    const updatedState = this.gatewayCoreStore.getState();
    return !!updatedState.inputs.gatewayToken.received;
  }

  /**
   * expect a token to exist in state before a timeout occurs
   */
  expectOnChainToken() {
    const fullState = this.gatewayCoreStore.getState();
    if (fullState.inputs.gatewayToken.received || this.timers.expectOnChainToken) {
      return;
    }

    this.timers.expectOnChainToken = setTimeout(() => {
      this.gatewayCoreStore.setState((state) => {
        if (!this.statusHasValidToken()) {
          state.internal.errors.expectedOnChainToken = new ChainConfirmationTimeout(
            'No on-chain token found within interval'
          );
        }
      });
    }, this.expectTokenTimeoutSeconds * 1000);
    this.log.debug('Started expected token timer', this.timers.expectOnChainToken);
  }

  abort() {
    this.abortExpectedTokenTimer();
    this.abortRefreshCountdownTimer();
  }

  /**
   * Clear the timer that expects an on-chain token
   */
  abortExpectedTokenTimer() {
    if (this.timers.expectOnChainToken) {
      this.log.debug('Aborting expected token timer', this.timers.expectOnChainToken);
      clearTimeout(this.timers.expectOnChainToken);
    }
  }

  /**
   * Clear the timer that expects an on-chain token
   */
  onActiveTokenFound() {
    this.abortExpectedTokenTimer();
    // clear the force require refresh flag to stop the flow restarting
    this.gatewayCoreStore.setState((state) => {
      if (state.inputs.dynamicParameters?.forceRequireRefresh !== undefined) {
        state.inputs.gatekeeperRecord.received = null;
        state.internal.chainTransaction = undefined;
        state.inputs.dynamicParameters.forceRequireRefresh = false;
      }
    });
    this.startRefreshCountdownTimer();
  }

  /**
   * start a countdown towards when the token will expire
   * so that we can update the state and prompt the user to refresh
   */
  startRefreshCountdownTimer() {
    const fullState = this.gatewayCoreStore.getState();
    const gatewayToken = fullState.inputs.gatewayToken.received;
    if (!gatewayToken?.expiryTime) {
      return;
    }

    this.abortRefreshCountdownTimer();
    const refreshIntervalDuration = getTokenRefreshIntervalMilliseconds(gatewayToken.expiryTime, 0);
    this.timers.refreshCountdownTimer = setTimeout(() => {
      this.abortRefreshCountdownTimer();
    }, refreshIntervalDuration);
    this.log.debug('Started refresh countdown timer', {
      gatewayToken,
      refreshCountdownTimer: this.timers.refreshCountdownTimer,
    });
  }

  abortRefreshCountdownTimer() {
    this.log.debug('abortRefreshCountdownTimer', {
      refreshCountdownTimer: this.timers.refreshCountdownTimer,
    });
    if (this.timers.refreshCountdownTimer) {
      clearTimeout(this.timers.refreshCountdownTimer);
      this.timers.refreshCountdownTimer = undefined;
    }
  }

  // reset civic-pass data collection so thta the user can restart the flow
  // and get a payload
  restartDataCollection() {
    this.gatewayCoreStore.setState((state) => {
      state.inputs.civicPass.received = null;
    });
  }
}

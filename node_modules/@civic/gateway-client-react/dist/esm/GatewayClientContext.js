import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import React, { useContext, useState, useEffect, useRef } from 'react';
import GatewayClientCore, { prefixLogger, shouldUpdateInstance, hasRequiredInputs, getInstanceInputObject, } from '@civic/gateway-client-core';
import IframeResizer from 'iframe-resizer-react';
import * as R from 'ramda';
import { GatewayStatus, LogLevel } from './types';
import { Wrapper } from './wrapper/Wrapper';
import { IFRAME_ID, TESTID_IFRAME, TESTID_WRAPPER, TESTID_WRAPPER_CONTAINER } from './lib/constants';
import { coreToReactGatewayStatus } from './lib/gatewayUtils';
import { VERSION as GATEWAY_CLIENT_REACT_VERSION } from './version';
import { usePageUnload } from './lib/pageUnloadHook';
const GatewayContext = React.createContext({
    requestGatewayToken: async () => { },
    gatewayStatus: GatewayStatus.UNKNOWN,
});
// to handle environments where globalThis is not available by default, like nextjs
// https://github.com/vercel/next.js/pull/45592
let globalThisObject;
if (typeof window !== 'undefined') {
    globalThisObject = window;
}
else if (typeof global !== 'undefined') {
    globalThisObject = global;
}
else {
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    globalThisObject = Function('return this')();
}
globalThisObject.globalThis = globalThisObject;
// If there is no window object (e.g. in an SSR environment) then the redirectUrl must be passed in.
// If none is passed in, use a default redirect url.
const DEFAULT_REDIRECT_URL = 'https://getpass.civic.com';
const redirectUrlFromWindow = () => { var _a; return ((_a = globalThis.window) === null || _a === void 0 ? void 0 : _a.location.href) ? encodeURIComponent(globalThis.window.location.href) : DEFAULT_REDIRECT_URL; };
const logLevels = [LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR];
export const GatewayProvider = ({ children = null, walletAddress, chainImplementation, wrapper, logo, stage = 'prod', 
// If set, this will be passed to the core in the xCivicClientVersion param,
// so it will be sent in the Gatekeeper header and analytics events.
// This allows a chain-specific component's version to be passed in if one is used.
// If not passed in, we will use the version of this generic gateway-client-react component.
reactComponentVersion, redirectUrl, gatekeeperNetwork, options = { autoShowModal: false }, payer, gatekeeperSendsTransaction, expiryMarginSeconds = 0, partnerAppId, forceRequireRefresh, expectTokenTimeoutSeconds, disableInitialGatekeeperLookup, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const logger = prefixLogger('GatewayProvider', 'gateway-client-react');
    if (logger.setLogLevel) {
        if (options.logLevel) {
            logger.setLogLevel(options.logLevel);
        }
        else if (typeof globalThis.window !== 'undefined') {
            const urlSearchParams = new URLSearchParams(window.location.search);
            const urllogLevel = urlSearchParams.get('logLevel');
            if (logLevels.includes(urllogLevel)) {
                logger.setLogLevel(urllogLevel);
            }
        }
    }
    if (payer && gatekeeperSendsTransaction)
        throw Error('Cannot set payer when gatekeeperSendsTransaction is true');
    const [clientCoreOutput, setClientCoreOutput] = useState();
    const [darkMode, setDarkMode] = useState(false);
    const onOutputChange = (output) => {
        const newClientOutput = R.clone(Object.assign(Object.assign({}, output), { gatewayStatus: coreToReactGatewayStatus(output === null || output === void 0 ? void 0 : output.gatewayStatus) }));
        logger.debug(`GatewayProvider.onOutputChange: setClientCoreOutput: ${setClientCoreOutput}`, newClientOutput);
        setClientCoreOutput(newClientOutput);
    };
    const parentSearchParams = new URLSearchParams(((_a = globalThis.window) === null || _a === void 0 ? void 0 : _a.location.search) || '');
    // If a chain-specific RC version was passed in, use that.
    // Otherwise, use the version of this generic package (gateway-client-react).
    // That way, we'll have some version header even if this generic component is used directly from a dApp.
    const clientVersionHeader = reactComponentVersion || GATEWAY_CLIENT_REACT_VERSION;
    const postMessageTargetCallback = (instanceId) => { var _a, _b, _c; return (_c = (_b = (_a = globalThis.document) === null || _a === void 0 ? void 0 : _a.getElementById) === null || _b === void 0 ? void 0 : _b.call(_a, `${IFRAME_ID}_${instanceId}`)) === null || _c === void 0 ? void 0 : _c.contentWindow; };
    const inputs = {
        postMessageTargetCallback: postMessageTargetCallback,
        messageEventInterface: {
            addMessageEventListener: (handler) => window.addEventListener('message', handler),
            removeMessageEventListener: (handler) => window.removeEventListener('message', handler),
        },
        parameters: {
            wallet: walletAddress
                ? {
                    address: walletAddress,
                }
                : undefined,
            xCivicClientHeader: clientVersionHeader,
            stage,
            redirectUrl: redirectUrl || redirectUrlFromWindow(),
            gatekeeperNetwork,
            options,
            payer,
            gatekeeperSendsTransaction,
            expiryMarginSeconds,
            partnerAppId,
            expectTokenTimeoutSeconds,
            disableInitialGatekeeperLookup,
            flowIdPrefix: 'GWRC',
            referrer: parentSearchParams.get('referrer') || ((_b = globalThis.document) === null || _b === void 0 ? void 0 : _b.referrer),
            domain: (_c = globalThis.window) === null || _c === void 0 ? void 0 : _c.location.hostname,
        },
        chainImplementation,
        fetchConfig: { fetchImplementation: fetch, numRetries: 3 },
        onOutputChange,
        dynamicParameters: { forceRequireRefresh },
    };
    // the gateway client instance must be handled by react to ensure proper lifecycle management
    // as react doesn't like non-pure components that create side-effects handling their own
    // instance management
    const gatewayClientCoreInst = useRef();
    useEffect(() => {
        var _a, _b;
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        setDarkMode(mediaQuery.matches);
        if (!hasRequiredInputs(inputs)) {
            (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.abort();
            gatewayClientCoreInst.current = undefined;
            return;
        }
        if (shouldUpdateInstance(inputs, gatewayClientCoreInst.current)) {
            (_b = gatewayClientCoreInst.current) === null || _b === void 0 ? void 0 : _b.abort();
            gatewayClientCoreInst.current = new GatewayClientCore(inputs);
        }
        // eslint-disable-next-line consistent-return
        return () => {
            var _a;
            (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.abort();
            gatewayClientCoreInst.current = undefined;
        };
    }, [JSON.stringify(getInstanceInputObject(inputs))]);
    // we need a useEffect to handle the output change cleanup as the instance gets set to undefined
    // if there's no walletAddress and calling onOutputChange on abort causes infinite rendering
    useEffect(() => {
        if (!walletAddress && !gatewayClientCoreInst.current) {
            logger.debug('GatewayProvider.onOutputChange undefined');
            onOutputChange(undefined);
        }
    }, [walletAddress]);
    // update dynamic parameters separately from instance creation as we don't want every to change if dynamic parameters change
    useEffect(() => {
        var _a;
        (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.updateDynamicParameters({ forceRequireRefresh });
    }, [forceRequireRefresh, (_d = gatewayClientCoreInst.current) === null || _d === void 0 ? void 0 : _d.instanceId]);
    const noRequestGatewayTokenFn = () => {
        logger.warn('GatewayProvider.requestGatewayToken() called before the Gateway is ready');
    };
    logger.debug('GatewayProvider.render', { clientCoreOutput, gatewayClientCoreInst });
    usePageUnload(clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.flowParameters, gatewayClientCoreInst.current);
    return (_jsx(GatewayContext.Provider, Object.assign({ value: {
            civicPassSrcUrl: (_e = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _e === void 0 ? void 0 : _e.url,
            // we need to provide a default here to support legacy implementations wehere requestGatewayToken was always available
            requestGatewayToken: () => {
                var _a, _b, _c, _d, _e;
                return ((_b = (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.onShow)
                    ? (_e = (_d = (_c = gatewayClientCoreInst.current) === null || _c === void 0 ? void 0 : _c.ui) === null || _d === void 0 ? void 0 : _d.onShow) === null || _e === void 0 ? void 0 : _e.call(_d)
                    : noRequestGatewayTokenFn;
            },
            gatewayStatus: (clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.gatewayStatus) || GatewayStatus.UNKNOWN,
            gatewayToken: clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.gatewayToken,
            gatewayTokenTransaction: clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.gatewayTokenTransaction,
            pendingRequests: clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.pendingRequests,
        } }, { children: _jsxs(_Fragment, { children: [children, ((_f = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _f === void 0 ? void 0 : _f.url) && ((_g = gatewayClientCoreInst.current) === null || _g === void 0 ? void 0 : _g.instanceId) && (_jsx("div", Object.assign({ "data-testid": TESTID_WRAPPER_CONTAINER, hidden: !((_h = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _h === void 0 ? void 0 : _h.isVisible) }, { children: _jsx(Wrapper, Object.assign({ "data-testid": TESTID_WRAPPER, onClose: () => {
                            var _a, _b, _c;
                            (_c = (_b = (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.onHide) === null || _c === void 0 ? void 0 : _c.call(_b);
                        }, wrapper: wrapper, logo: logo, loaded: (_j = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _j === void 0 ? void 0 : _j.isLoaded, loading: (_k = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _k === void 0 ? void 0 : _k.isLoading }, { children: _jsx(IframeResizer, { "data-testid": TESTID_IFRAME, src: (_l = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _l === void 0 ? void 0 : _l.url, id: `${IFRAME_ID}_${(_m = gatewayClientCoreInst.current) === null || _m === void 0 ? void 0 : _m.instanceId}`, style: {
                                width: '1px',
                                minWidth: '100%',
                                border: 'none',
                                backgroundColor: darkMode ? 'rgb(30, 41, 59)' : 'rgb(255, 255, 255)',
                                height: '26px',
                                transition: 'height 0.25s ease',
                                pointerEvents: !((_o = clientCoreOutput === null || clientCoreOutput === void 0 ? void 0 : clientCoreOutput.ui) === null || _o === void 0 ? void 0 : _o.isLoading) ? 'auto' : 'none', // disables user input during loading
                            }, heightCalculationMethod: "min", checkOrigin: false, onLoad: () => {
                                var _a, _b, _c;
                                (_c = (_b = (_a = gatewayClientCoreInst.current) === null || _a === void 0 ? void 0 : _a.ui) === null || _b === void 0 ? void 0 : _b.onLoad) === null || _c === void 0 ? void 0 : _c.call(_b);
                            }, inPageLinks: true, allow: "camera; screen-wake-lock", allowFullScreen: true, frameBorder: "0" }) })) })))] }) })));
};
export const useGateway = () => useContext(GatewayContext);

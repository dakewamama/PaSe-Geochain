import { DEFAULT_MAX_CLIENT_SENDS_RETRIES } from '../utils/defaults';
import { CivicPassMessageAction, CivicPassMessageEventResult } from '../types/civicPass';
import { ExtendedGatewayStatus, InternalGatewayStatus } from '../types/gateway';
import { GatewayCoreState } from '../types/gatewayCore';
import { payerIsWalletOwner } from './common';

export const handleChainError = (state: GatewayCoreState): InternalGatewayStatus => {
  if (
    state.inputs.civicPass.received?.event === CivicPassMessageEventResult.FAILURE &&
    state.inputs.civicPass.received?.action === CivicPassMessageAction.CHAIN_ERROR
  ) {
    const isRefreshFlow = !!state.inputs.gatewayToken?.received;

    // handle the case where the user didn't send the client-sends transaction
    // TODO use a different civicPass action to differentiate between failed send transactions and failed signMessages
    // TODO make the number of attempts configurable
    if (
      state.internal.chainTransaction?.error &&
      (state.internal.chainTransaction.attempts || 0) <=
        (state.inputs.parameters?.options?.clientSendsMaxRetries || DEFAULT_MAX_CLIENT_SENDS_RETRIES)
    ) {
      if (isRefreshFlow) {
        return payerIsWalletOwner(state)
          ? ExtendedGatewayStatus.REFRESH_AWAITING_TRANSACTION_SEND
          : ExtendedGatewayStatus.REFRESH_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
      }

      return payerIsWalletOwner(state)
        ? ExtendedGatewayStatus.ISSUANCE_AWAITING_TRANSACTION_SEND
        : ExtendedGatewayStatus.ISSUANCE_AWAITING_THIRD_PARTY_TRANSACTION_SEND;
    }

    // The user tried to send the transaction, but it failed too many times
    // No need to restart the flow, instead we will request a new transaction

    if (isRefreshFlow) {
      return payerIsWalletOwner(state)
        ? ExtendedGatewayStatus.REFRESH_CLIENT_SENDS_REQUEST_NEW_TX
        : ExtendedGatewayStatus.REFRESH_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
    }

    return payerIsWalletOwner(state)
      ? ExtendedGatewayStatus.ISSUANCE_CLIENT_SENDS_REQUEST_NEW_TX
      : ExtendedGatewayStatus.ISSUANCE_CLIENT_THIRD_PARTY_SENDS_REQUEST_NEW_TX;
  }
  return state.internal?.status as InternalGatewayStatus;
};

export const handleGatekeeperError = (state: GatewayCoreState): InternalGatewayStatus => {
  const isRefreshFlow = !!state.inputs.gatewayToken.received;
  if (
    state.inputs.civicPass.received?.event === CivicPassMessageEventResult.FAILURE &&
    state.inputs.civicPass.received?.action === CivicPassMessageAction.ERROR
  ) {
    return isRefreshFlow ? ExtendedGatewayStatus.RESTART_REFRESH : ExtendedGatewayStatus.RESTART;
  }
  return state.internal?.status as InternalGatewayStatus;
};

export const handleUserValidationFailed = (state: GatewayCoreState): InternalGatewayStatus =>
  state.inputs.parameters?.options?.disableAutoRestartOnValidationFailure
    ? ExtendedGatewayStatus.USER_VALIDATION_FAILED
    : ExtendedGatewayStatus.RESTART;

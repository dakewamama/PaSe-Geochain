import * as R from 'ramda';
import { ExtendedGatewayStatus, GatewayCoreState, GatewayStatus, InternalGatewayStatus } from '../../src';
import { computeFlowParameters } from '../../src/state/flowParameters';
import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import { CivicPassMessageAction } from '../../src/types/civicPass';
import { DEFAULT_FLOW_ID_PREFIX } from '../../src/utils/flow';
// Auto-generated by 'yarn generate-version' from package.json
// Done on prepublish and pretest.
import { VERSION as CORE_VERSION } from '../../src/version';

chai.use(chaiSubset);
const sandbox = sinon.createSandbox();
const { expect } = chai;

describe('computeFlowParameters', () => {
  let state: GatewayCoreState;
  beforeEach(() => {
    state = {
      inputs: {
        parameters: {
          wallet: {
            address: 'address',
          },
          referrer: 'referrer',
          domain: 'domain',
        },
      },
      internal: {
        instanceId: 'instanceId',
        chainDetails: {
          chainType: 'chainType',
          chainNetwork: 'chainNetwork',
        },
      },
    } as unknown as GatewayCoreState;
  });
  afterEach(sandbox.restore);
  context('with no wallet, chainDetails, or instanceId', () => {
    beforeEach(() => {
      state = R.pipe(
        R.assocPath(['inputs', 'parameters', 'wallet'], undefined),
        R.assocPath(['internal', 'instanceId'], undefined),
        R.assocPath(['internal', 'chainDetails'], undefined)
      )(state) as GatewayCoreState;
    });
    it('should return null', () => {
      const computedInternalStatus = GatewayStatus.UNKNOWN;
      const result = computeFlowParameters(state, computedInternalStatus);
      expect(result).to.be.null;
    });
  });

  context('with computedInternalStatus of UNKNOWN', () => {
    it('should return null', () => {
      const computedInternalStatus = GatewayStatus.UNKNOWN;
      const result = computeFlowParameters(state, computedInternalStatus);
      expect(result).to.be.null;
    });
  });

  context('with computedInternalStatus of CHECKING', () => {
    it('should return null', () => {
      // Arrange
      const computedInternalStatus = GatewayStatus.CHECKING;
      // Act
      const result = computeFlowParameters(state, computedInternalStatus);
      // Assert
      expect(result).to.be.null;
    });
  });
  context('action', () => {
    let computedInternalStatus: InternalGatewayStatus;
    beforeEach(() => {
      computedInternalStatus = GatewayStatus.IN_REVIEW;
    });

    it('should return the action from gatewayStatusToCivicPassAction', () => {
      expect(computeFlowParameters(state, computedInternalStatus)).to.containSubset({
        action: CivicPassMessageAction.TOKEN_IN_REVIEW,
      });
    });
  });

  context('flowId', () => {
    let computedInternalStatus: InternalGatewayStatus;
    beforeEach(() => {
      computedInternalStatus = ExtendedGatewayStatus.ISSUANCE_AWAITING_ON_CHAIN_TOKEN;
    });

    context('with an input flowIdPrefix', () => {
      beforeEach(() => {
        state = R.assocPath(['inputs', 'parameters', 'flowIdPrefix'], 'TEST_CORE')(state) as GatewayCoreState;
      });
      it('should return the flowId from getFlowId with the input prefix', () => {
        expect(computeFlowParameters(state, computedInternalStatus)?.flowId).to.match(/TEST_CORE_issuance_/);
      });
    });

    context('with no input flowIdPrefix', () => {
      it('should return the default flowId prefix', () => {
        expect(computeFlowParameters(state, computedInternalStatus)?.flowId).to.match(
          new RegExp(`${DEFAULT_FLOW_ID_PREFIX}_issuance_`, 'gi')
        );
      });
    });
  });

  context('referrer and domain', () => {
    it('should return the referrer from the parameters', () => {
      expect(computeFlowParameters(state, GatewayStatus.ACTIVE)).to.containSubset({
        referrer: 'referrer',
      });
    });
    it('should return the domain from the parameters', () => {
      expect(computeFlowParameters(state, GatewayStatus.ACTIVE)).to.containSubset({
        domain: 'domain',
      });
    });
  });

  context('hideWalletPrompts', () => {
    beforeEach(() => {
      state = R.assocPath(['inputs', 'parameters', 'options', 'hideWalletPrompts'], true)(state) as GatewayCoreState;
    });
    it('should be null if the payer is not present', () => {
      expect(computeFlowParameters(state, GatewayStatus.ACTIVE)).to.not.containSubset({
        hideWalletPrompts: true,
      });
    });

    it('should be null if the payer is equal to the wallet', () => {
      state = R.assocPath(['inputs', 'parameters', 'payer'], 'address')(state) as GatewayCoreState;
      expect(computeFlowParameters(state, GatewayStatus.ACTIVE)).to.not.containSubset({
        hideWalletPrompts: true,
      });
    });

    it('should be returned if the payer is different from the wallet', () => {
      state = R.assocPath(['inputs', 'parameters', 'payer'], 'payer-address')(state) as GatewayCoreState;
      expect(computeFlowParameters(state, GatewayStatus.ACTIVE)).to.containSubset({
        hideWalletPrompts: true,
      });
    });
  });
  context('civicClient version', () => {
    context('with xCivicClientHeader param passed in', () => {
      beforeEach(() => {
        state = R.assocPath<string, GatewayCoreState>(
          ['inputs', 'parameters', 'xCivicClientHeader'],
          '@civic/gateway-client-react:1.1.1'
        )(state);
      });
      it('should use the passed-in version', () => {
        expect(computeFlowParameters(state, GatewayStatus.ACTIVE)?.civicClient).to.equal(
          '@civic/gateway-client-react:1.1.1'
        );
      });
    });
    context('with no xCivicClientHeader param passed in', () => {
      it('should use the core package version', () => {
        expect(CORE_VERSION.startsWith('@civic/gateway-client-core')).to.be.true;
        expect(computeFlowParameters(state, GatewayStatus.ACTIVE)?.civicClient).to.equal(CORE_VERSION);
      });
    });
    context('with empty xCivicClientHeader param passed in', () => {
      beforeEach(() => {
        state = R.assocPath<string, GatewayCoreState>(['inputs', 'parameters', 'xCivicClientHeader'], '')(state);
      });
      it('should use the core package version', () => {
        expect(computeFlowParameters(state, GatewayStatus.ACTIVE)?.civicClient).to.equal(CORE_VERSION);
      });
    });
  });
});

import chai from 'chai';
import chaiSubset from 'chai-subset';
import sinon from 'sinon';
import { ChainClientInterface, ChainType, GatewayCoreState } from '../src';
import { GatekeeperClient } from '../src/gatekeeperClient';
import { Issuance } from '../src/issuance';
import { createGatewayCoreStore, Store } from '../src/state/state';
import { CivicPassMessageAction, CivicPassMessageEventResult, ValidationStatus } from '../src/types/civicPass';
import { InputStatus } from '../src/types/fetch';
import { GatekeeperAPIStatus, GatekeeperClientConfig, RequestTokenIssuanceResponse } from '../src/types/gatekeeperApi';
import { IntegrationTestHelpers, sleep } from './testSupport';

chai.use(chaiSubset);
const { expect } = chai;

const sandbox = sinon.createSandbox();

describe('issuance tests', () => {
  let fetchImplementationStub: any;

  let gatewayCoreStore: Store;

  let abortController: AbortController;
  let gatekeeperClient: GatekeeperClient;
  let chainImplementation: ChainClientInterface;
  let setStateStub: sinon.SinonStub<any[], any>;
  let getStateStub: sinon.SinonStub<any[], any>;
  let issuance: Issuance;
  let realGatewayCoreStore: Store;
  afterEach(() => {
    sandbox.restore();
    issuance?.abort();
  });

  afterEach(sandbox.restore);

  let handleTransactionStub: sinon.SinonStub<any[], any>;
  beforeEach(() => {
    abortController = new AbortController();

    gatewayCoreStore = createGatewayCoreStore({ name: 'test' });
    setStateStub = sinon.stub();
    getStateStub = sinon.stub();
    gatewayCoreStore.setState = setStateStub;
    gatewayCoreStore.getState = getStateStub;

    fetchImplementationStub = sandbox.stub();

    const config: GatekeeperClientConfig = {
      abortController: abortController,
      baseUrl: 'https://api.example.com',
      fetchImplementation: fetchImplementationStub,
      numRetries: 3,
      walletAddress: '0x123',
      stage: 'prod',
      queryParams: { network: 'test_network', gatekeeperNetworkAddress: 'test_gatekeeperNetworkAddress' },
      chainType: ChainType.ETHEREUM,
    };
    handleTransactionStub = sandbox.stub();
    chainImplementation = {
      httpConfig: {
        baseUrl: 'https://example.com',
        queryParams: {
          network: '0x123',
        },
        headers: {},
      },
      handleTransaction: handleTransactionStub,
    } as unknown as ChainClientInterface;

    // Initialize the GatekeeperClient with the stubbed fetch
    gatekeeperClient = new GatekeeperClient(config);
    gatekeeperClient.requestGatewayTokenFromGatekeeper = sandbox.stub().resolves({ state: GatekeeperAPIStatus.ISSUED });
    gatekeeperClient.updateTransactionStatus = sandbox.stub().resolves();
  });

  context('clearStateBeforeGatekeeperRequest', () => {
    it('should set state with initial values', async () => {
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      issuance.clearStateBeforeGatekeeperRequest();
      expect(setStateStub.callCount).to.eq(1);
    });
  });

  context('gatekeeperRequest', () => {
    it('should throw an error if there is no civicPass received data', async () => {
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: undefined,
          },
        },
      } as unknown as GatewayCoreState;
      return expect(issuance.gatekeeperRequest('payer', state)).to.be.rejectedWith('Missing civicPass payload');
    });

    it('should throw an error if there is no civicPass input payload', async () => {
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: {
              payload: undefined,
            },
          },
        },
      } as GatewayCoreState;
      return expect(issuance.gatekeeperRequest('payer', state)).to.be.rejectedWith('Missing civicPass payload');
    });

    it('should call requestGatewayTokenFromGatekeeper with the correct parameters', async () => {
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: {
              payload: { test: true },
            },
          },
        },
      } as unknown as GatewayCoreState;
      await issuance.gatekeeperRequest('payer', state);
      expect(gatekeeperClient.requestGatewayTokenFromGatekeeper).to.have.been.calledOnceWith({
        payload: { test: true },
        payer: 'payer',
      });
    });
  });

  context('statusHasValidToken', () => {
    it('should return false if there is no token receoved in state', () => {
      getStateStub.returns({
        inputs: {
          gatewayToken: {
            received: undefined,
          },
        },
      });
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const status = issuance.statusHasValidToken();
      expect(getStateStub).to.have.been.calledOnce;
      expect(status).to.be.false;
    });

    it('should return true if gatewayToken is present', () => {
      getStateStub.returns({
        inputs: {
          gatewayToken: {
            received: {
              state: 'ACTIVE',
              expiryTime: 12345678,
            },
          },
        },
      });
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const status = issuance.statusHasValidToken();
      expect(getStateStub).to.have.been.calledOnce;
      expect(status).to.be.true;
    });
  });

  context('sendTransaction', () => {
    context('with no handleTransaction', () => {
      it('should throw an error', () => {
        getStateStub.returns({
          inputs: {
            gatekeeperRecord: {
              status: InputStatus.COMPLETE,
              received: {
                state: GatekeeperAPIStatus.REQUESTED,
                transaction: 'test_transaction',
              },
            },
          },
        });
        chainImplementation.handleTransaction = undefined;
        issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
        return expect(issuance.sendTransaction()).to.be.rejectedWith(
          'No handleTransaction defined on chainImplementation'
        );
      });
    });

    context('with no gatekeeperRecord received transaction', () => {
      it('should throw an error', () => {
        getStateStub.returns({
          inputs: {
            gatekeeperRecord: {
              received: {
                transaction: undefined,
              },
            },
          },
        });
        issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
        return expect(issuance.sendTransaction()).to.be.rejectedWith('Missing gatekeeperRecord payload');
      });
    });

    context('with a valid gatekeeperRecord received transaction', () => {
      beforeEach(() => {
        realGatewayCoreStore = createGatewayCoreStore({ name: 'test' });
        realGatewayCoreStore.setState((draft) => {
          draft.inputs.gatekeeperRecord = {
            status: InputStatus.COMPLETE,
            received: {
              state: GatekeeperAPIStatus.REQUESTED,
              transaction: 'test_transaction',
            },
          };
        });
      });

      context('with a successful transaction being sent', () => {
        beforeEach(() => {
          handleTransactionStub.withArgs('test_transaction').resolves('txId');
        });

        it('should update the sentTxId in state', async () => {
          issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
          await issuance.sendTransaction();
          await sleep(100);
          const fullState = realGatewayCoreStore.getState();
          expect(fullState.internal?.chainTransaction?.sentTxId).to.eq('txId');
        });

        it('should patch the txId', async () => {
          issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
          await issuance.sendTransaction();
          expect(gatekeeperClient.updateTransactionStatus).to.have.been.calledOnceWith('txId');
        });
      });

      context('with GKN frontendPollingTimeoutSeconds set', () => {
        it('should return the correct frontendPollingTimeoutSeconds', async () => {
          handleTransactionStub.resolves('txId');

          getStateStub.returns({
            internal: {
              chainDetails: { chainType: ChainType.ETHEREUM, chainNetwork: 'test_network' },
            },
            inputs: {
              gatekeeperNetworkData: {
                status: InputStatus.COMPLETE,
                received: {
                  id: 'test_id',
                  chains: { ethereum: { frontendPollingTimeoutSeconds: 123 } },
                },
              },
              gatekeeperRecord: {
                status: InputStatus.COMPLETE,
                received: {
                  state: GatekeeperAPIStatus.REQUESTED,
                  transaction: 'test_transaction',
                },
              },
            },
          });

          issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
          await issuance.sendTransaction();
          expect(chainImplementation.handleTransaction).to.have.been.calledOnceWith('test_transaction', 123);
        });
      });

      context('with an error during transaction sending', () => {
        beforeEach(() => {
          handleTransactionStub.withArgs('test_transaction').rejects(new Error('test_error'));
        });
        it('should update the error in state', async () => {
          issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
          await issuance.sendTransaction();
          await sleep(100);
          const fullState = realGatewayCoreStore.getState();
          expect(fullState.internal?.chainTransaction?.error?.message).to.eq('test_error');
        });
      });
    });
  });

  context('makeGatekeeperRequest', () => {
    context('with no flowId', () => {
      it('should throw an error', async () => {
        getStateStub.returns({
          inputs: {
            civicPass: {
              received: undefined,
            },
          },
        });
        issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
        return expect(issuance.makeGatekeeperRequest({ payer: 'payer' })).to.be.rejectedWith('Missing flowId');
      });
    });

    context('with a valid received payload', () => {
      context('with a successful request', () => {
        beforeEach(() => {
          const testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
          realGatewayCoreStore = testHelpers.getInitializedStore();
          realGatewayCoreStore.setState((draft) => {
            draft.inputs.civicPass = {
              status: InputStatus.COMPLETE,
              received: {
                event: CivicPassMessageEventResult.SUCCESS,
                action: CivicPassMessageAction.ISSUANCE,
                payload: { status: ValidationStatus.COMPLETED },
              },
            };
          });
        });

        it('should update status and received', async () => {
          issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
          issuance.makeGatekeeperRequest({ payer: 'payer' });
          await sleep(100);
          const fullState = realGatewayCoreStore.getState();
          expect(fullState.inputs.gatekeeperRecord.status).to.eq(InputStatus.COMPLETE);
          expect(fullState.inputs.gatekeeperRecord.received).to.deep.eq({ state: GatekeeperAPIStatus.ISSUED });
        });
      });
    });

    context('freshTransactionGatekeeperRequest', () => {
      it('should call gatekeeper client fetchFreshTransaction', async () => {
        const fetchFreshTransactionStub = sandbox
          .stub(GatekeeperClient.prototype, 'fetchFreshTransaction')
          .resolves({ status: GatekeeperAPIStatus.REQUESTED } as RequestTokenIssuanceResponse);
        issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
        issuance.freshTransactionGatekeeperRequest('payer');
        expect(fetchFreshTransactionStub).calledWith({ payer: 'payer' });
      });
    });
  });

  context('retrieveFreshTransaction', () => {
    beforeEach(() => {
      const testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
      realGatewayCoreStore = testHelpers.getInitializedStore();
      realGatewayCoreStore.setState((draft) => {
        draft.inputs.civicPass = {
          status: InputStatus.COMPLETE,
          received: {
            event: CivicPassMessageEventResult.SUCCESS,
            action: CivicPassMessageAction.ISSUANCE,
            payload: { status: ValidationStatus.COMPLETED },
          },
        };
      });
    });

    it('should throw an error if there is no civicPass payload', async () => {
      issuance = new Issuance(gatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const state = {
        inputs: {
          civicPass: {
            received: undefined,
          },
        },
      } as unknown as GatewayCoreState;
      getStateStub.returns(state);
      return expect(issuance.retrieveFreshTransaction('payer')).to.be.rejectedWith('Missing civicPass payload');
    });

    it('should call gatekeeperRequest with the correct parameters', async () => {
      issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      sandbox.stub(issuance, 'gatekeeperRequest').resolves({ state: GatekeeperAPIStatus.ISSUED, status: 200 });
      await issuance.retrieveFreshTransaction('payer');
      expect(issuance.gatekeeperRequest).to.have.been.calledOnceWith('payer');
    });

    it('should set the state correctly on successful request', async () => {
      issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      sandbox.stub(issuance, 'gatekeeperRequest').resolves({ state: GatekeeperAPIStatus.ISSUED, status: 200 });
      await issuance.retrieveFreshTransaction('payer');
      const fullState = realGatewayCoreStore.getState();
      expect(fullState.inputs.gatekeeperRecord.status).to.eq(InputStatus.COMPLETE);
      expect(fullState.inputs.gatekeeperRecord.received).to.deep.eq({ state: GatekeeperAPIStatus.ISSUED, status: 200 });
    });

    it('should set the error state correctly on failed request', async () => {
      issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      sandbox.stub(issuance, 'gatekeeperRequest').rejects(new Error('test_error'));
      await issuance.retrieveFreshTransaction('payer');
      await sleep(100);
      const fullState = realGatewayCoreStore.getState();
      expect(fullState.inputs.gatekeeperRecord.status).to.eq(InputStatus.ERROR);
      expect((fullState.inputs.gatekeeperRecord.error as Error).message).to.eq('test_error');
    });
  });

  context('restartDataCollection', () => {
    beforeEach(() => {
      const testHelpers = new IntegrationTestHelpers(sandbox, { clientSends: false });
      realGatewayCoreStore = testHelpers.getInitializedStore();
      realGatewayCoreStore.setState((draft) => {
        draft.inputs.civicPass = {
          status: InputStatus.COMPLETE,
          received: {
            event: CivicPassMessageEventResult.SUCCESS,
            action: CivicPassMessageAction.ISSUANCE,
            payload: { status: ValidationStatus.COMPLETED },
          },
        };
      });
    });

    it('should reset civicPass received data to null', () => {
      issuance = new Issuance(realGatewayCoreStore, chainImplementation, gatekeeperClient, abortController);
      const initialState = {
        inputs: {
          civicPass: {
            received: {
              event: CivicPassMessageEventResult.SUCCESS,
              action: CivicPassMessageAction.ISSUANCE,
              payload: { status: ValidationStatus.COMPLETED },
            },
          },
        },
      } as unknown as GatewayCoreState;

      realGatewayCoreStore.setState((draft) => {
        draft.inputs.civicPass = initialState.inputs.civicPass;
      });

      issuance.restartDataCollection();

      const updatedState = realGatewayCoreStore.getState();
      expect(updatedState.inputs.civicPass.received).to.be.null;
    });
  });
});
